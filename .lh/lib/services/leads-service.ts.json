{
    "sourceFile": "lib/services/leads-service.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 40,
            "patches": [
                {
                    "date": 1741292440169,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1741292452135,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -12,9 +12,10 @@\n   Timestamp,\n   FirestoreDataConverter,\n   DocumentData,\n   QueryDocumentSnapshot,\n-  SnapshotOptions\n+  SnapshotOptions,\n+  writeBatch\n } from 'firebase/firestore';\n import { db } from '@/lib/firebase';\n import { Lead } from '@/data/leads';\n \n@@ -268,9 +269,9 @@\n \n // Seed initial lead data (for development only)\n export async function seedLeads(initialLeads: Lead[]): Promise<void> {\n   try {\n-    const batch = db.batch();\n+    const batch = writeBatch(db);\n     \n     for (const lead of initialLeads) {\n       const newLeadRef = doc(collection(db, LEADS_COLLECTION));\n       const { id, ...leadData } = lead;\n"
                },
                {
                    "date": 1741293640118,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -31,8 +31,9 @@\n     \n     // Convert date strings to Firestore Timestamps\n     return {\n       ...leadData,\n+      position: lead.position || 0, // Ensure position is included\n       createdAt: Timestamp.fromDate(new Date(lead.createdAt)),\n       lastActivity: Timestamp.fromDate(new Date(lead.lastActivity)),\n       // Convert complex activity objects\n       activities: {\n@@ -73,8 +74,9 @@\n       email: data.email,\n       phone: data.phone,\n       status: data.status,\n       value: data.value,\n+      position: data.position || 0, // Include position with default\n       createdAt: data.createdAt.toDate().toISOString(),\n       lastActivity: data.lastActivity.toDate().toISOString(),\n       activities: {\n         calls: data.activities?.calls?.map((call: any) => ({\n@@ -165,12 +167,22 @@\n export async function createLead(leadData: Omit<Lead, 'id'>): Promise<string> {\n   try {\n     const now = new Date().toISOString();\n     \n+    // If no position is specified, find the max position for leads with the same status\n+    let position = leadData.position || 0;\n+    if (!position) {\n+      const leadsWithSameStatus = await getLeadsByStatus(leadData.status || 'New');\n+      position = leadsWithSameStatus.length > 0\n+        ? Math.max(...leadsWithSameStatus.map(lead => lead.position || 0)) + 1\n+        : 1;\n+    }\n+    \n     // Generate a temporary ID for the lead (will be replaced by Firestore's auto ID)\n     const tempLead: Lead = {\n       ...leadData,\n       id: Date.now(), // Temporary ID\n+      position, // Set the calculated position\n       createdAt: now,\n       lastActivity: now,\n       activities: leadData.activities || {\n         calls: [],\n"
                },
                {
                    "date": 1741293648522,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -326,5 +326,27 @@\n   } catch (error) {\n     console.error('Error seeding leads:', error);\n     throw error;\n   }\n+}\n+\n+// Add a batch update function for updating multiple lead positions\n+export async function updateLeadPositions(updates: { id: string; position: number }[]): Promise<void> {\n+  try {\n+    const batch = writeBatch(db);\n+    \n+    // Prepare batch updates\n+    for (const update of updates) {\n+      const leadRef = doc(db, LEADS_COLLECTION, update.id);\n+      batch.update(leadRef, { \n+        position: update.position,\n+        lastActivity: Timestamp.now()\n+      });\n+    }\n+    \n+    // Commit the batch\n+    await batch.commit();\n+  } catch (error) {\n+    console.error('Error updating lead positions:', error);\n+    throw error;\n+  }\n } \n\\ No newline at end of file\n"
                },
                {
                    "date": 1741294640024,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -335,8 +335,14 @@\n     const batch = writeBatch(db);\n     \n     // Prepare batch updates\n     for (const update of updates) {\n+      // Ensure id is a valid string and not NaN\n+      if (!update.id || update.id === 'NaN' || update.id === 'undefined') {\n+        console.warn(`Skipping update for invalid lead ID: ${update.id}`);\n+        continue;\n+      }\n+      \n       const leadRef = doc(db, LEADS_COLLECTION, update.id);\n       batch.update(leadRef, { \n         position: update.position,\n         lastActivity: Timestamp.now()\n"
                },
                {
                    "date": 1741294707245,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -67,9 +67,9 @@\n     const data = snapshot.data(options);\n     \n     // Convert Firestore data to Lead type\n     return {\n-      id: Number(snapshot.id), // Convert string ID to number\n+      id: isNaN(Number(snapshot.id)) ? -1 : Number(snapshot.id), // Convert string ID to number, use -1 for invalid IDs\n       name: data.name,\n       company: data.company,\n       email: data.email,\n       phone: data.phone,\n"
                },
                {
                    "date": 1741294805787,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -335,10 +335,10 @@\n     const batch = writeBatch(db);\n     \n     // Prepare batch updates\n     for (const update of updates) {\n-      // Ensure id is a valid string and not NaN\n-      if (!update.id || update.id === 'NaN' || update.id === 'undefined') {\n+      // Ensure id is a valid string and not NaN or -1\n+      if (!update.id || update.id === 'NaN' || update.id === 'undefined' || update.id === '-1') {\n         console.warn(`Skipping update for invalid lead ID: ${update.id}`);\n         continue;\n       }\n       \n@@ -348,10 +348,14 @@\n         lastActivity: Timestamp.now()\n       });\n     }\n     \n-    // Commit the batch\n-    await batch.commit();\n+    // Only commit if we have valid updates\n+    if (batch._mutations && batch._mutations.length > 0) {\n+      await batch.commit();\n+    } else {\n+      console.log('No valid lead position updates to commit');\n+    }\n   } catch (error) {\n     console.error('Error updating lead positions:', error);\n     throw error;\n   }\n"
                },
                {
                    "date": 1741294816643,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -332,8 +332,9 @@\n // Add a batch update function for updating multiple lead positions\n export async function updateLeadPositions(updates: { id: string; position: number }[]): Promise<void> {\n   try {\n     const batch = writeBatch(db);\n+    let hasUpdates = false;\n     \n     // Prepare batch updates\n     for (const update of updates) {\n       // Ensure id is a valid string and not NaN or -1\n@@ -346,12 +347,13 @@\n       batch.update(leadRef, { \n         position: update.position,\n         lastActivity: Timestamp.now()\n       });\n+      hasUpdates = true;\n     }\n     \n     // Only commit if we have valid updates\n-    if (batch._mutations && batch._mutations.length > 0) {\n+    if (hasUpdates) {\n       await batch.commit();\n     } else {\n       console.log('No valid lead position updates to commit');\n     }\n"
                },
                {
                    "date": 1741294836791,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -65,11 +65,17 @@\n     options?: SnapshotOptions\n   ): Lead {\n     const data = snapshot.data(options);\n     \n+    // Generate a unique negative number for invalid IDs\n+    // This avoids the warning about duplicate keys when multiple items have invalid IDs\n+    const generateUniqueInvalidId = () => {\n+      return -Math.floor(Math.random() * 1000000 + 1);\n+    };\n+    \n     // Convert Firestore data to Lead type\n     return {\n-      id: isNaN(Number(snapshot.id)) ? -1 : Number(snapshot.id), // Convert string ID to number, use -1 for invalid IDs\n+      id: isNaN(Number(snapshot.id)) ? generateUniqueInvalidId() : Number(snapshot.id), // Convert string ID to number, use unique negative number for invalid IDs\n       name: data.name,\n       company: data.company,\n       email: data.email,\n       phone: data.phone,\n"
                },
                {
                    "date": 1741294891610,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -182,12 +182,13 @@\n         ? Math.max(...leadsWithSameStatus.map(lead => lead.position || 0)) + 1\n         : 1;\n     }\n     \n-    // Generate a temporary ID for the lead (will be replaced by Firestore's auto ID)\n+    // Use timestamp for temporary ID (will be replaced by Firestore document ID)\n+    const timestamp = Date.now();\n     const tempLead: Lead = {\n       ...leadData,\n-      id: Date.now(), // Temporary ID\n+      id: timestamp, // Use timestamp as temporary ID\n       position, // Set the calculated position\n       createdAt: now,\n       lastActivity: now,\n       activities: leadData.activities || {\n@@ -198,12 +199,28 @@\n         documents: []\n       }\n     };\n     \n-    const leadsRef = collection(db, LEADS_COLLECTION).withConverter(leadConverter);\n-    const docRef = await addDoc(leadsRef, tempLead);\n+    // Create a reference without the converter first\n+    const leadsCollection = collection(db, LEADS_COLLECTION);\n     \n-    return docRef.id;\n+    // Add the document and get the auto-generated ID\n+    const docRef = await addDoc(leadsCollection, leadConverter.toFirestore(tempLead));\n+    \n+    // Now update the document to set its numeric ID field to match the document ID\n+    // First convert the document ID to a numeric ID\n+    const numericId = parseInt(docRef.id, 10);\n+    \n+    // Only update if the conversion was successful\n+    if (!isNaN(numericId)) {\n+      await updateDoc(docRef, { numericId: numericId });\n+      return docRef.id;\n+    } else {\n+      console.error('Failed to create a valid numeric ID from document ID:', docRef.id);\n+      // Clean up the invalid document\n+      await deleteDoc(docRef);\n+      throw new Error('Failed to create a valid numeric ID for lead');\n+    }\n   } catch (error) {\n     console.error('Error creating lead:', error);\n     throw error;\n   }\n"
                },
                {
                    "date": 1741294918957,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -71,11 +71,21 @@\n     const generateUniqueInvalidId = () => {\n       return -Math.floor(Math.random() * 1000000 + 1);\n     };\n     \n+    // Determine the ID - use numericId if available, otherwise try to parse the document ID\n+    let id: number;\n+    if (data.numericId !== undefined && !isNaN(Number(data.numericId))) {\n+      // Use the numericId field if it exists and is valid\n+      id = Number(data.numericId);\n+    } else {\n+      // Fall back to parsing the document ID\n+      id = isNaN(Number(snapshot.id)) ? generateUniqueInvalidId() : Number(snapshot.id);\n+    }\n+    \n     // Convert Firestore data to Lead type\n     return {\n-      id: isNaN(Number(snapshot.id)) ? generateUniqueInvalidId() : Number(snapshot.id), // Convert string ID to number, use unique negative number for invalid IDs\n+      id: id, // Use the determined ID\n       name: data.name,\n       company: data.company,\n       email: data.email,\n       phone: data.phone,\n"
                },
                {
                    "date": 1741294928491,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -28,11 +28,12 @@\n     // Convert Lead to Firestore format\n     // We need to remove the id since it's stored as the document ID\n     const { id, ...leadData } = lead;\n     \n-    // Convert date strings to Firestore Timestamps\n-    return {\n+    // Add the ID as a numericId field to ensure we can retrieve it later\n+    const firestoreData = {\n       ...leadData,\n+      numericId: id, // Store the numeric ID as a field\n       position: lead.position || 0, // Ensure position is included\n       createdAt: Timestamp.fromDate(new Date(lead.createdAt)),\n       lastActivity: Timestamp.fromDate(new Date(lead.lastActivity)),\n       // Convert complex activity objects\n@@ -58,8 +59,10 @@\n           date: Timestamp.fromDate(new Date(document.date))\n         }))\n       }\n     };\n+    \n+    return firestoreData;\n   },\n   fromFirestore(\n     snapshot: QueryDocumentSnapshot,\n     options?: SnapshotOptions\n"
                },
                {
                    "date": 1741294961612,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -241,8 +241,14 @@\n \n // Update a lead\n export async function updateLead(id: string, leadData: Partial<Lead>): Promise<void> {\n   try {\n+    // Validate the ID before proceeding\n+    if (!id || id === 'NaN' || id === 'undefined' || id === '-1') {\n+      console.error(`Cannot update lead with invalid ID: ${id}`);\n+      throw new Error(`Invalid lead ID: ${id}`);\n+    }\n+    \n     const leadRef = doc(db, LEADS_COLLECTION, id);\n     \n     // Update the last activity timestamp and provided fields\n     const updateData = {\n"
                },
                {
                    "date": 1741294991083,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -402,5 +402,46 @@\n   } catch (error) {\n     console.error('Error updating lead positions:', error);\n     throw error;\n   }\n+}\n+\n+// Migrate existing leads to have numericId field\n+export async function migrateLeadsToNumericId(): Promise<void> {\n+  try {\n+    console.log('Starting lead migration to add numericId field...');\n+    const leadsRef = collection(db, LEADS_COLLECTION);\n+    const querySnapshot = await getDocs(leadsRef);\n+    \n+    const batch = writeBatch(db);\n+    let updateCount = 0;\n+    \n+    querySnapshot.forEach((document) => {\n+      const data = document.data();\n+      \n+      // Only add numericId if it doesn't exist already\n+      if (data.numericId === undefined) {\n+        const parsedId = parseInt(document.id, 10);\n+        \n+        if (!isNaN(parsedId)) {\n+          batch.update(document.ref, { numericId: parsedId });\n+          updateCount++;\n+        } else {\n+          // For documents with unparseable IDs, we'll generate a unique timestamp-based ID\n+          const timestampId = Date.now() + Math.floor(Math.random() * 1000);\n+          batch.update(document.ref, { numericId: timestampId });\n+          updateCount++;\n+        }\n+      }\n+    });\n+    \n+    if (updateCount > 0) {\n+      await batch.commit();\n+      console.log(`Migration complete. Updated ${updateCount} leads with numericId.`);\n+    } else {\n+      console.log('No leads needed migration.');\n+    }\n+  } catch (error) {\n+    console.error('Error migrating leads:', error);\n+    throw error;\n+  }\n } \n\\ No newline at end of file\n"
                },
                {
                    "date": 1741295174610,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -195,45 +195,48 @@\n         ? Math.max(...leadsWithSameStatus.map(lead => lead.position || 0)) + 1\n         : 1;\n     }\n     \n-    // Use timestamp for temporary ID (will be replaced by Firestore document ID)\n-    const timestamp = Date.now();\n-    const tempLead: Lead = {\n+    // Generate a timestamp ID for the lead\n+    const timestampId = Date.now();\n+    \n+    // Prepare the lead with Firestore-compatible data\n+    const firestoreLead = {\n       ...leadData,\n-      id: timestamp, // Use timestamp as temporary ID\n-      position, // Set the calculated position\n-      createdAt: now,\n-      lastActivity: now,\n-      activities: leadData.activities || {\n-        calls: [],\n-        notes: [],\n-        emails: [],\n-        meetings: [],\n-        documents: []\n+      position,\n+      numericId: timestampId, // Set a numeric ID\n+      createdAt: Timestamp.fromDate(new Date(now)),\n+      lastActivity: Timestamp.fromDate(new Date(now)),\n+      activities: {\n+        calls: (leadData.activities?.calls || []).map(a => ({\n+          ...a,\n+          date: Timestamp.fromDate(new Date(a.date))\n+        })),\n+        notes: (leadData.activities?.notes || []).map(a => ({\n+          ...a,\n+          date: Timestamp.fromDate(new Date(a.date))\n+        })),\n+        emails: (leadData.activities?.emails || []).map(a => ({\n+          ...a,\n+          date: Timestamp.fromDate(new Date(a.date))\n+        })),\n+        meetings: (leadData.activities?.meetings || []).map(a => ({\n+          ...a,\n+          date: Timestamp.fromDate(new Date(a.date))\n+        })),\n+        documents: (leadData.activities?.documents || []).map(a => ({\n+          ...a,\n+          date: Timestamp.fromDate(new Date(a.date))\n+        }))\n       }\n     };\n     \n-    // Create a reference without the converter first\n+    // Add the document to Firestore\n     const leadsCollection = collection(db, LEADS_COLLECTION);\n+    const docRef = await addDoc(leadsCollection, firestoreLead);\n     \n-    // Add the document and get the auto-generated ID\n-    const docRef = await addDoc(leadsCollection, leadConverter.toFirestore(tempLead));\n-    \n-    // Now update the document to set its numeric ID field to match the document ID\n-    // First convert the document ID to a numeric ID\n-    const numericId = parseInt(docRef.id, 10);\n-    \n-    // Only update if the conversion was successful\n-    if (!isNaN(numericId)) {\n-      await updateDoc(docRef, { numericId: numericId });\n-      return docRef.id;\n-    } else {\n-      console.error('Failed to create a valid numeric ID from document ID:', docRef.id);\n-      // Clean up the invalid document\n-      await deleteDoc(docRef);\n-      throw new Error('Failed to create a valid numeric ID for lead');\n-    }\n+    console.log(`Created new lead with ID: ${docRef.id}, numericId: ${timestampId}`);\n+    return docRef.id;\n   } catch (error) {\n     console.error('Error creating lead:', error);\n     throw error;\n   }\n"
                },
                {
                    "date": 1741295186477,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -208,25 +208,25 @@\n       lastActivity: Timestamp.fromDate(new Date(now)),\n       activities: {\n         calls: (leadData.activities?.calls || []).map(a => ({\n           ...a,\n-          date: Timestamp.fromDate(new Date(a.date))\n+          date: a.date ? Timestamp.fromDate(new Date(a.date)) : Timestamp.fromDate(new Date(now))\n         })),\n         notes: (leadData.activities?.notes || []).map(a => ({\n           ...a,\n-          date: Timestamp.fromDate(new Date(a.date))\n+          date: a.date ? Timestamp.fromDate(new Date(a.date)) : Timestamp.fromDate(new Date(now))\n         })),\n         emails: (leadData.activities?.emails || []).map(a => ({\n           ...a,\n-          date: Timestamp.fromDate(new Date(a.date))\n+          date: a.date ? Timestamp.fromDate(new Date(a.date)) : Timestamp.fromDate(new Date(now))\n         })),\n         meetings: (leadData.activities?.meetings || []).map(a => ({\n           ...a,\n-          date: Timestamp.fromDate(new Date(a.date))\n+          date: a.date ? Timestamp.fromDate(new Date(a.date)) : Timestamp.fromDate(new Date(now))\n         })),\n         documents: (leadData.activities?.documents || []).map(a => ({\n           ...a,\n-          date: Timestamp.fromDate(new Date(a.date))\n+          date: a.date ? Timestamp.fromDate(new Date(a.date)) : Timestamp.fromDate(new Date(now))\n         }))\n       }\n     };\n     \n"
                },
                {
                    "date": 1741890169235,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -387,9 +387,17 @@\n         console.warn(`Skipping update for invalid lead ID: ${update.id}`);\n         continue;\n       }\n       \n+      // Check if document exists before updating\n       const leadRef = doc(db, LEADS_COLLECTION, update.id);\n+      const docSnap = await getDoc(leadRef);\n+      \n+      if (!docSnap.exists()) {\n+        console.warn(`Skipping update for non-existent lead ID: ${update.id}`);\n+        continue;\n+      }\n+      \n       batch.update(leadRef, { \n         position: update.position,\n         lastActivity: Timestamp.now()\n       });\n"
                },
                {
                    "date": 1741890178983,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -387,21 +387,14 @@\n         console.warn(`Skipping update for invalid lead ID: ${update.id}`);\n         continue;\n       }\n       \n-      // Check if document exists before updating\n       const leadRef = doc(db, LEADS_COLLECTION, update.id);\n-      const docSnap = await getDoc(leadRef);\n-      \n-      if (!docSnap.exists()) {\n-        console.warn(`Skipping update for non-existent lead ID: ${update.id}`);\n-        continue;\n-      }\n-      \n-      batch.update(leadRef, { \n+      // Use set with merge instead of update to handle non-existent documents\n+      batch.set(leadRef, { \n         position: update.position,\n         lastActivity: Timestamp.now()\n-      });\n+      }, { merge: true });\n       hasUpdates = true;\n     }\n     \n     // Only commit if we have valid updates\n"
                },
                {
                    "date": 1741890500234,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -376,34 +376,56 @@\n \n // Add a batch update function for updating multiple lead positions\n export async function updateLeadPositions(updates: { id: string; position: number }[]): Promise<void> {\n   try {\n-    const batch = writeBatch(db);\n-    let hasUpdates = false;\n+    // First, check which documents actually exist\n+    const validUpdates: { id: string; position: number; exists: boolean }[] = [];\n     \n-    // Prepare batch updates\n     for (const update of updates) {\n       // Ensure id is a valid string and not NaN or -1\n       if (!update.id || update.id === 'NaN' || update.id === 'undefined' || update.id === '-1') {\n         console.warn(`Skipping update for invalid lead ID: ${update.id}`);\n         continue;\n       }\n       \n+      try {\n+        // Check if document exists\n+        const leadRef = doc(db, LEADS_COLLECTION, update.id);\n+        const docSnap = await getDoc(leadRef);\n+        validUpdates.push({\n+          ...update,\n+          exists: docSnap.exists()\n+        });\n+      } catch (checkError) {\n+        console.warn(`Error checking if lead ${update.id} exists:`, checkError);\n+      }\n+    }\n+    \n+    // Filter to only include existing documents\n+    const existingDocUpdates = validUpdates.filter(update => update.exists);\n+    \n+    if (existingDocUpdates.length < validUpdates.length) {\n+      console.warn(`Skipping updates for ${validUpdates.length - existingDocUpdates.length} non-existent leads`);\n+    }\n+    \n+    if (existingDocUpdates.length === 0) {\n+      console.log('No valid lead position updates to commit (no existing documents)');\n+      return;\n+    }\n+    \n+    // Now proceed with batch update for existing documents only\n+    const batch = writeBatch(db);\n+    \n+    for (const update of existingDocUpdates) {\n       const leadRef = doc(db, LEADS_COLLECTION, update.id);\n-      // Use set with merge instead of update to handle non-existent documents\n-      batch.set(leadRef, { \n+      batch.update(leadRef, { \n         position: update.position,\n         lastActivity: Timestamp.now()\n-      }, { merge: true });\n-      hasUpdates = true;\n+      });\n     }\n     \n-    // Only commit if we have valid updates\n-    if (hasUpdates) {\n-      await batch.commit();\n-    } else {\n-      console.log('No valid lead position updates to commit');\n-    }\n+    await batch.commit();\n+    console.log(`Successfully updated positions for ${existingDocUpdates.length} leads`);\n   } catch (error) {\n     console.error('Error updating lead positions:', error);\n     throw error;\n   }\n"
                },
                {
                    "date": 1741890612427,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -84,41 +84,57 @@\n       // Fall back to parsing the document ID\n       id = isNaN(Number(snapshot.id)) ? generateUniqueInvalidId() : Number(snapshot.id);\n     }\n     \n+    // Helper function to safely convert Timestamp to ISO string\n+    const safeTimestampToISOString = (timestamp: any) => {\n+      if (!timestamp) return new Date().toISOString(); // Default to current date\n+      if (typeof timestamp.toDate === 'function') {\n+        return timestamp.toDate().toISOString();\n+      }\n+      if (timestamp instanceof Date) {\n+        return timestamp.toISOString();\n+      }\n+      return new Date().toISOString(); // Fallback\n+    };\n+    \n+    // Helper function to safely convert activity date\n+    const safeActivityDateToISOString = (activity: any) => {\n+      if (!activity || !activity.date) return { ...activity, date: new Date().toISOString() };\n+      return {\n+        ...activity,\n+        date: safeTimestampToISOString(activity.date)\n+      };\n+    };\n+    \n     // Convert Firestore data to Lead type\n     return {\n       id: id, // Use the determined ID\n-      name: data.name,\n-      company: data.company,\n-      email: data.email,\n-      phone: data.phone,\n-      status: data.status,\n-      value: data.value,\n+      name: data.name || '',\n+      company: data.company || '',\n+      email: data.email || '',\n+      phone: data.phone || '',\n+      status: data.status || 'New',\n+      value: data.value || '$0',\n       position: data.position || 0, // Include position with default\n-      createdAt: data.createdAt.toDate().toISOString(),\n-      lastActivity: data.lastActivity.toDate().toISOString(),\n+      createdAt: safeTimestampToISOString(data.createdAt),\n+      lastActivity: safeTimestampToISOString(data.lastActivity),\n       activities: {\n-        calls: data.activities?.calls?.map((call: any) => ({\n-          ...call,\n-          date: call.date.toDate().toISOString()\n-        })) || [],\n-        notes: data.activities?.notes?.map((note: any) => ({\n-          ...note,\n-          date: note.date.toDate().toISOString()\n-        })) || [],\n-        emails: data.activities?.emails?.map((email: any) => ({\n-          ...email,\n-          date: email.date.toDate().toISOString()\n-        })) || [],\n-        meetings: data.activities?.meetings?.map((meeting: any) => ({\n-          ...meeting,\n-          date: meeting.date.toDate().toISOString()\n-        })) || [],\n-        documents: data.activities?.documents?.map((document: any) => ({\n-          ...document,\n-          date: document.date.toDate().toISOString()\n-        })) || []\n+        calls: Array.isArray(data.activities?.calls) \n+          ? data.activities.calls.map(safeActivityDateToISOString) \n+          : [],\n+        notes: Array.isArray(data.activities?.notes) \n+          ? data.activities.notes.map(safeActivityDateToISOString) \n+          : [],\n+        emails: Array.isArray(data.activities?.emails) \n+          ? data.activities.emails.map(safeActivityDateToISOString) \n+          : [],\n+        meetings: Array.isArray(data.activities?.meetings) \n+          ? data.activities.meetings.map(safeActivityDateToISOString) \n+          : [],\n+        documents: Array.isArray(data.activities?.documents) \n+          ? data.activities.documents.map(safeActivityDateToISOString) \n+          : []\n       }\n     };\n   }\n };\n"
                },
                {
                    "date": 1741890622198,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -147,9 +147,14 @@\n     const querySnapshot = await getDocs(q);\n     \n     const leads: Lead[] = [];\n     querySnapshot.forEach((doc) => {\n-      leads.push(doc.data());\n+      try {\n+        leads.push(doc.data());\n+      } catch (conversionError) {\n+        console.error(`Error converting lead document ${doc.id}:`, conversionError);\n+        // Skip this document and continue with others\n+      }\n     });\n     \n     return leads;\n   } catch (error) {\n"
                },
                {
                    "date": 1741890634464,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -490,5 +490,58 @@\n   } catch (error) {\n     console.error('Error migrating leads:', error);\n     throw error;\n   }\n+}\n+\n+// Identify problematic leads in the database\n+export async function identifyProblematicLeads(): Promise<string[]> {\n+  try {\n+    console.log('Scanning for problematic leads...');\n+    const leadsRef = collection(db, LEADS_COLLECTION);\n+    const querySnapshot = await getDocs(leadsRef);\n+    \n+    const problematicLeadIds: string[] = [];\n+    \n+    querySnapshot.forEach((doc) => {\n+      try {\n+        const data = doc.data();\n+        \n+        // Check for missing required fields\n+        const missingFields = [];\n+        if (!data.name) missingFields.push('name');\n+        if (!data.status) missingFields.push('status');\n+        if (!data.createdAt) missingFields.push('createdAt');\n+        if (!data.lastActivity) missingFields.push('lastActivity');\n+        \n+        // Check for invalid timestamp fields\n+        const invalidFields = [];\n+        if (data.createdAt && typeof data.createdAt.toDate !== 'function') {\n+          invalidFields.push('createdAt');\n+        }\n+        if (data.lastActivity && typeof data.lastActivity.toDate !== 'function') {\n+          invalidFields.push('lastActivity');\n+        }\n+        \n+        if (missingFields.length > 0 || invalidFields.length > 0) {\n+          console.warn(`Problematic lead found (ID: ${doc.id})`);\n+          if (missingFields.length > 0) {\n+            console.warn(`  Missing fields: ${missingFields.join(', ')}`);\n+          }\n+          if (invalidFields.length > 0) {\n+            console.warn(`  Invalid fields: ${invalidFields.join(', ')}`);\n+          }\n+          problematicLeadIds.push(doc.id);\n+        }\n+      } catch (error) {\n+        console.error(`Error analyzing lead ${doc.id}:`, error);\n+        problematicLeadIds.push(doc.id);\n+      }\n+    });\n+    \n+    console.log(`Found ${problematicLeadIds.length} problematic leads`);\n+    return problematicLeadIds;\n+  } catch (error) {\n+    console.error('Error identifying problematic leads:', error);\n+    throw error;\n+  }\n } \n\\ No newline at end of file\n"
                },
                {
                    "date": 1741892143221,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -437,12 +437,13 @@\n     const batch = writeBatch(db);\n     \n     for (const update of existingDocUpdates) {\n       const leadRef = doc(db, LEADS_COLLECTION, update.id);\n-      batch.update(leadRef, { \n+      // Use set with merge to ensure the update is applied even if some fields are missing\n+      batch.set(leadRef, { \n         position: update.position,\n         lastActivity: Timestamp.now()\n-      });\n+      }, { merge: true });\n     }\n     \n     await batch.commit();\n     console.log(`Successfully updated positions for ${existingDocUpdates.length} leads`);\n"
                },
                {
                    "date": 1741895018136,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -271,17 +271,27 @@\n       console.error(`Cannot update lead with invalid ID: ${id}`);\n       throw new Error(`Invalid lead ID: ${id}`);\n     }\n     \n+    console.log(`Updating lead ${id} with data:`, JSON.stringify(leadData));\n+    \n     const leadRef = doc(db, LEADS_COLLECTION, id);\n     \n+    // Check if document exists before updating\n+    const docSnap = await getDoc(leadRef);\n+    if (!docSnap.exists()) {\n+      console.error(`Cannot update non-existent lead with ID: ${id}`);\n+      throw new Error(`Lead with ID ${id} does not exist`);\n+    }\n+    \n     // Update the last activity timestamp and provided fields\n     const updateData = {\n       ...leadData,\n       lastActivity: Timestamp.now()\n     };\n     \n     await updateDoc(leadRef, updateData);\n+    console.log(`Successfully updated lead ${id}`);\n   } catch (error) {\n     console.error('Error updating lead:', error);\n     throw error;\n   }\n"
                },
                {
                    "date": 1741895032616,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -407,8 +407,10 @@\n \n // Add a batch update function for updating multiple lead positions\n export async function updateLeadPositions(updates: { id: string; position: number }[]): Promise<void> {\n   try {\n+    console.log(`Attempting to update positions for ${updates.length} leads:`, JSON.stringify(updates));\n+    \n     // First, check which documents actually exist\n     const validUpdates: { id: string; position: number; exists: boolean }[] = [];\n     \n     for (const update of updates) {\n@@ -442,8 +444,10 @@\n       console.log('No valid lead position updates to commit (no existing documents)');\n       return;\n     }\n     \n+    console.log(`Proceeding with batch update for ${existingDocUpdates.length} leads`);\n+    \n     // Now proceed with batch update for existing documents only\n     const batch = writeBatch(db);\n     \n     for (const update of existingDocUpdates) {\n"
                },
                {
                    "date": 1742493107312,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -409,8 +409,13 @@\n export async function updateLeadPositions(updates: { id: string; position: number }[]): Promise<void> {\n   try {\n     console.log(`Attempting to update positions for ${updates.length} leads:`, JSON.stringify(updates));\n     \n+    if (updates.length === 0) {\n+      console.log('No lead position updates to process');\n+      return;\n+    }\n+    \n     // First, check which documents actually exist\n     const validUpdates: { id: string; position: number; exists: boolean }[] = [];\n     \n     for (const update of updates) {\n@@ -451,15 +456,19 @@\n     const batch = writeBatch(db);\n     \n     for (const update of existingDocUpdates) {\n       const leadRef = doc(db, LEADS_COLLECTION, update.id);\n+      \n       // Use set with merge to ensure the update is applied even if some fields are missing\n       batch.set(leadRef, { \n         position: update.position,\n         lastActivity: Timestamp.now()\n       }, { merge: true });\n+      \n+      console.log(`Added update to batch: Lead ${update.id} → Position ${update.position}`);\n     }\n     \n+    // Commit the batch\n     await batch.commit();\n     console.log(`Successfully updated positions for ${existingDocUpdates.length} leads`);\n   } catch (error) {\n     console.error('Error updating lead positions:', error);\n"
                },
                {
                    "date": 1742493129851,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -142,9 +142,10 @@\n // Get all leads\n export async function getLeads(): Promise<Lead[]> {\n   try {\n     const leadsRef = collection(db, LEADS_COLLECTION).withConverter(leadConverter);\n-    const q = query(leadsRef, orderBy('lastActivity', 'desc'));\n+    // We don't sort by position here because we want to sort by status and position later\n+    const q = query(leadsRef);\n     const querySnapshot = await getDocs(q);\n     \n     const leads: Lead[] = [];\n     querySnapshot.forEach((doc) => {\n@@ -155,9 +156,35 @@\n         // Skip this document and continue with others\n       }\n     });\n     \n-    return leads;\n+    // Group leads by status\n+    const leadsByStatus: Record<string, Lead[]> = {};\n+    \n+    leads.forEach(lead => {\n+      if (!leadsByStatus[lead.status]) {\n+        leadsByStatus[lead.status] = [];\n+      }\n+      leadsByStatus[lead.status].push(lead);\n+    });\n+    \n+    // Sort each status group by position\n+    Object.keys(leadsByStatus).forEach(status => {\n+      leadsByStatus[status].sort((a, b) => {\n+        // Use default position 999 for leads without a position\n+        const posA = a.position !== undefined && !isNaN(a.position) ? a.position : 999;\n+        const posB = b.position !== undefined && !isNaN(b.position) ? b.position : 999;\n+        return posA - posB;\n+      });\n+    });\n+    \n+    // Flatten the leads back into a single array\n+    const sortedLeads: Lead[] = [];\n+    Object.values(leadsByStatus).forEach(statusLeads => {\n+      sortedLeads.push(...statusLeads);\n+    });\n+    \n+    return sortedLeads;\n   } catch (error) {\n     console.error('Error getting leads:', error);\n     throw error;\n   }\n"
                },
                {
                    "date": 1742493412737,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -451,8 +451,14 @@\n         console.warn(`Skipping update for invalid lead ID: ${update.id}`);\n         continue;\n       }\n       \n+      // Ensure position is a valid number\n+      if (update.position === undefined || isNaN(update.position)) {\n+        console.warn(`Skipping update for lead ${update.id} with invalid position: ${update.position}`);\n+        continue;\n+      }\n+      \n       try {\n         // Check if document exists\n         const leadRef = doc(db, LEADS_COLLECTION, update.id);\n         const docSnap = await getDoc(leadRef);\n@@ -484,20 +490,36 @@\n     \n     for (const update of existingDocUpdates) {\n       const leadRef = doc(db, LEADS_COLLECTION, update.id);\n       \n-      // Use set with merge to ensure the update is applied even if some fields are missing\n-      batch.set(leadRef, { \n+      // Log each update for debugging\n+      console.log(`Adding to batch: Lead ${update.id} → Position ${update.position}`);\n+      \n+      // Use updateDoc instead of set with merge to ensure we're only updating the fields we want\n+      // This prevents any potential issues with merge behavior\n+      batch.update(leadRef, { \n         position: update.position,\n         lastActivity: Timestamp.now()\n-      }, { merge: true });\n-      \n-      console.log(`Added update to batch: Lead ${update.id} → Position ${update.position}`);\n+      });\n     }\n     \n-    // Commit the batch\n+    // Commit the batch and verify success\n     await batch.commit();\n-    console.log(`Successfully updated positions for ${existingDocUpdates.length} leads`);\n+    console.log(`Successfully committed position updates for ${existingDocUpdates.length} leads`);\n+    \n+    // Double-check that updates were applied correctly\n+    for (const update of existingDocUpdates.slice(0, 2)) { // Check first 2 for validation\n+      try {\n+        const leadRef = doc(db, LEADS_COLLECTION, update.id);\n+        const docSnap = await getDoc(leadRef);\n+        if (docSnap.exists()) {\n+          const data = docSnap.data();\n+          console.log(`Verification: Lead ${update.id} position is now ${data.position}`);\n+        }\n+      } catch (verifyError) {\n+        console.warn(`Error verifying update for lead ${update.id}:`, verifyError);\n+      }\n+    }\n   } catch (error) {\n     console.error('Error updating lead positions:', error);\n     throw error;\n   }\n"
                },
                {
                    "date": 1742493429210,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -298,8 +298,18 @@\n       console.error(`Cannot update lead with invalid ID: ${id}`);\n       throw new Error(`Invalid lead ID: ${id}`);\n     }\n     \n+    // Ensure position is a valid number if provided\n+    if (leadData.position !== undefined) {\n+      if (isNaN(leadData.position)) {\n+        console.error(`Cannot update lead with invalid position: ${leadData.position}`);\n+        throw new Error(`Invalid position value: ${leadData.position}`);\n+      }\n+      // Log position update for debugging\n+      console.log(`Updating lead ${id} position to ${leadData.position}`);\n+    }\n+    \n     console.log(`Updating lead ${id} with data:`, JSON.stringify(leadData));\n     \n     const leadRef = doc(db, LEADS_COLLECTION, id);\n     \n@@ -309,15 +319,28 @@\n       console.error(`Cannot update non-existent lead with ID: ${id}`);\n       throw new Error(`Lead with ID ${id} does not exist`);\n     }\n     \n+    // Get current data to log changes\n+    const currentData = docSnap.data();\n+    \n     // Update the last activity timestamp and provided fields\n     const updateData = {\n       ...leadData,\n       lastActivity: Timestamp.now()\n     };\n     \n     await updateDoc(leadRef, updateData);\n+    \n+    // Verify the update was successful for position changes\n+    if (leadData.position !== undefined) {\n+      const updatedSnap = await getDoc(leadRef);\n+      if (updatedSnap.exists()) {\n+        const newData = updatedSnap.data();\n+        console.log(`Verification: Lead ${id} position changed from ${currentData.position || 'undefined'} to ${newData.position}`);\n+      }\n+    }\n+    \n     console.log(`Successfully updated lead ${id}`);\n   } catch (error) {\n     console.error('Error updating lead:', error);\n     throw error;\n"
                },
                {
                    "date": 1742493447861,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -141,23 +141,39 @@\n \n // Get all leads\n export async function getLeads(): Promise<Lead[]> {\n   try {\n+    console.log('Fetching all leads from database');\n     const leadsRef = collection(db, LEADS_COLLECTION).withConverter(leadConverter);\n-    // We don't sort by position here because we want to sort by status and position later\n+    \n+    // Don't sort in the query - we'll sort by position after grouping by status\n     const q = query(leadsRef);\n     const querySnapshot = await getDocs(q);\n     \n     const leads: Lead[] = [];\n+    let leadsWithoutPosition = 0;\n+    \n     querySnapshot.forEach((doc) => {\n       try {\n-        leads.push(doc.data());\n+        const leadData = doc.data();\n+        \n+        // Log any lead without a valid position for debugging\n+        if (leadData.position === undefined || isNaN(leadData.position)) {\n+          leadsWithoutPosition++;\n+          console.log(`Lead ${leadData.id} (${leadData.name}) has no valid position`);\n+        }\n+        \n+        leads.push(leadData);\n       } catch (conversionError) {\n         console.error(`Error converting lead document ${doc.id}:`, conversionError);\n         // Skip this document and continue with others\n       }\n     });\n     \n+    if (leadsWithoutPosition > 0) {\n+      console.warn(`Found ${leadsWithoutPosition} leads without valid positions`);\n+    }\n+    \n     // Group leads by status\n     const leadsByStatus: Record<string, Lead[]> = {};\n     \n     leads.forEach(lead => {\n@@ -172,18 +188,29 @@\n       leadsByStatus[status].sort((a, b) => {\n         // Use default position 999 for leads without a position\n         const posA = a.position !== undefined && !isNaN(a.position) ? a.position : 999;\n         const posB = b.position !== undefined && !isNaN(b.position) ? b.position : 999;\n+        \n+        // Log sorting comparisons for debugging\n+        // console.log(`Comparing ${a.id} (pos: ${posA}) with ${b.id} (pos: ${posB})`);\n+        \n         return posA - posB;\n       });\n+      \n+      // Log the sorted positions for this status\n+      console.log(`Sorted leads for status \"${status}\": `, \n+        leadsByStatus[status].map(lead => `${lead.id}:${lead.position}`).join(', ')\n+      );\n     });\n     \n     // Flatten the leads back into a single array\n     const sortedLeads: Lead[] = [];\n     Object.values(leadsByStatus).forEach(statusLeads => {\n       sortedLeads.push(...statusLeads);\n     });\n     \n+    console.log(`Retrieved ${sortedLeads.length} leads, sorted by position within each status`);\n+    \n     return sortedLeads;\n   } catch (error) {\n     console.error('Error getting leads:', error);\n     throw error;\n"
                },
                {
                    "date": 1742496788526,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -31,9 +31,10 @@\n     \n     // Add the ID as a numericId field to ensure we can retrieve it later\n     const firestoreData = {\n       ...leadData,\n-      numericId: id, // Store the numeric ID as a field\n+      // We don't need to store the document ID - it's already the document ID\n+      // Just keep numericId field for backward compatibility\n       position: lead.position || 0, // Ensure position is included\n       createdAt: Timestamp.fromDate(new Date(lead.createdAt)),\n       lastActivity: Timestamp.fromDate(new Date(lead.lastActivity)),\n       // Convert complex activity objects\n@@ -68,22 +69,16 @@\n     options?: SnapshotOptions\n   ): Lead {\n     const data = snapshot.data(options);\n     \n-    // Generate a unique negative number for invalid IDs\n-    // This avoids the warning about duplicate keys when multiple items have invalid IDs\n-    const generateUniqueInvalidId = () => {\n-      return -Math.floor(Math.random() * 1000000 + 1);\n-    };\n-    \n-    // Determine the ID - use numericId if available, otherwise try to parse the document ID\n-    let id: number;\n+    // Determine the numeric ID from the numericId field or generate one if needed\n+    let numericId: number;\n     if (data.numericId !== undefined && !isNaN(Number(data.numericId))) {\n       // Use the numericId field if it exists and is valid\n-      id = Number(data.numericId);\n+      numericId = Number(data.numericId);\n     } else {\n-      // Fall back to parsing the document ID\n-      id = isNaN(Number(snapshot.id)) ? generateUniqueInvalidId() : Number(snapshot.id);\n+      // Fall back to generating a timestamp as numericId\n+      numericId = Date.now();\n     }\n     \n     // Helper function to safely convert Timestamp to ISO string\n     const safeTimestampToISOString = (timestamp: any) => {\n@@ -107,9 +102,10 @@\n     };\n     \n     // Convert Firestore data to Lead type\n     return {\n-      id: id, // Use the determined ID\n+      id: snapshot.id, // Use the document ID (string)\n+      numericId,       // Use the numeric ID from data\n       name: data.name || '',\n       company: data.company || '',\n       email: data.email || '',\n       phone: data.phone || '',\n"
                },
                {
                    "date": 1742496808332,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -253,9 +253,9 @@\n   }\n }\n \n // Create a new lead\n-export async function createLead(leadData: Omit<Lead, 'id'>): Promise<string> {\n+export async function createLead(leadData: Omit<Lead, 'id' | 'numericId'>): Promise<string> {\n   try {\n     const now = new Date().toISOString();\n     \n     // If no position is specified, find the max position for leads with the same status\n@@ -304,9 +304,10 @@\n     // Add the document to Firestore\n     const leadsCollection = collection(db, LEADS_COLLECTION);\n     const docRef = await addDoc(leadsCollection, firestoreLead);\n     \n-    console.log(`Created new lead with ID: ${docRef.id}, numericId: ${timestampId}`);\n+    console.log(`Added lead with ID: ${docRef.id}, numericId: ${timestampId}`);\n+    \n     return docRef.id;\n   } catch (error) {\n     console.error('Error creating lead:', error);\n     throw error;\n@@ -641,26 +642,5 @@\n           invalidFields.push('lastActivity');\n         }\n         \n         if (missingFields.length > 0 || invalidFields.length > 0) {\n-          console.warn(`Problematic lead found (ID: ${doc.id})`);\n-          if (missingFields.length > 0) {\n-            console.warn(`  Missing fields: ${missingFields.join(', ')}`);\n-          }\n-          if (invalidFields.length > 0) {\n-            console.warn(`  Invalid fields: ${invalidFields.join(', ')}`);\n-          }\n-          problematicLeadIds.push(doc.id);\n-        }\n-      } catch (error) {\n-        console.error(`Error analyzing lead ${doc.id}:`, error);\n-        problematicLeadIds.push(doc.id);\n-      }\n-    });\n-    \n-    console.log(`Found ${problematicLeadIds.length} problematic leads`);\n-    return problematicLeadIds;\n-  } catch (error) {\n-    console.error('Error identifying problematic leads:', error);\n-    throw error;\n-  }\n-} \n\\ No newline at end of file\n+          console.warn(`\n\\ No newline at end of file\n"
                },
                {
                    "date": 1742496822529,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -642,5 +642,26 @@\n           invalidFields.push('lastActivity');\n         }\n         \n         if (missingFields.length > 0 || invalidFields.length > 0) {\n-          console.warn(`\n\\ No newline at end of file\n+          console.warn(`Problematic lead found (ID: ${doc.id})`);\n+          if (missingFields.length > 0) {\n+            console.warn(`  Missing fields: ${missingFields.join(', ')}`);\n+          }\n+          if (invalidFields.length > 0) {\n+            console.warn(`  Invalid fields: ${invalidFields.join(', ')}`);\n+          }\n+          problematicLeadIds.push(doc.id);\n+        }\n+      } catch (error) {\n+        console.error(`Error analyzing lead ${doc.id}:`, error);\n+        problematicLeadIds.push(doc.id);\n+      }\n+    });\n+    \n+    console.log(`Found ${problematicLeadIds.length} problematic leads`);\n+    return problematicLeadIds;\n+  } catch (error) {\n+    console.error('Error identifying problematic leads:', error);\n+    throw error;\n+  }\n+}\n\\ No newline at end of file\n"
                },
                {
                    "date": 1742497170796,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -104,9 +104,10 @@\n     // Convert Firestore data to Lead type\n     return {\n       id: snapshot.id, // Use the document ID (string)\n       numericId,       // Use the numeric ID from data\n-      name: data.name || '',\n+      firstName: data.firstName || (data.name ? data.name.split(' ')[0] || '' : ''), // Handle migration from name\n+      lastName: data.lastName || (data.name ? data.name.split(' ').slice(1).join(' ') || '' : ''), // Handle migration from name\n       company: data.company || '',\n       email: data.email || '',\n       phone: data.phone || '',\n       status: data.status || 'New',\n"
                },
                {
                    "date": 1742498408135,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -628,19 +628,24 @@\n         const data = doc.data();\n         \n         // Check for missing required fields\n         const missingFields = [];\n-        if (!data.name) missingFields.push('name');\n+        // Don't check for name which doesn't exist in our schema\n+        // if (!data.name) missingFields.push('name');\n         if (!data.status) missingFields.push('status');\n-        if (!data.createdAt) missingFields.push('createdAt');\n-        if (!data.lastActivity) missingFields.push('lastActivity');\n         \n+        // Timestamps can be missing, don't treat as problematic\n+        // if (!data.createdAt) missingFields.push('createdAt');\n+        // if (!data.lastActivity) missingFields.push('lastActivity');\n+        \n         // Check for invalid timestamp fields\n         const invalidFields = [];\n-        if (data.createdAt && typeof data.createdAt.toDate !== 'function') {\n+        if (data.createdAt && typeof data.createdAt === 'object' && \n+            typeof data.createdAt.toDate !== 'function') {\n           invalidFields.push('createdAt');\n         }\n-        if (data.lastActivity && typeof data.lastActivity.toDate !== 'function') {\n+        if (data.lastActivity && typeof data.lastActivity === 'object' && \n+            typeof data.lastActivity.toDate !== 'function') {\n           invalidFields.push('lastActivity');\n         }\n         \n         if (missingFields.length > 0 || invalidFields.length > 0) {\n@@ -662,7 +667,7 @@\n     console.log(`Found ${problematicLeadIds.length} problematic leads`);\n     return problematicLeadIds;\n   } catch (error) {\n     console.error('Error identifying problematic leads:', error);\n-    throw error;\n+    return []; // Return an empty array on error instead of throwing\n   }\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1742501157627,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -36,8 +36,9 @@\n       // Just keep numericId field for backward compatibility\n       position: lead.position || 0, // Ensure position is included\n       createdAt: Timestamp.fromDate(new Date(lead.createdAt)),\n       lastActivity: Timestamp.fromDate(new Date(lead.lastActivity)),\n+      lastTouchpoint: lead.lastTouchpoint ? Timestamp.fromDate(new Date(lead.lastTouchpoint)) : null,\n       // Convert complex activity objects\n       activities: {\n         calls: lead.activities.calls.map(call => ({\n           ...call,\n@@ -114,8 +115,23 @@\n       value: data.value || '$0',\n       position: data.position || 0, // Include position with default\n       createdAt: safeTimestampToISOString(data.createdAt),\n       lastActivity: safeTimestampToISOString(data.lastActivity),\n+      // Address fields\n+      address: data.address || '',\n+      city: data.city || '',\n+      state: data.state || '',\n+      zipCode: data.zipCode || '',\n+      country: data.country || '',\n+      // Lead qualification fields\n+      score: data.score || '',\n+      interest: data.interest || '',\n+      budget: data.budget || '',\n+      timeframe: data.timeframe || '',\n+      source: data.source || '',\n+      nextSteps: data.nextSteps || '',\n+      lastTouchpoint: data.lastTouchpoint ? safeTimestampToISOString(data.lastTouchpoint) : '',\n+      tags: Array.isArray(data.tags) ? data.tags : [],\n       activities: {\n         calls: Array.isArray(data.activities?.calls) \n           ? data.activities.calls.map(safeActivityDateToISOString) \n           : [],\n"
                },
                {
                    "date": 1742501165740,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -36,9 +36,8 @@\n       // Just keep numericId field for backward compatibility\n       position: lead.position || 0, // Ensure position is included\n       createdAt: Timestamp.fromDate(new Date(lead.createdAt)),\n       lastActivity: Timestamp.fromDate(new Date(lead.lastActivity)),\n-      lastTouchpoint: lead.lastTouchpoint ? Timestamp.fromDate(new Date(lead.lastTouchpoint)) : null,\n       // Convert complex activity objects\n       activities: {\n         calls: lead.activities.calls.map(call => ({\n           ...call,\n@@ -115,23 +114,8 @@\n       value: data.value || '$0',\n       position: data.position || 0, // Include position with default\n       createdAt: safeTimestampToISOString(data.createdAt),\n       lastActivity: safeTimestampToISOString(data.lastActivity),\n-      // Address fields\n-      address: data.address || '',\n-      city: data.city || '',\n-      state: data.state || '',\n-      zipCode: data.zipCode || '',\n-      country: data.country || '',\n-      // Lead qualification fields\n-      score: data.score || '',\n-      interest: data.interest || '',\n-      budget: data.budget || '',\n-      timeframe: data.timeframe || '',\n-      source: data.source || '',\n-      nextSteps: data.nextSteps || '',\n-      lastTouchpoint: data.lastTouchpoint ? safeTimestampToISOString(data.lastTouchpoint) : '',\n-      tags: Array.isArray(data.tags) ? data.tags : [],\n       activities: {\n         calls: Array.isArray(data.activities?.calls) \n           ? data.activities.calls.map(safeActivityDateToISOString) \n           : [],\n"
                },
                {
                    "date": 1742502810714,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -347,11 +347,25 @@\n     \n     // Get current data to log changes\n     const currentData = docSnap.data();\n     \n+    // Clean up the data for Firestore (remove undefined values)\n+    const cleanedData: Record<string, any> = {};\n+    for (const [key, value] of Object.entries(leadData)) {\n+      // Skip undefined values - Firestore doesn't accept them\n+      if (value === undefined) continue;\n+      \n+      // Handle tags specifically - ensure it's never undefined\n+      if (key === 'tags' && value === undefined) {\n+        cleanedData[key] = [];\n+      } else {\n+        cleanedData[key] = value;\n+      }\n+    }\n+    \n     // Update the last activity timestamp and provided fields\n     const updateData = {\n-      ...leadData,\n+      ...cleanedData,\n       lastActivity: Timestamp.now()\n     };\n     \n     await updateDoc(leadRef, updateData);\n"
                },
                {
                    "date": 1742502866198,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -270,11 +270,23 @@\n     \n     // Generate a timestamp ID for the lead\n     const timestampId = Date.now();\n     \n+    // Ensure tags is never undefined\n+    const tags = leadData.tags || [];\n+    \n+    // Clean the data for Firestore - replace undefined with null or default values\n+    const cleanedData = { ...leadData };\n+    \n+    // Handle undefined values\n+    if (cleanedData.tags === undefined) cleanedData.tags = [];\n+    if (cleanedData.customFields === undefined) cleanedData.customFields = [];\n+    if (cleanedData.socialProfiles === undefined) cleanedData.socialProfiles = {};\n+    \n     // Prepare the lead with Firestore-compatible data\n     const firestoreLead = {\n-      ...leadData,\n+      ...cleanedData,\n+      tags,\n       position,\n       numericId: timestampId, // Set a numeric ID\n       createdAt: Timestamp.fromDate(new Date(now)),\n       lastActivity: Timestamp.fromDate(new Date(now)),\n"
                },
                {
                    "date": 1742502911883,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -155,9 +155,9 @@\n         \n         // Log any lead without a valid position for debugging\n         if (leadData.position === undefined || isNaN(leadData.position)) {\n           leadsWithoutPosition++;\n-          console.log(`Lead ${leadData.id} (${leadData.name}) has no valid position`);\n+          console.log(`Lead ${leadData.id} has no valid position`);\n         }\n         \n         leads.push(leadData);\n       } catch (conversionError) {\n"
                },
                {
                    "date": 1743706142490,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -114,8 +114,42 @@\n       value: data.value || '$0',\n       position: data.position || 0, // Include position with default\n       createdAt: safeTimestampToISOString(data.createdAt),\n       lastActivity: safeTimestampToISOString(data.lastActivity),\n+      \n+      // Address fields - preserve exactly as stored\n+      address: data.address,\n+      city: data.city,\n+      state: data.state,\n+      zipCode: data.zipCode, \n+      country: data.country,\n+      \n+      // Lead source information\n+      source: data.source,\n+      referredBy: data.referredBy,\n+      campaign: data.campaign,\n+      \n+      // Tags - ensure it's an array\n+      tags: Array.isArray(data.tags) ? data.tags : (data.tags ? [data.tags] : []),\n+      \n+      // Custom fields\n+      customFields: data.customFields || [],\n+      \n+      // Social profiles\n+      socialProfiles: data.socialProfiles || {},\n+      \n+      // Business details\n+      website: data.website,\n+      industry: data.industry,\n+      companySize: data.companySize,\n+      annualRevenue: data.annualRevenue,\n+      \n+      // Lead preferences\n+      budget: data.budget,\n+      timeline: data.timeline,\n+      preferredContact: data.preferredContact,\n+      keyRequirements: data.keyRequirements,\n+      \n       activities: {\n         calls: Array.isArray(data.activities?.calls) \n           ? data.activities.calls.map(safeActivityDateToISOString) \n           : [],\n"
                }
            ],
            "date": 1741292440169,
            "name": "Commit-0",
            "content": "import { \n  collection, \n  addDoc, \n  getDocs, \n  getDoc, \n  doc, \n  updateDoc, \n  deleteDoc, \n  query, \n  where, \n  orderBy, \n  Timestamp,\n  FirestoreDataConverter,\n  DocumentData,\n  QueryDocumentSnapshot,\n  SnapshotOptions\n} from 'firebase/firestore';\nimport { db } from '@/lib/firebase';\nimport { Lead } from '@/data/leads';\n\n// Collection name\nconst LEADS_COLLECTION = 'leads';\n\n// Define a converter for the Lead type\nconst leadConverter: FirestoreDataConverter<Lead> = {\n  toFirestore(lead: Lead): DocumentData {\n    // Convert Lead to Firestore format\n    // We need to remove the id since it's stored as the document ID\n    const { id, ...leadData } = lead;\n    \n    // Convert date strings to Firestore Timestamps\n    return {\n      ...leadData,\n      createdAt: Timestamp.fromDate(new Date(lead.createdAt)),\n      lastActivity: Timestamp.fromDate(new Date(lead.lastActivity)),\n      // Convert complex activity objects\n      activities: {\n        calls: lead.activities.calls.map(call => ({\n          ...call,\n          date: Timestamp.fromDate(new Date(call.date))\n        })),\n        notes: lead.activities.notes.map(note => ({\n          ...note,\n          date: Timestamp.fromDate(new Date(note.date))\n        })),\n        emails: lead.activities.emails.map(email => ({\n          ...email,\n          date: Timestamp.fromDate(new Date(email.date))\n        })),\n        meetings: lead.activities.meetings.map(meeting => ({\n          ...meeting,\n          date: Timestamp.fromDate(new Date(meeting.date))\n        })),\n        documents: lead.activities.documents.map(document => ({\n          ...document,\n          date: Timestamp.fromDate(new Date(document.date))\n        }))\n      }\n    };\n  },\n  fromFirestore(\n    snapshot: QueryDocumentSnapshot,\n    options?: SnapshotOptions\n  ): Lead {\n    const data = snapshot.data(options);\n    \n    // Convert Firestore data to Lead type\n    return {\n      id: Number(snapshot.id), // Convert string ID to number\n      name: data.name,\n      company: data.company,\n      email: data.email,\n      phone: data.phone,\n      status: data.status,\n      value: data.value,\n      createdAt: data.createdAt.toDate().toISOString(),\n      lastActivity: data.lastActivity.toDate().toISOString(),\n      activities: {\n        calls: data.activities?.calls?.map((call: any) => ({\n          ...call,\n          date: call.date.toDate().toISOString()\n        })) || [],\n        notes: data.activities?.notes?.map((note: any) => ({\n          ...note,\n          date: note.date.toDate().toISOString()\n        })) || [],\n        emails: data.activities?.emails?.map((email: any) => ({\n          ...email,\n          date: email.date.toDate().toISOString()\n        })) || [],\n        meetings: data.activities?.meetings?.map((meeting: any) => ({\n          ...meeting,\n          date: meeting.date.toDate().toISOString()\n        })) || [],\n        documents: data.activities?.documents?.map((document: any) => ({\n          ...document,\n          date: document.date.toDate().toISOString()\n        })) || []\n      }\n    };\n  }\n};\n\n// Get all leads\nexport async function getLeads(): Promise<Lead[]> {\n  try {\n    const leadsRef = collection(db, LEADS_COLLECTION).withConverter(leadConverter);\n    const q = query(leadsRef, orderBy('lastActivity', 'desc'));\n    const querySnapshot = await getDocs(q);\n    \n    const leads: Lead[] = [];\n    querySnapshot.forEach((doc) => {\n      leads.push(doc.data());\n    });\n    \n    return leads;\n  } catch (error) {\n    console.error('Error getting leads:', error);\n    throw error;\n  }\n}\n\n// Get a lead by ID\nexport async function getLeadById(id: string): Promise<Lead | null> {\n  try {\n    const leadRef = doc(db, LEADS_COLLECTION, id).withConverter(leadConverter);\n    const docSnap = await getDoc(leadRef);\n    \n    if (docSnap.exists()) {\n      return docSnap.data();\n    } else {\n      return null;\n    }\n  } catch (error) {\n    console.error('Error getting lead:', error);\n    throw error;\n  }\n}\n\n// Get leads by status\nexport async function getLeadsByStatus(status: string): Promise<Lead[]> {\n  try {\n    const leadsRef = collection(db, LEADS_COLLECTION).withConverter(leadConverter);\n    const q = query(\n      leadsRef, \n      where('status', '==', status),\n      orderBy('lastActivity', 'desc')\n    );\n    const querySnapshot = await getDocs(q);\n    \n    const leads: Lead[] = [];\n    querySnapshot.forEach((doc) => {\n      leads.push(doc.data());\n    });\n    \n    return leads;\n  } catch (error) {\n    console.error('Error getting leads by status:', error);\n    throw error;\n  }\n}\n\n// Create a new lead\nexport async function createLead(leadData: Omit<Lead, 'id'>): Promise<string> {\n  try {\n    const now = new Date().toISOString();\n    \n    // Generate a temporary ID for the lead (will be replaced by Firestore's auto ID)\n    const tempLead: Lead = {\n      ...leadData,\n      id: Date.now(), // Temporary ID\n      createdAt: now,\n      lastActivity: now,\n      activities: leadData.activities || {\n        calls: [],\n        notes: [],\n        emails: [],\n        meetings: [],\n        documents: []\n      }\n    };\n    \n    const leadsRef = collection(db, LEADS_COLLECTION).withConverter(leadConverter);\n    const docRef = await addDoc(leadsRef, tempLead);\n    \n    return docRef.id;\n  } catch (error) {\n    console.error('Error creating lead:', error);\n    throw error;\n  }\n}\n\n// Update a lead\nexport async function updateLead(id: string, leadData: Partial<Lead>): Promise<void> {\n  try {\n    const leadRef = doc(db, LEADS_COLLECTION, id);\n    \n    // Update the last activity timestamp and provided fields\n    const updateData = {\n      ...leadData,\n      lastActivity: Timestamp.now()\n    };\n    \n    await updateDoc(leadRef, updateData);\n  } catch (error) {\n    console.error('Error updating lead:', error);\n    throw error;\n  }\n}\n\n// Delete a lead\nexport async function deleteLead(id: string): Promise<void> {\n  try {\n    const leadRef = doc(db, LEADS_COLLECTION, id);\n    await deleteDoc(leadRef);\n  } catch (error) {\n    console.error('Error deleting lead:', error);\n    throw error;\n  }\n}\n\n// Add an activity to a lead\nexport async function addActivityToLead(\n  leadId: string, \n  activityType: 'calls' | 'notes' | 'emails' | 'meetings' | 'documents',\n  activityData: any\n): Promise<void> {\n  try {\n    const leadRef = doc(db, LEADS_COLLECTION, leadId);\n    const leadDoc = await getDoc(leadRef);\n    \n    if (!leadDoc.exists()) {\n      throw new Error(`Lead with ID ${leadId} not found`);\n    }\n    \n    const leadData = leadDoc.data();\n    const activities = leadData?.activities || {\n      calls: [],\n      notes: [],\n      emails: [],\n      meetings: [],\n      documents: []\n    };\n    \n    // Add the new activity with timestamp\n    const newActivity = {\n      ...activityData,\n      id: Date.now(), // Generate a unique ID\n      date: Timestamp.now()\n    };\n    \n    // Update the specific activity array\n    const updatedActivities = {\n      ...activities,\n      [activityType]: [...(activities[activityType] || []), newActivity]\n    };\n    \n    // Update the lead document\n    await updateDoc(leadRef, {\n      activities: updatedActivities,\n      lastActivity: Timestamp.now()\n    });\n  } catch (error) {\n    console.error('Error adding activity:', error);\n    throw error;\n  }\n}\n\n// Seed initial lead data (for development only)\nexport async function seedLeads(initialLeads: Lead[]): Promise<void> {\n  try {\n    const batch = db.batch();\n    \n    for (const lead of initialLeads) {\n      const newLeadRef = doc(collection(db, LEADS_COLLECTION));\n      const { id, ...leadData } = lead;\n      \n      // Convert date strings to Firestore Timestamps\n      const firestoreData = {\n        ...leadData,\n        createdAt: Timestamp.fromDate(new Date(lead.createdAt)),\n        lastActivity: Timestamp.fromDate(new Date(lead.lastActivity)),\n        // Convert complex activity objects\n        activities: {\n          calls: lead.activities.calls.map(call => ({\n            ...call,\n            date: Timestamp.fromDate(new Date(call.date))\n          })),\n          notes: lead.activities.notes.map(note => ({\n            ...note,\n            date: Timestamp.fromDate(new Date(note.date))\n          })),\n          emails: lead.activities.emails.map(email => ({\n            ...email,\n            date: Timestamp.fromDate(new Date(email.date))\n          })),\n          meetings: lead.activities.meetings.map(meeting => ({\n            ...meeting,\n            date: Timestamp.fromDate(new Date(meeting.date))\n          })),\n          documents: lead.activities.documents.map(document => ({\n            ...document,\n            date: Timestamp.fromDate(new Date(document.date))\n          }))\n        }\n      };\n      \n      batch.set(newLeadRef, firestoreData);\n    }\n    \n    await batch.commit();\n    console.log('Successfully seeded leads data');\n  } catch (error) {\n    console.error('Error seeding leads:', error);\n    throw error;\n  }\n} "
        }
    ]
}