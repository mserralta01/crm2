{
    "sourceFile": "lib/services/leads-service.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 15,
            "patches": [
                {
                    "date": 1741292440169,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1741292452135,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -12,9 +12,10 @@\n   Timestamp,\n   FirestoreDataConverter,\n   DocumentData,\n   QueryDocumentSnapshot,\n-  SnapshotOptions\n+  SnapshotOptions,\n+  writeBatch\n } from 'firebase/firestore';\n import { db } from '@/lib/firebase';\n import { Lead } from '@/data/leads';\n \n@@ -268,9 +269,9 @@\n \n // Seed initial lead data (for development only)\n export async function seedLeads(initialLeads: Lead[]): Promise<void> {\n   try {\n-    const batch = db.batch();\n+    const batch = writeBatch(db);\n     \n     for (const lead of initialLeads) {\n       const newLeadRef = doc(collection(db, LEADS_COLLECTION));\n       const { id, ...leadData } = lead;\n"
                },
                {
                    "date": 1741293640118,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -31,8 +31,9 @@\n     \n     // Convert date strings to Firestore Timestamps\n     return {\n       ...leadData,\n+      position: lead.position || 0, // Ensure position is included\n       createdAt: Timestamp.fromDate(new Date(lead.createdAt)),\n       lastActivity: Timestamp.fromDate(new Date(lead.lastActivity)),\n       // Convert complex activity objects\n       activities: {\n@@ -73,8 +74,9 @@\n       email: data.email,\n       phone: data.phone,\n       status: data.status,\n       value: data.value,\n+      position: data.position || 0, // Include position with default\n       createdAt: data.createdAt.toDate().toISOString(),\n       lastActivity: data.lastActivity.toDate().toISOString(),\n       activities: {\n         calls: data.activities?.calls?.map((call: any) => ({\n@@ -165,12 +167,22 @@\n export async function createLead(leadData: Omit<Lead, 'id'>): Promise<string> {\n   try {\n     const now = new Date().toISOString();\n     \n+    // If no position is specified, find the max position for leads with the same status\n+    let position = leadData.position || 0;\n+    if (!position) {\n+      const leadsWithSameStatus = await getLeadsByStatus(leadData.status || 'New');\n+      position = leadsWithSameStatus.length > 0\n+        ? Math.max(...leadsWithSameStatus.map(lead => lead.position || 0)) + 1\n+        : 1;\n+    }\n+    \n     // Generate a temporary ID for the lead (will be replaced by Firestore's auto ID)\n     const tempLead: Lead = {\n       ...leadData,\n       id: Date.now(), // Temporary ID\n+      position, // Set the calculated position\n       createdAt: now,\n       lastActivity: now,\n       activities: leadData.activities || {\n         calls: [],\n"
                },
                {
                    "date": 1741293648522,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -326,5 +326,27 @@\n   } catch (error) {\n     console.error('Error seeding leads:', error);\n     throw error;\n   }\n+}\n+\n+// Add a batch update function for updating multiple lead positions\n+export async function updateLeadPositions(updates: { id: string; position: number }[]): Promise<void> {\n+  try {\n+    const batch = writeBatch(db);\n+    \n+    // Prepare batch updates\n+    for (const update of updates) {\n+      const leadRef = doc(db, LEADS_COLLECTION, update.id);\n+      batch.update(leadRef, { \n+        position: update.position,\n+        lastActivity: Timestamp.now()\n+      });\n+    }\n+    \n+    // Commit the batch\n+    await batch.commit();\n+  } catch (error) {\n+    console.error('Error updating lead positions:', error);\n+    throw error;\n+  }\n } \n\\ No newline at end of file\n"
                },
                {
                    "date": 1741294640024,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -335,8 +335,14 @@\n     const batch = writeBatch(db);\n     \n     // Prepare batch updates\n     for (const update of updates) {\n+      // Ensure id is a valid string and not NaN\n+      if (!update.id || update.id === 'NaN' || update.id === 'undefined') {\n+        console.warn(`Skipping update for invalid lead ID: ${update.id}`);\n+        continue;\n+      }\n+      \n       const leadRef = doc(db, LEADS_COLLECTION, update.id);\n       batch.update(leadRef, { \n         position: update.position,\n         lastActivity: Timestamp.now()\n"
                },
                {
                    "date": 1741294707245,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -67,9 +67,9 @@\n     const data = snapshot.data(options);\n     \n     // Convert Firestore data to Lead type\n     return {\n-      id: Number(snapshot.id), // Convert string ID to number\n+      id: isNaN(Number(snapshot.id)) ? -1 : Number(snapshot.id), // Convert string ID to number, use -1 for invalid IDs\n       name: data.name,\n       company: data.company,\n       email: data.email,\n       phone: data.phone,\n"
                },
                {
                    "date": 1741294805787,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -335,10 +335,10 @@\n     const batch = writeBatch(db);\n     \n     // Prepare batch updates\n     for (const update of updates) {\n-      // Ensure id is a valid string and not NaN\n-      if (!update.id || update.id === 'NaN' || update.id === 'undefined') {\n+      // Ensure id is a valid string and not NaN or -1\n+      if (!update.id || update.id === 'NaN' || update.id === 'undefined' || update.id === '-1') {\n         console.warn(`Skipping update for invalid lead ID: ${update.id}`);\n         continue;\n       }\n       \n@@ -348,10 +348,14 @@\n         lastActivity: Timestamp.now()\n       });\n     }\n     \n-    // Commit the batch\n-    await batch.commit();\n+    // Only commit if we have valid updates\n+    if (batch._mutations && batch._mutations.length > 0) {\n+      await batch.commit();\n+    } else {\n+      console.log('No valid lead position updates to commit');\n+    }\n   } catch (error) {\n     console.error('Error updating lead positions:', error);\n     throw error;\n   }\n"
                },
                {
                    "date": 1741294816643,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -332,8 +332,9 @@\n // Add a batch update function for updating multiple lead positions\n export async function updateLeadPositions(updates: { id: string; position: number }[]): Promise<void> {\n   try {\n     const batch = writeBatch(db);\n+    let hasUpdates = false;\n     \n     // Prepare batch updates\n     for (const update of updates) {\n       // Ensure id is a valid string and not NaN or -1\n@@ -346,12 +347,13 @@\n       batch.update(leadRef, { \n         position: update.position,\n         lastActivity: Timestamp.now()\n       });\n+      hasUpdates = true;\n     }\n     \n     // Only commit if we have valid updates\n-    if (batch._mutations && batch._mutations.length > 0) {\n+    if (hasUpdates) {\n       await batch.commit();\n     } else {\n       console.log('No valid lead position updates to commit');\n     }\n"
                },
                {
                    "date": 1741294836791,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -65,11 +65,17 @@\n     options?: SnapshotOptions\n   ): Lead {\n     const data = snapshot.data(options);\n     \n+    // Generate a unique negative number for invalid IDs\n+    // This avoids the warning about duplicate keys when multiple items have invalid IDs\n+    const generateUniqueInvalidId = () => {\n+      return -Math.floor(Math.random() * 1000000 + 1);\n+    };\n+    \n     // Convert Firestore data to Lead type\n     return {\n-      id: isNaN(Number(snapshot.id)) ? -1 : Number(snapshot.id), // Convert string ID to number, use -1 for invalid IDs\n+      id: isNaN(Number(snapshot.id)) ? generateUniqueInvalidId() : Number(snapshot.id), // Convert string ID to number, use unique negative number for invalid IDs\n       name: data.name,\n       company: data.company,\n       email: data.email,\n       phone: data.phone,\n"
                },
                {
                    "date": 1741294891610,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -182,12 +182,13 @@\n         ? Math.max(...leadsWithSameStatus.map(lead => lead.position || 0)) + 1\n         : 1;\n     }\n     \n-    // Generate a temporary ID for the lead (will be replaced by Firestore's auto ID)\n+    // Use timestamp for temporary ID (will be replaced by Firestore document ID)\n+    const timestamp = Date.now();\n     const tempLead: Lead = {\n       ...leadData,\n-      id: Date.now(), // Temporary ID\n+      id: timestamp, // Use timestamp as temporary ID\n       position, // Set the calculated position\n       createdAt: now,\n       lastActivity: now,\n       activities: leadData.activities || {\n@@ -198,12 +199,28 @@\n         documents: []\n       }\n     };\n     \n-    const leadsRef = collection(db, LEADS_COLLECTION).withConverter(leadConverter);\n-    const docRef = await addDoc(leadsRef, tempLead);\n+    // Create a reference without the converter first\n+    const leadsCollection = collection(db, LEADS_COLLECTION);\n     \n-    return docRef.id;\n+    // Add the document and get the auto-generated ID\n+    const docRef = await addDoc(leadsCollection, leadConverter.toFirestore(tempLead));\n+    \n+    // Now update the document to set its numeric ID field to match the document ID\n+    // First convert the document ID to a numeric ID\n+    const numericId = parseInt(docRef.id, 10);\n+    \n+    // Only update if the conversion was successful\n+    if (!isNaN(numericId)) {\n+      await updateDoc(docRef, { numericId: numericId });\n+      return docRef.id;\n+    } else {\n+      console.error('Failed to create a valid numeric ID from document ID:', docRef.id);\n+      // Clean up the invalid document\n+      await deleteDoc(docRef);\n+      throw new Error('Failed to create a valid numeric ID for lead');\n+    }\n   } catch (error) {\n     console.error('Error creating lead:', error);\n     throw error;\n   }\n"
                },
                {
                    "date": 1741294918957,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -71,11 +71,21 @@\n     const generateUniqueInvalidId = () => {\n       return -Math.floor(Math.random() * 1000000 + 1);\n     };\n     \n+    // Determine the ID - use numericId if available, otherwise try to parse the document ID\n+    let id: number;\n+    if (data.numericId !== undefined && !isNaN(Number(data.numericId))) {\n+      // Use the numericId field if it exists and is valid\n+      id = Number(data.numericId);\n+    } else {\n+      // Fall back to parsing the document ID\n+      id = isNaN(Number(snapshot.id)) ? generateUniqueInvalidId() : Number(snapshot.id);\n+    }\n+    \n     // Convert Firestore data to Lead type\n     return {\n-      id: isNaN(Number(snapshot.id)) ? generateUniqueInvalidId() : Number(snapshot.id), // Convert string ID to number, use unique negative number for invalid IDs\n+      id: id, // Use the determined ID\n       name: data.name,\n       company: data.company,\n       email: data.email,\n       phone: data.phone,\n"
                },
                {
                    "date": 1741294928491,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -28,11 +28,12 @@\n     // Convert Lead to Firestore format\n     // We need to remove the id since it's stored as the document ID\n     const { id, ...leadData } = lead;\n     \n-    // Convert date strings to Firestore Timestamps\n-    return {\n+    // Add the ID as a numericId field to ensure we can retrieve it later\n+    const firestoreData = {\n       ...leadData,\n+      numericId: id, // Store the numeric ID as a field\n       position: lead.position || 0, // Ensure position is included\n       createdAt: Timestamp.fromDate(new Date(lead.createdAt)),\n       lastActivity: Timestamp.fromDate(new Date(lead.lastActivity)),\n       // Convert complex activity objects\n@@ -58,8 +59,10 @@\n           date: Timestamp.fromDate(new Date(document.date))\n         }))\n       }\n     };\n+    \n+    return firestoreData;\n   },\n   fromFirestore(\n     snapshot: QueryDocumentSnapshot,\n     options?: SnapshotOptions\n"
                },
                {
                    "date": 1741294961612,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -241,8 +241,14 @@\n \n // Update a lead\n export async function updateLead(id: string, leadData: Partial<Lead>): Promise<void> {\n   try {\n+    // Validate the ID before proceeding\n+    if (!id || id === 'NaN' || id === 'undefined' || id === '-1') {\n+      console.error(`Cannot update lead with invalid ID: ${id}`);\n+      throw new Error(`Invalid lead ID: ${id}`);\n+    }\n+    \n     const leadRef = doc(db, LEADS_COLLECTION, id);\n     \n     // Update the last activity timestamp and provided fields\n     const updateData = {\n"
                },
                {
                    "date": 1741294991083,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -402,5 +402,46 @@\n   } catch (error) {\n     console.error('Error updating lead positions:', error);\n     throw error;\n   }\n+}\n+\n+// Migrate existing leads to have numericId field\n+export async function migrateLeadsToNumericId(): Promise<void> {\n+  try {\n+    console.log('Starting lead migration to add numericId field...');\n+    const leadsRef = collection(db, LEADS_COLLECTION);\n+    const querySnapshot = await getDocs(leadsRef);\n+    \n+    const batch = writeBatch(db);\n+    let updateCount = 0;\n+    \n+    querySnapshot.forEach((document) => {\n+      const data = document.data();\n+      \n+      // Only add numericId if it doesn't exist already\n+      if (data.numericId === undefined) {\n+        const parsedId = parseInt(document.id, 10);\n+        \n+        if (!isNaN(parsedId)) {\n+          batch.update(document.ref, { numericId: parsedId });\n+          updateCount++;\n+        } else {\n+          // For documents with unparseable IDs, we'll generate a unique timestamp-based ID\n+          const timestampId = Date.now() + Math.floor(Math.random() * 1000);\n+          batch.update(document.ref, { numericId: timestampId });\n+          updateCount++;\n+        }\n+      }\n+    });\n+    \n+    if (updateCount > 0) {\n+      await batch.commit();\n+      console.log(`Migration complete. Updated ${updateCount} leads with numericId.`);\n+    } else {\n+      console.log('No leads needed migration.');\n+    }\n+  } catch (error) {\n+    console.error('Error migrating leads:', error);\n+    throw error;\n+  }\n } \n\\ No newline at end of file\n"
                },
                {
                    "date": 1741295174610,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -195,45 +195,48 @@\n         ? Math.max(...leadsWithSameStatus.map(lead => lead.position || 0)) + 1\n         : 1;\n     }\n     \n-    // Use timestamp for temporary ID (will be replaced by Firestore document ID)\n-    const timestamp = Date.now();\n-    const tempLead: Lead = {\n+    // Generate a timestamp ID for the lead\n+    const timestampId = Date.now();\n+    \n+    // Prepare the lead with Firestore-compatible data\n+    const firestoreLead = {\n       ...leadData,\n-      id: timestamp, // Use timestamp as temporary ID\n-      position, // Set the calculated position\n-      createdAt: now,\n-      lastActivity: now,\n-      activities: leadData.activities || {\n-        calls: [],\n-        notes: [],\n-        emails: [],\n-        meetings: [],\n-        documents: []\n+      position,\n+      numericId: timestampId, // Set a numeric ID\n+      createdAt: Timestamp.fromDate(new Date(now)),\n+      lastActivity: Timestamp.fromDate(new Date(now)),\n+      activities: {\n+        calls: (leadData.activities?.calls || []).map(a => ({\n+          ...a,\n+          date: Timestamp.fromDate(new Date(a.date))\n+        })),\n+        notes: (leadData.activities?.notes || []).map(a => ({\n+          ...a,\n+          date: Timestamp.fromDate(new Date(a.date))\n+        })),\n+        emails: (leadData.activities?.emails || []).map(a => ({\n+          ...a,\n+          date: Timestamp.fromDate(new Date(a.date))\n+        })),\n+        meetings: (leadData.activities?.meetings || []).map(a => ({\n+          ...a,\n+          date: Timestamp.fromDate(new Date(a.date))\n+        })),\n+        documents: (leadData.activities?.documents || []).map(a => ({\n+          ...a,\n+          date: Timestamp.fromDate(new Date(a.date))\n+        }))\n       }\n     };\n     \n-    // Create a reference without the converter first\n+    // Add the document to Firestore\n     const leadsCollection = collection(db, LEADS_COLLECTION);\n+    const docRef = await addDoc(leadsCollection, firestoreLead);\n     \n-    // Add the document and get the auto-generated ID\n-    const docRef = await addDoc(leadsCollection, leadConverter.toFirestore(tempLead));\n-    \n-    // Now update the document to set its numeric ID field to match the document ID\n-    // First convert the document ID to a numeric ID\n-    const numericId = parseInt(docRef.id, 10);\n-    \n-    // Only update if the conversion was successful\n-    if (!isNaN(numericId)) {\n-      await updateDoc(docRef, { numericId: numericId });\n-      return docRef.id;\n-    } else {\n-      console.error('Failed to create a valid numeric ID from document ID:', docRef.id);\n-      // Clean up the invalid document\n-      await deleteDoc(docRef);\n-      throw new Error('Failed to create a valid numeric ID for lead');\n-    }\n+    console.log(`Created new lead with ID: ${docRef.id}, numericId: ${timestampId}`);\n+    return docRef.id;\n   } catch (error) {\n     console.error('Error creating lead:', error);\n     throw error;\n   }\n"
                },
                {
                    "date": 1741295186477,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -208,25 +208,25 @@\n       lastActivity: Timestamp.fromDate(new Date(now)),\n       activities: {\n         calls: (leadData.activities?.calls || []).map(a => ({\n           ...a,\n-          date: Timestamp.fromDate(new Date(a.date))\n+          date: a.date ? Timestamp.fromDate(new Date(a.date)) : Timestamp.fromDate(new Date(now))\n         })),\n         notes: (leadData.activities?.notes || []).map(a => ({\n           ...a,\n-          date: Timestamp.fromDate(new Date(a.date))\n+          date: a.date ? Timestamp.fromDate(new Date(a.date)) : Timestamp.fromDate(new Date(now))\n         })),\n         emails: (leadData.activities?.emails || []).map(a => ({\n           ...a,\n-          date: Timestamp.fromDate(new Date(a.date))\n+          date: a.date ? Timestamp.fromDate(new Date(a.date)) : Timestamp.fromDate(new Date(now))\n         })),\n         meetings: (leadData.activities?.meetings || []).map(a => ({\n           ...a,\n-          date: Timestamp.fromDate(new Date(a.date))\n+          date: a.date ? Timestamp.fromDate(new Date(a.date)) : Timestamp.fromDate(new Date(now))\n         })),\n         documents: (leadData.activities?.documents || []).map(a => ({\n           ...a,\n-          date: Timestamp.fromDate(new Date(a.date))\n+          date: a.date ? Timestamp.fromDate(new Date(a.date)) : Timestamp.fromDate(new Date(now))\n         }))\n       }\n     };\n     \n"
                }
            ],
            "date": 1741292440169,
            "name": "Commit-0",
            "content": "import { \n  collection, \n  addDoc, \n  getDocs, \n  getDoc, \n  doc, \n  updateDoc, \n  deleteDoc, \n  query, \n  where, \n  orderBy, \n  Timestamp,\n  FirestoreDataConverter,\n  DocumentData,\n  QueryDocumentSnapshot,\n  SnapshotOptions\n} from 'firebase/firestore';\nimport { db } from '@/lib/firebase';\nimport { Lead } from '@/data/leads';\n\n// Collection name\nconst LEADS_COLLECTION = 'leads';\n\n// Define a converter for the Lead type\nconst leadConverter: FirestoreDataConverter<Lead> = {\n  toFirestore(lead: Lead): DocumentData {\n    // Convert Lead to Firestore format\n    // We need to remove the id since it's stored as the document ID\n    const { id, ...leadData } = lead;\n    \n    // Convert date strings to Firestore Timestamps\n    return {\n      ...leadData,\n      createdAt: Timestamp.fromDate(new Date(lead.createdAt)),\n      lastActivity: Timestamp.fromDate(new Date(lead.lastActivity)),\n      // Convert complex activity objects\n      activities: {\n        calls: lead.activities.calls.map(call => ({\n          ...call,\n          date: Timestamp.fromDate(new Date(call.date))\n        })),\n        notes: lead.activities.notes.map(note => ({\n          ...note,\n          date: Timestamp.fromDate(new Date(note.date))\n        })),\n        emails: lead.activities.emails.map(email => ({\n          ...email,\n          date: Timestamp.fromDate(new Date(email.date))\n        })),\n        meetings: lead.activities.meetings.map(meeting => ({\n          ...meeting,\n          date: Timestamp.fromDate(new Date(meeting.date))\n        })),\n        documents: lead.activities.documents.map(document => ({\n          ...document,\n          date: Timestamp.fromDate(new Date(document.date))\n        }))\n      }\n    };\n  },\n  fromFirestore(\n    snapshot: QueryDocumentSnapshot,\n    options?: SnapshotOptions\n  ): Lead {\n    const data = snapshot.data(options);\n    \n    // Convert Firestore data to Lead type\n    return {\n      id: Number(snapshot.id), // Convert string ID to number\n      name: data.name,\n      company: data.company,\n      email: data.email,\n      phone: data.phone,\n      status: data.status,\n      value: data.value,\n      createdAt: data.createdAt.toDate().toISOString(),\n      lastActivity: data.lastActivity.toDate().toISOString(),\n      activities: {\n        calls: data.activities?.calls?.map((call: any) => ({\n          ...call,\n          date: call.date.toDate().toISOString()\n        })) || [],\n        notes: data.activities?.notes?.map((note: any) => ({\n          ...note,\n          date: note.date.toDate().toISOString()\n        })) || [],\n        emails: data.activities?.emails?.map((email: any) => ({\n          ...email,\n          date: email.date.toDate().toISOString()\n        })) || [],\n        meetings: data.activities?.meetings?.map((meeting: any) => ({\n          ...meeting,\n          date: meeting.date.toDate().toISOString()\n        })) || [],\n        documents: data.activities?.documents?.map((document: any) => ({\n          ...document,\n          date: document.date.toDate().toISOString()\n        })) || []\n      }\n    };\n  }\n};\n\n// Get all leads\nexport async function getLeads(): Promise<Lead[]> {\n  try {\n    const leadsRef = collection(db, LEADS_COLLECTION).withConverter(leadConverter);\n    const q = query(leadsRef, orderBy('lastActivity', 'desc'));\n    const querySnapshot = await getDocs(q);\n    \n    const leads: Lead[] = [];\n    querySnapshot.forEach((doc) => {\n      leads.push(doc.data());\n    });\n    \n    return leads;\n  } catch (error) {\n    console.error('Error getting leads:', error);\n    throw error;\n  }\n}\n\n// Get a lead by ID\nexport async function getLeadById(id: string): Promise<Lead | null> {\n  try {\n    const leadRef = doc(db, LEADS_COLLECTION, id).withConverter(leadConverter);\n    const docSnap = await getDoc(leadRef);\n    \n    if (docSnap.exists()) {\n      return docSnap.data();\n    } else {\n      return null;\n    }\n  } catch (error) {\n    console.error('Error getting lead:', error);\n    throw error;\n  }\n}\n\n// Get leads by status\nexport async function getLeadsByStatus(status: string): Promise<Lead[]> {\n  try {\n    const leadsRef = collection(db, LEADS_COLLECTION).withConverter(leadConverter);\n    const q = query(\n      leadsRef, \n      where('status', '==', status),\n      orderBy('lastActivity', 'desc')\n    );\n    const querySnapshot = await getDocs(q);\n    \n    const leads: Lead[] = [];\n    querySnapshot.forEach((doc) => {\n      leads.push(doc.data());\n    });\n    \n    return leads;\n  } catch (error) {\n    console.error('Error getting leads by status:', error);\n    throw error;\n  }\n}\n\n// Create a new lead\nexport async function createLead(leadData: Omit<Lead, 'id'>): Promise<string> {\n  try {\n    const now = new Date().toISOString();\n    \n    // Generate a temporary ID for the lead (will be replaced by Firestore's auto ID)\n    const tempLead: Lead = {\n      ...leadData,\n      id: Date.now(), // Temporary ID\n      createdAt: now,\n      lastActivity: now,\n      activities: leadData.activities || {\n        calls: [],\n        notes: [],\n        emails: [],\n        meetings: [],\n        documents: []\n      }\n    };\n    \n    const leadsRef = collection(db, LEADS_COLLECTION).withConverter(leadConverter);\n    const docRef = await addDoc(leadsRef, tempLead);\n    \n    return docRef.id;\n  } catch (error) {\n    console.error('Error creating lead:', error);\n    throw error;\n  }\n}\n\n// Update a lead\nexport async function updateLead(id: string, leadData: Partial<Lead>): Promise<void> {\n  try {\n    const leadRef = doc(db, LEADS_COLLECTION, id);\n    \n    // Update the last activity timestamp and provided fields\n    const updateData = {\n      ...leadData,\n      lastActivity: Timestamp.now()\n    };\n    \n    await updateDoc(leadRef, updateData);\n  } catch (error) {\n    console.error('Error updating lead:', error);\n    throw error;\n  }\n}\n\n// Delete a lead\nexport async function deleteLead(id: string): Promise<void> {\n  try {\n    const leadRef = doc(db, LEADS_COLLECTION, id);\n    await deleteDoc(leadRef);\n  } catch (error) {\n    console.error('Error deleting lead:', error);\n    throw error;\n  }\n}\n\n// Add an activity to a lead\nexport async function addActivityToLead(\n  leadId: string, \n  activityType: 'calls' | 'notes' | 'emails' | 'meetings' | 'documents',\n  activityData: any\n): Promise<void> {\n  try {\n    const leadRef = doc(db, LEADS_COLLECTION, leadId);\n    const leadDoc = await getDoc(leadRef);\n    \n    if (!leadDoc.exists()) {\n      throw new Error(`Lead with ID ${leadId} not found`);\n    }\n    \n    const leadData = leadDoc.data();\n    const activities = leadData?.activities || {\n      calls: [],\n      notes: [],\n      emails: [],\n      meetings: [],\n      documents: []\n    };\n    \n    // Add the new activity with timestamp\n    const newActivity = {\n      ...activityData,\n      id: Date.now(), // Generate a unique ID\n      date: Timestamp.now()\n    };\n    \n    // Update the specific activity array\n    const updatedActivities = {\n      ...activities,\n      [activityType]: [...(activities[activityType] || []), newActivity]\n    };\n    \n    // Update the lead document\n    await updateDoc(leadRef, {\n      activities: updatedActivities,\n      lastActivity: Timestamp.now()\n    });\n  } catch (error) {\n    console.error('Error adding activity:', error);\n    throw error;\n  }\n}\n\n// Seed initial lead data (for development only)\nexport async function seedLeads(initialLeads: Lead[]): Promise<void> {\n  try {\n    const batch = db.batch();\n    \n    for (const lead of initialLeads) {\n      const newLeadRef = doc(collection(db, LEADS_COLLECTION));\n      const { id, ...leadData } = lead;\n      \n      // Convert date strings to Firestore Timestamps\n      const firestoreData = {\n        ...leadData,\n        createdAt: Timestamp.fromDate(new Date(lead.createdAt)),\n        lastActivity: Timestamp.fromDate(new Date(lead.lastActivity)),\n        // Convert complex activity objects\n        activities: {\n          calls: lead.activities.calls.map(call => ({\n            ...call,\n            date: Timestamp.fromDate(new Date(call.date))\n          })),\n          notes: lead.activities.notes.map(note => ({\n            ...note,\n            date: Timestamp.fromDate(new Date(note.date))\n          })),\n          emails: lead.activities.emails.map(email => ({\n            ...email,\n            date: Timestamp.fromDate(new Date(email.date))\n          })),\n          meetings: lead.activities.meetings.map(meeting => ({\n            ...meeting,\n            date: Timestamp.fromDate(new Date(meeting.date))\n          })),\n          documents: lead.activities.documents.map(document => ({\n            ...document,\n            date: Timestamp.fromDate(new Date(document.date))\n          }))\n        }\n      };\n      \n      batch.set(newLeadRef, firestoreData);\n    }\n    \n    await batch.commit();\n    console.log('Successfully seeded leads data');\n  } catch (error) {\n    console.error('Error seeding leads:', error);\n    throw error;\n  }\n} "
        }
    ]
}