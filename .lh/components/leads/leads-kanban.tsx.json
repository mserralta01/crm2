{
    "sourceFile": "components/leads/leads-kanban.tsx",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 45,
            "patches": [
                {
                    "date": 1741292639254,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1741293619090,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -120,21 +120,78 @@\n     } else {\n       const activeItem = items.find(item => item.id.toString() === active.id);\n       const overColumn = over.data.current?.type === 'column' ? over.id : over.data.current?.columnId;\n \n-      if (activeItem && overColumn && activeItem.status !== overColumn) {\n+      if (activeItem && overColumn) {\n         try {\n-          // Update in Firestore\n-          await updateLead(activeItem.id.toString(), { status: overColumn as string });\n-          \n-          // Update local state\n-          setItems(items.map(item => \n-            item.id.toString() === active.id\n-              ? { ...item, status: overColumn as string }\n-              : item\n-          ));\n+          // Moving between columns\n+          if (activeItem.status !== overColumn) {\n+            // Get items in the target column to calculate new position\n+            const itemsInTargetColumn = items\n+              .filter(item => item.status === overColumn)\n+              .sort((a, b) => a.position - b.position);\n+            \n+            // Calculate new position (add at the end of the target column)\n+            const newPosition = itemsInTargetColumn.length > 0\n+              ? Math.max(...itemsInTargetColumn.map(item => item.position)) + 1\n+              : 1;\n+            \n+            // Update in Firestore\n+            await updateLead(activeItem.id.toString(), { \n+              status: overColumn as string,\n+              position: newPosition\n+            });\n+            \n+            // Update local state\n+            setItems(items.map(item => \n+              item.id.toString() === active.id\n+                ? { ...item, status: overColumn as string, position: newPosition }\n+                : item\n+            ));\n+          } \n+          // Reordering within the same column\n+          else if (over.data.current?.type === 'item') {\n+            const activeIndex = items\n+              .filter(item => item.status === activeItem.status)\n+              .sort((a, b) => a.position - b.position)\n+              .findIndex(item => item.id.toString() === active.id);\n+            \n+            const overIndex = items\n+              .filter(item => item.status === activeItem.status)\n+              .sort((a, b) => a.position - b.position)\n+              .findIndex(item => item.id.toString() === over.id);\n+            \n+            if (activeIndex !== overIndex) {\n+              // Get all items in the column, sorted by position\n+              const itemsInColumn = items\n+                .filter(item => item.status === activeItem.status)\n+                .sort((a, b) => a.position - b.position);\n+              \n+              // Reorder items\n+              const reorderedItems = arrayMove(itemsInColumn, activeIndex, overIndex);\n+              \n+              // Update positions for all items in the column to match their new order\n+              const updates = reorderedItems.map((item, index) => ({\n+                id: item.id.toString(),\n+                newPosition: index + 1\n+              }));\n+              \n+              // Update positions in database (one by one)\n+              for (const update of updates) {\n+                await updateLead(update.id, { position: update.newPosition });\n+              }\n+              \n+              // Update local state for all affected items\n+              setItems(items.map(item => {\n+                const update = updates.find(u => u.id === item.id.toString());\n+                return update \n+                  ? { ...item, position: update.newPosition }\n+                  : item;\n+              }));\n+            }\n+          }\n         } catch (err) {\n-          console.error('Error updating lead status:', err);\n+          console.error('Error updating lead position:', err);\n           // You might want to show a toast notification here\n         }\n       }\n     }\n@@ -259,8 +316,9 @@\n                         item.status === column.id &&\n                         (item.name.toLowerCase().includes(searchTerm.toLowerCase()) ||\n                          item.company.toLowerCase().includes(searchTerm.toLowerCase()))\n                       )\n+                      .sort((a, b) => a.position - b.position)\n                       .map((item) => (\n                         <KanbanCard\n                           key={item.id}\n                           id={item.id.toString()}\n"
                },
                {
                    "date": 1741293663832,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -33,10 +33,14 @@\n   DollarSign,\n   BarChart\n } from 'lucide-react';\n import { Lead } from '@/data/leads';\n-import { getLeads, updateLead } from '@/lib/services/leads-service';\n+import { getLeads, updateLead, updateLeadPositions } from '@/lib/services/leads-service';\n import { formatCurrency } from '@/lib/utils';\n+import { \n+  collection, \n+} from 'firebase/firestore';\n+import { db } from '@/lib/firebase';\n \n // Professional color scheme using muted, corporate tones\n const initialColumns = [\n   { id: 'New', title: 'New Leads', color: 'from-slate-600 to-slate-500' },\n@@ -171,23 +175,25 @@\n               \n               // Update positions for all items in the column to match their new order\n               const updates = reorderedItems.map((item, index) => ({\n                 id: item.id.toString(),\n-                newPosition: index + 1\n+                position: index + 1\n               }));\n               \n-              // Update positions in database (one by one)\n-              for (const update of updates) {\n-                await updateLead(update.id, { position: update.newPosition });\n+              // Use batch update for better performance\n+              try {\n+                await updateLeadPositions(updates);\n+                \n+                // Update local state for all affected items\n+                setItems(items.map(item => {\n+                  const update = updates.find(u => u.id === item.id.toString());\n+                  return update \n+                    ? { ...item, position: update.position }\n+                    : item;\n+                }));\n+              } catch (err) {\n+                console.error('Error batch updating lead positions:', err);\n               }\n-              \n-              // Update local state for all affected items\n-              setItems(items.map(item => {\n-                const update = updates.find(u => u.id === item.id.toString());\n-                return update \n-                  ? { ...item, position: update.newPosition }\n-                  : item;\n-              }));\n             }\n           }\n         } catch (err) {\n           console.error('Error updating lead position:', err);\n"
                },
                {
                    "date": 1741293681592,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -70,9 +70,63 @@\n     async function fetchLeads() {\n       try {\n         setLoading(true);\n         const data = await getLeads();\n-        setItems(data);\n+        \n+        // Check if positions need to be initialized\n+        const needsPositionInit = data.some(lead => !lead.position);\n+        \n+        if (needsPositionInit) {\n+          console.log('Initializing positions for leads...');\n+          \n+          // Group leads by status\n+          const leadsByStatus = data.reduce((acc, lead) => {\n+            if (!acc[lead.status]) {\n+              acc[lead.status] = [];\n+            }\n+            acc[lead.status].push(lead);\n+            return acc;\n+          }, {} as Record<string, Lead[]>);\n+          \n+          // Generate position updates for each status group\n+          const positionUpdates: { id: string; position: number }[] = [];\n+          \n+          for (const status in leadsByStatus) {\n+            const statusLeads = leadsByStatus[status];\n+            // Sort by lastActivity date as a reasonable default order\n+            statusLeads.sort((a, b) => \n+              new Date(b.lastActivity).getTime() - new Date(a.lastActivity).getTime()\n+            );\n+            \n+            // Assign positions\n+            statusLeads.forEach((lead, index) => {\n+              if (!lead.position) {\n+                positionUpdates.push({\n+                  id: lead.id.toString(),\n+                  position: index + 1\n+                });\n+              }\n+            });\n+          }\n+          \n+          // Update positions in database\n+          if (positionUpdates.length > 0) {\n+            await updateLeadPositions(positionUpdates);\n+            \n+            // Update local state\n+            const updatedData = data.map(lead => {\n+              const update = positionUpdates.find(u => u.id === lead.id.toString());\n+              return update ? { ...lead, position: update.position } : lead;\n+            });\n+            \n+            setItems(updatedData);\n+          } else {\n+            setItems(data);\n+          }\n+        } else {\n+          setItems(data);\n+        }\n+        \n         setError(null);\n       } catch (err) {\n         console.error('Error fetching leads:', err);\n         setError('Failed to load leads. Please try again later.');\n"
                },
                {
                    "date": 1741293913544,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -39,8 +39,9 @@\n import { \n   collection, \n } from 'firebase/firestore';\n import { db } from '@/lib/firebase';\n+import { AddLeadDialog } from '@/components/leads/add-lead-dialog';\n \n // Professional color scheme using muted, corporate tones\n const initialColumns = [\n   { id: 'New', title: 'New Leads', color: 'from-slate-600 to-slate-500' },\n@@ -65,8 +66,14 @@\n   const [activeColumnId, setActiveColumnId] = useState<string | null>(null);\n   const [loading, setLoading] = useState(true);\n   const [error, setError] = useState<string | null>(null);\n \n+  // Function to handle when a new lead is added\n+  const handleLeadAdded = () => {\n+    // Refetch leads\n+    fetchLeads();\n+  };\n+\n   useEffect(() => {\n     async function fetchLeads() {\n       try {\n         setLoading(true);\n@@ -319,12 +326,14 @@\n       </div>\n \n       <div className=\"mb-4 flex justify-between items-center\">\n         <div className=\"flex items-center space-x-2\">\n-          <Button onClick={() => {}} className=\"bg-blue-600 hover:bg-blue-700\">\n-            <Plus className=\"w-4 h-4 mr-2\" />\n-            Add Lead\n-          </Button>\n+          <AddLeadDialog onLeadAdded={handleLeadAdded}>\n+            <Button className=\"bg-blue-600 hover:bg-blue-700\">\n+              <Plus className=\"w-4 h-4 mr-2\" />\n+              Add Lead\n+            </Button>\n+          </AddLeadDialog>\n           <Button variant=\"outline\" className=\"border-slate-200\">\n             <SlidersHorizontal className=\"w-4 h-4 mr-2\" />\n             Filters\n           </Button>\n"
                },
                {
                    "date": 1741293925486,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -66,84 +66,85 @@\n   const [activeColumnId, setActiveColumnId] = useState<string | null>(null);\n   const [loading, setLoading] = useState(true);\n   const [error, setError] = useState<string | null>(null);\n \n-  // Function to handle when a new lead is added\n-  const handleLeadAdded = () => {\n-    // Refetch leads\n-    fetchLeads();\n-  };\n-\n-  useEffect(() => {\n-    async function fetchLeads() {\n-      try {\n-        setLoading(true);\n-        const data = await getLeads();\n+  // Function to fetch leads data\n+  async function fetchLeads() {\n+    try {\n+      setLoading(true);\n+      const data = await getLeads();\n+      \n+      // Check if positions need to be initialized\n+      const needsPositionInit = data.some(lead => !lead.position);\n+      \n+      if (needsPositionInit) {\n+        console.log('Initializing positions for leads...');\n         \n-        // Check if positions need to be initialized\n-        const needsPositionInit = data.some(lead => !lead.position);\n+        // Group leads by status\n+        const leadsByStatus = data.reduce((acc, lead) => {\n+          if (!acc[lead.status]) {\n+            acc[lead.status] = [];\n+          }\n+          acc[lead.status].push(lead);\n+          return acc;\n+        }, {} as Record<string, Lead[]>);\n         \n-        if (needsPositionInit) {\n-          console.log('Initializing positions for leads...');\n+        // Generate position updates for each status group\n+        const positionUpdates: { id: string; position: number }[] = [];\n+        \n+        for (const status in leadsByStatus) {\n+          const statusLeads = leadsByStatus[status];\n+          // Sort by lastActivity date as a reasonable default order\n+          statusLeads.sort((a, b) => \n+            new Date(b.lastActivity).getTime() - new Date(a.lastActivity).getTime()\n+          );\n           \n-          // Group leads by status\n-          const leadsByStatus = data.reduce((acc, lead) => {\n-            if (!acc[lead.status]) {\n-              acc[lead.status] = [];\n+          // Assign positions\n+          statusLeads.forEach((lead, index) => {\n+            if (!lead.position) {\n+              positionUpdates.push({\n+                id: lead.id.toString(),\n+                position: index + 1\n+              });\n             }\n-            acc[lead.status].push(lead);\n-            return acc;\n-          }, {} as Record<string, Lead[]>);\n+          });\n+        }\n+        \n+        // Update positions in database\n+        if (positionUpdates.length > 0) {\n+          await updateLeadPositions(positionUpdates);\n           \n-          // Generate position updates for each status group\n-          const positionUpdates: { id: string; position: number }[] = [];\n+          // Update local state\n+          const updatedData = data.map(lead => {\n+            const update = positionUpdates.find(u => u.id === lead.id.toString());\n+            return update ? { ...lead, position: update.position } : lead;\n+          });\n           \n-          for (const status in leadsByStatus) {\n-            const statusLeads = leadsByStatus[status];\n-            // Sort by lastActivity date as a reasonable default order\n-            statusLeads.sort((a, b) => \n-              new Date(b.lastActivity).getTime() - new Date(a.lastActivity).getTime()\n-            );\n-            \n-            // Assign positions\n-            statusLeads.forEach((lead, index) => {\n-              if (!lead.position) {\n-                positionUpdates.push({\n-                  id: lead.id.toString(),\n-                  position: index + 1\n-                });\n-              }\n-            });\n-          }\n-          \n-          // Update positions in database\n-          if (positionUpdates.length > 0) {\n-            await updateLeadPositions(positionUpdates);\n-            \n-            // Update local state\n-            const updatedData = data.map(lead => {\n-              const update = positionUpdates.find(u => u.id === lead.id.toString());\n-              return update ? { ...lead, position: update.position } : lead;\n-            });\n-            \n-            setItems(updatedData);\n-          } else {\n-            setItems(data);\n-          }\n+          setItems(updatedData);\n         } else {\n           setItems(data);\n         }\n-        \n-        setError(null);\n-      } catch (err) {\n-        console.error('Error fetching leads:', err);\n-        setError('Failed to load leads. Please try again later.');\n-      } finally {\n-        setLoading(false);\n+      } else {\n+        setItems(data);\n       }\n+      \n+      setError(null);\n+    } catch (err) {\n+      console.error('Error fetching leads:', err);\n+      setError('Failed to load leads. Please try again later.');\n+    } finally {\n+      setLoading(false);\n     }\n+  }\n \n+  // Function to handle when a new lead is added\n+  const handleLeadAdded = () => {\n+    // Refetch leads\n     fetchLeads();\n+  };\n+\n+  useEffect(() => {\n+    fetchLeads();\n   }, []);\n \n   const sensors = useSensors(\n     useSensor(PointerSensor),\n"
                },
                {
                    "date": 1741294657343,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -100,12 +100,17 @@\n           \n           // Assign positions\n           statusLeads.forEach((lead, index) => {\n             if (!lead.position) {\n-              positionUpdates.push({\n-                id: lead.id.toString(),\n-                position: index + 1\n-              });\n+              // Ensure lead.id is valid before converting to string\n+              if (lead.id && !isNaN(lead.id)) {\n+                positionUpdates.push({\n+                  id: lead.id.toString(),\n+                  position: index + 1\n+                });\n+              } else {\n+                console.warn(`Skipping position update for lead with invalid ID: ${lead.id}`);\n+              }\n             }\n           });\n         }\n         \n"
                },
                {
                    "date": 1741294688287,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -240,12 +240,14 @@\n               // Reorder items\n               const reorderedItems = arrayMove(itemsInColumn, activeIndex, overIndex);\n               \n               // Update positions for all items in the column to match their new order\n-              const updates = reorderedItems.map((item, index) => ({\n-                id: item.id.toString(),\n-                position: index + 1\n-              }));\n+              const updates = reorderedItems\n+                .filter(item => item.id && !isNaN(item.id)) // Only include items with valid IDs\n+                .map((item, index) => ({\n+                  id: item.id.toString(),\n+                  position: index + 1\n+                }));\n               \n               // Use batch update for better performance\n               try {\n                 await updateLeadPositions(updates);\n"
                },
                {
                    "date": 1741294699526,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -195,8 +195,14 @@\n       if (activeItem && overColumn) {\n         try {\n           // Moving between columns\n           if (activeItem.status !== overColumn) {\n+            // Validate the lead ID before updating\n+            if (!activeItem.id || isNaN(activeItem.id)) {\n+              console.error(`Cannot update lead with invalid ID: ${activeItem.id}`);\n+              return;\n+            }\n+            \n             // Get items in the target column to calculate new position\n             const itemsInTargetColumn = items\n               .filter(item => item.status === overColumn)\n               .sort((a, b) => a.position - b.position);\n"
                },
                {
                    "date": 1741294718896,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -134,9 +134,12 @@\n       \n       setError(null);\n     } catch (err) {\n       console.error('Error fetching leads:', err);\n-      setError('Failed to load leads. Please try again later.');\n+      const errorMessage = err instanceof Error ? \n+        `Failed to load leads: ${err.message}` : \n+        'Failed to load leads. Please try again later.';\n+      setError(errorMessage);\n     } finally {\n       setLoading(false);\n     }\n   }\n"
                },
                {
                    "date": 1741294854691,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -72,16 +72,23 @@\n     try {\n       setLoading(true);\n       const data = await getLeads();\n       \n+      // Filter out leads with invalid IDs (negative numbers)\n+      const validLeads = data.filter(lead => lead.id > 0);\n+      \n+      if (validLeads.length < data.length) {\n+        console.warn(`Filtered out ${data.length - validLeads.length} leads with invalid IDs`);\n+      }\n+      \n       // Check if positions need to be initialized\n-      const needsPositionInit = data.some(lead => !lead.position);\n+      const needsPositionInit = validLeads.some(lead => !lead.position);\n       \n       if (needsPositionInit) {\n         console.log('Initializing positions for leads...');\n         \n         // Group leads by status\n-        const leadsByStatus = data.reduce((acc, lead) => {\n+        const leadsByStatus = validLeads.reduce((acc, lead) => {\n           if (!acc[lead.status]) {\n             acc[lead.status] = [];\n           }\n           acc[lead.status].push(lead);\n@@ -101,9 +108,9 @@\n           // Assign positions\n           statusLeads.forEach((lead, index) => {\n             if (!lead.position) {\n               // Ensure lead.id is valid before converting to string\n-              if (lead.id && !isNaN(lead.id)) {\n+              if (lead.id && !isNaN(lead.id) && lead.id > 0) {\n                 positionUpdates.push({\n                   id: lead.id.toString(),\n                   position: index + 1\n                 });\n@@ -118,19 +125,19 @@\n         if (positionUpdates.length > 0) {\n           await updateLeadPositions(positionUpdates);\n           \n           // Update local state\n-          const updatedData = data.map(lead => {\n+          const updatedData = validLeads.map(lead => {\n             const update = positionUpdates.find(u => u.id === lead.id.toString());\n             return update ? { ...lead, position: update.position } : lead;\n           });\n           \n           setItems(updatedData);\n         } else {\n-          setItems(data);\n+          setItems(validLeads);\n         }\n       } else {\n-        setItems(data);\n+        setItems(validLeads);\n       }\n       \n       setError(null);\n     } catch (err) {\n"
                },
                {
                    "date": 1741294866859,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -236,23 +236,24 @@\n             ));\n           } \n           // Reordering within the same column\n           else if (over.data.current?.type === 'item') {\n-            const activeIndex = items\n-              .filter(item => item.status === activeItem.status)\n+            const itemsInSameColumn = items.filter(item => \n+              item.status === activeItem.status && \n+              item.id > 0 // Only include items with valid positive IDs\n+            );\n+            \n+            const activeIndex = itemsInSameColumn\n               .sort((a, b) => a.position - b.position)\n               .findIndex(item => item.id.toString() === active.id);\n             \n-            const overIndex = items\n-              .filter(item => item.status === activeItem.status)\n+            const overIndex = itemsInSameColumn\n               .sort((a, b) => a.position - b.position)\n               .findIndex(item => item.id.toString() === over.id);\n             \n-            if (activeIndex !== overIndex) {\n+            if (activeIndex !== overIndex && activeIndex !== -1 && overIndex !== -1) {\n               // Get all items in the column, sorted by position\n-              const itemsInColumn = items\n-                .filter(item => item.status === activeItem.status)\n-                .sort((a, b) => a.position - b.position);\n+              const itemsInColumn = itemsInSameColumn.sort((a, b) => a.position - b.position);\n               \n               // Reorder items\n               const reorderedItems = arrayMove(itemsInColumn, activeIndex, overIndex);\n               \n"
                },
                {
                    "date": 1741294971821,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -206,16 +206,16 @@\n         try {\n           // Moving between columns\n           if (activeItem.status !== overColumn) {\n             // Validate the lead ID before updating\n-            if (!activeItem.id || isNaN(activeItem.id)) {\n+            if (!activeItem.id || isNaN(activeItem.id) || activeItem.id <= 0) {\n               console.error(`Cannot update lead with invalid ID: ${activeItem.id}`);\n               return;\n             }\n             \n             // Get items in the target column to calculate new position\n             const itemsInTargetColumn = items\n-              .filter(item => item.status === overColumn)\n+              .filter(item => item.status === overColumn && item.id > 0)\n               .sort((a, b) => a.position - b.position);\n             \n             // Calculate new position (add at the end of the target column)\n             const newPosition = itemsInTargetColumn.length > 0\n"
                },
                {
                    "date": 1741890197377,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -109,8 +109,11 @@\n           statusLeads.forEach((lead, index) => {\n             if (!lead.position) {\n               // Ensure lead.id is valid before converting to string\n               if (lead.id && !isNaN(lead.id) && lead.id > 0) {\n+                // Only include leads that exist in Firestore\n+                // The getLeads function already fetched these from Firestore,\n+                // so we know they exist\n                 positionUpdates.push({\n                   id: lead.id.toString(),\n                   position: index + 1\n                 });\n@@ -122,17 +125,23 @@\n         }\n         \n         // Update positions in database\n         if (positionUpdates.length > 0) {\n-          await updateLeadPositions(positionUpdates);\n-          \n-          // Update local state\n-          const updatedData = validLeads.map(lead => {\n-            const update = positionUpdates.find(u => u.id === lead.id.toString());\n-            return update ? { ...lead, position: update.position } : lead;\n-          });\n-          \n-          setItems(updatedData);\n+          try {\n+            await updateLeadPositions(positionUpdates);\n+            \n+            // Update local state\n+            const updatedData = validLeads.map(lead => {\n+              const update = positionUpdates.find(u => u.id === lead.id.toString());\n+              return update ? { ...lead, position: update.position } : lead;\n+            });\n+            \n+            setItems(updatedData);\n+          } catch (updateError) {\n+            console.error('Error updating lead positions:', updateError);\n+            // Continue with the existing data even if position updates fail\n+            setItems(validLeads);\n+          }\n         } else {\n           setItems(validLeads);\n         }\n       } else {\n"
                },
                {
                    "date": 1741890255136,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -109,11 +109,8 @@\n           statusLeads.forEach((lead, index) => {\n             if (!lead.position) {\n               // Ensure lead.id is valid before converting to string\n               if (lead.id && !isNaN(lead.id) && lead.id > 0) {\n-                // Only include leads that exist in Firestore\n-                // The getLeads function already fetched these from Firestore,\n-                // so we know they exist\n                 positionUpdates.push({\n                   id: lead.id.toString(),\n                   position: index + 1\n                 });\n"
                },
                {
                    "date": 1741890278051,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -283,8 +283,11 @@\n                     : item;\n                 }));\n               } catch (err) {\n                 console.error('Error batch updating lead positions:', err);\n+                // Don't update the UI state if the database update fails\n+                // This will cause the UI to revert to the previous state\n+                fetchLeads(); // Refresh the data to ensure UI is in sync with database\n               }\n             }\n           }\n         } catch (err) {\n"
                },
                {
                    "date": 1741890285921,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,454 @@\n+\"use client\";\n+\n+import { useState, useEffect } from 'react';\n+import { motion } from 'framer-motion';\n+import {\n+  DndContext,\n+  DragOverlay,\n+  closestCorners,\n+  KeyboardSensor,\n+  PointerSensor,\n+  useSensor,\n+  useSensors,\n+  DragStartEvent,\n+  DragEndEvent,\n+} from '@dnd-kit/core';\n+import {\n+  arrayMove,\n+  SortableContext,\n+  sortableKeyboardCoordinates,\n+  horizontalListSortingStrategy,\n+  verticalListSortingStrategy,\n+} from '@dnd-kit/sortable';\n+import { KanbanColumn } from './kanban-column';\n+import { KanbanCard } from './kanban-card';\n+import { Button } from '@/components/ui/button';\n+import { Card } from '@/components/ui/card';\n+import { \n+  Plus, \n+  Search, \n+  SlidersHorizontal,\n+  TrendingUp,\n+  Users,\n+  DollarSign,\n+  BarChart\n+} from 'lucide-react';\n+import { Lead } from '@/data/leads';\n+import { getLeads, updateLead, updateLeadPositions } from '@/lib/services/leads-service';\n+import { formatCurrency } from '@/lib/utils';\n+import { \n+  collection, \n+} from 'firebase/firestore';\n+import { db } from '@/lib/firebase';\n+import { AddLeadDialog } from '@/components/leads/add-lead-dialog';\n+\n+// Professional color scheme using muted, corporate tones\n+const initialColumns = [\n+  { id: 'New', title: 'New Leads', color: 'from-slate-600 to-slate-500' },\n+  { id: 'Contacted', title: 'Contacted', color: 'from-blue-700 to-blue-600' },\n+  { id: 'Qualified', title: 'Qualified', color: 'from-emerald-700 to-emerald-600' },\n+  { id: 'Negotiating', title: 'Negotiating', color: 'from-indigo-700 to-indigo-600' },\n+];\n+\n+const availableColors = [\n+  { id: 'slate', gradient: 'from-slate-600 to-slate-500' },\n+  { id: 'blue', gradient: 'from-blue-700 to-blue-600' },\n+  { id: 'emerald', gradient: 'from-emerald-700 to-emerald-600' },\n+  { id: 'indigo', gradient: 'from-indigo-700 to-indigo-600' },\n+  { id: 'zinc', gradient: 'from-zinc-600 to-zinc-500' },\n+  { id: 'gray', gradient: 'from-gray-600 to-gray-500' },\n+];\n+\n+export function LeadsKanban({ searchTerm }: { searchTerm: string }) {\n+  const [items, setItems] = useState<Lead[]>([]);\n+  const [columns, setColumns] = useState(initialColumns);\n+  const [activeId, setActiveId] = useState<string | null>(null);\n+  const [activeColumnId, setActiveColumnId] = useState<string | null>(null);\n+  const [loading, setLoading] = useState(true);\n+  const [error, setError] = useState<string | null>(null);\n+\n+  // Function to fetch leads data\n+  async function fetchLeads() {\n+    try {\n+      setLoading(true);\n+      const data = await getLeads();\n+      \n+      // Filter out leads with invalid IDs (negative numbers)\n+      const validLeads = data.filter(lead => lead.id > 0);\n+      \n+      if (validLeads.length < data.length) {\n+        console.warn(`Filtered out ${data.length - validLeads.length} leads with invalid IDs`);\n+      }\n+      \n+      // Check if positions need to be initialized\n+      const needsPositionInit = validLeads.some(lead => !lead.position);\n+      \n+      if (needsPositionInit) {\n+        console.log('Initializing positions for leads...');\n+        \n+        // Group leads by status\n+        const leadsByStatus = validLeads.reduce((acc, lead) => {\n+          if (!acc[lead.status]) {\n+            acc[lead.status] = [];\n+          }\n+          acc[lead.status].push(lead);\n+          return acc;\n+        }, {} as Record<string, Lead[]>);\n+        \n+        // Generate position updates for each status group\n+        const positionUpdates: { id: string; position: number }[] = [];\n+        \n+        for (const status in leadsByStatus) {\n+          const statusLeads = leadsByStatus[status];\n+          // Sort by lastActivity date as a reasonable default order\n+          statusLeads.sort((a, b) => \n+            new Date(b.lastActivity).getTime() - new Date(a.lastActivity).getTime()\n+          );\n+          \n+          // Assign positions\n+          statusLeads.forEach((lead, index) => {\n+            if (!lead.position) {\n+              // Ensure lead.id is valid before converting to string\n+              if (lead.id && !isNaN(lead.id) && lead.id > 0) {\n+                positionUpdates.push({\n+                  id: lead.id.toString(),\n+                  position: index + 1\n+                });\n+              } else {\n+                console.warn(`Skipping position update for lead with invalid ID: ${lead.id}`);\n+              }\n+            }\n+          });\n+        }\n+        \n+        // Update positions in database\n+        if (positionUpdates.length > 0) {\n+          try {\n+            await updateLeadPositions(positionUpdates);\n+            \n+            // Update local state\n+            const updatedData = validLeads.map(lead => {\n+              const update = positionUpdates.find(u => u.id === lead.id.toString());\n+              return update ? { ...lead, position: update.position } : lead;\n+            });\n+            \n+            setItems(updatedData);\n+          } catch (updateError) {\n+            console.error('Error updating lead positions:', updateError);\n+            // Continue with the existing data even if position updates fail\n+            setItems(validLeads);\n+          }\n+        } else {\n+          setItems(validLeads);\n+        }\n+      } else {\n+        setItems(validLeads);\n+      }\n+      \n+      setError(null);\n+    } catch (err) {\n+      console.error('Error fetching leads:', err);\n+      const errorMessage = err instanceof Error ? \n+        `Failed to load leads: ${err.message}` : \n+        'Failed to load leads. Please try again later.';\n+      setError(errorMessage);\n+    } finally {\n+      setLoading(false);\n+    }\n+  }\n+\n+  // Function to handle when a new lead is added\n+  const handleLeadAdded = () => {\n+    // Refetch leads\n+    fetchLeads();\n+  };\n+\n+  useEffect(() => {\n+    fetchLeads();\n+  }, []);\n+\n+  const sensors = useSensors(\n+    useSensor(PointerSensor),\n+    useSensor(KeyboardSensor, {\n+      coordinateGetter: sortableKeyboardCoordinates,\n+    })\n+  );\n+\n+  // Calculate summary statistics\n+  const totalLeads = items.length;\n+  const qualifiedLeads = items.filter(item => item.status === 'Qualified').length;\n+  const totalValue = items.reduce((sum, item) => {\n+    const numericValue = item.value.replace(/[^0-9]/g, '');\n+    return sum + (numericValue ? parseInt(numericValue) : 0);\n+  }, 0);\n+  const conversionRate = totalLeads > 0 ? Math.round((qualifiedLeads / totalLeads) * 100) : 0;\n+\n+  const handleDragStart = (event: DragStartEvent) => {\n+    const { active } = event;\n+    if (active.data.current?.type === 'column') {\n+      setActiveColumnId(active.id as string);\n+    } else {\n+      setActiveId(active.id as string);\n+    }\n+  };\n+\n+  const handleDragEnd = async (event: DragEndEvent) => {\n+    const { active, over } = event;\n+\n+    if (!over) return;\n+\n+    if (active.data.current?.type === 'column') {\n+      const oldIndex = columns.findIndex(col => col.id === active.id);\n+      const newIndex = columns.findIndex(col => col.id === over.id);\n+\n+      if (oldIndex !== newIndex) {\n+        setColumns(arrayMove(columns, oldIndex, newIndex));\n+      }\n+    } else {\n+      const activeItem = items.find(item => item.id.toString() === active.id);\n+      const overColumn = over.data.current?.type === 'column' ? over.id : over.data.current?.columnId;\n+\n+      if (activeItem && overColumn) {\n+        try {\n+          // Moving between columns\n+          if (activeItem.status !== overColumn) {\n+            // Validate the lead ID before updating\n+            if (!activeItem.id || isNaN(activeItem.id) || activeItem.id <= 0) {\n+              console.error(`Cannot update lead with invalid ID: ${activeItem.id}`);\n+              return;\n+            }\n+            \n+            // Get items in the target column to calculate new position\n+            const itemsInTargetColumn = items\n+              .filter(item => item.status === overColumn && item.id > 0)\n+              .sort((a, b) => a.position - b.position);\n+            \n+            // Calculate new position (add at the end of the target column)\n+            const newPosition = itemsInTargetColumn.length > 0\n+              ? Math.max(...itemsInTargetColumn.map(item => item.position)) + 1\n+              : 1;\n+            \n+            // Update in Firestore\n+            await updateLead(activeItem.id.toString(), { \n+              status: overColumn as string,\n+              position: newPosition\n+            });\n+            \n+            // Update local state\n+            setItems(items.map(item => \n+              item.id.toString() === active.id\n+                ? { ...item, status: overColumn as string, position: newPosition }\n+                : item\n+            ));\n+          } \n+          // Reordering within the same column\n+          else if (over.data.current?.type === 'item') {\n+            const itemsInSameColumn = items.filter(item => \n+              item.status === activeItem.status && \n+              item.id > 0 // Only include items with valid positive IDs\n+            );\n+            \n+            const activeIndex = itemsInSameColumn\n+              .sort((a, b) => a.position - b.position)\n+              .findIndex(item => item.id.toString() === active.id);\n+            \n+            const overIndex = itemsInSameColumn\n+              .sort((a, b) => a.position - b.position)\n+              .findIndex(item => item.id.toString() === over.id);\n+            \n+            if (activeIndex !== overIndex && activeIndex !== -1 && overIndex !== -1) {\n+              // Get all items in the column, sorted by position\n+              const itemsInColumn = itemsInSameColumn.sort((a, b) => a.position - b.position);\n+              \n+              // Reorder items\n+              const reorderedItems = arrayMove(itemsInColumn, activeIndex, overIndex);\n+              \n+              // Update positions for all items in the column to match their new order\n+              const updates = reorderedItems\n+                .filter(item => item.id && !isNaN(item.id)) // Only include items with valid IDs\n+                .map((item, index) => ({\n+                  id: item.id.toString(),\n+                  position: index + 1\n+                }));\n+              \n+              // Use batch update for better performance\n+              try {\n+                await updateLeadPositions(updates);\n+                \n+                // Update local state for all affected items\n+                setItems(items.map(item => {\n+                  const update = updates.find(u => u.id === item.id.toString());\n+                  return update \n+                    ? { ...item, position: update.position }\n+                    : item;\n+                }));\n+              } catch (err) {\n+                console.error('Error batch updating lead positions:', err);\n+                // Don't update the UI state if the database update fails\n+                // This will cause the UI to revert to the previous state\n+                fetchLeads(); // Refresh the data to ensure UI is in sync with database\n+              }\n+            }\n+          }\n+        } catch (err) {\n+          console.error('Error updating lead position:', err);\n+          // You might want to show a toast notification here\n+        }\n+      }\n+    }\n+\n+    setActiveId(null);\n+    setActiveColumnId(null);\n+  };\n+\n+  if (loading) {\n+    return <div className=\"py-10 text-center\">Loading leads...</div>;\n+  }\n+\n+  if (error) {\n+    return <div className=\"py-10 text-center text-red-500\">{error}</div>;\n+  }\n+\n+  return (\n+    <DndContext\n+      sensors={sensors}\n+      collisionDetection={closestCorners}\n+      onDragStart={handleDragStart}\n+      onDragEnd={handleDragEnd}\n+    >\n+      {/* Summary Statistics */}\n+      <div className=\"grid grid-cols-4 gap-4 mb-8\">\n+        <Card className=\"p-4 border-l-4 border-l-blue-600\">\n+          <div className=\"flex items-center justify-between\">\n+            <div>\n+              <p className=\"text-sm font-medium text-muted-foreground\">Total Leads</p>\n+              <p className=\"text-2xl font-bold\">{totalLeads}</p>\n+            </div>\n+            <Users className=\"w-8 h-8 text-blue-600\" />\n+          </div>\n+        </Card>\n+        \n+        <Card className=\"p-4 border-l-4 border-l-emerald-600\">\n+          <div className=\"flex items-center justify-between\">\n+            <div>\n+              <p className=\"text-sm font-medium text-muted-foreground\">Conversion Rate</p>\n+              <p className=\"text-2xl font-bold\">{conversionRate}%</p>\n+            </div>\n+            <BarChart className=\"w-8 h-8 text-emerald-600\" />\n+          </div>\n+        </Card>\n+        \n+        <Card className=\"p-4 border-l-4 border-l-indigo-600\">\n+          <div className=\"flex items-center justify-between\">\n+            <div>\n+              <p className=\"text-sm font-medium text-muted-foreground\">Pipeline Value</p>\n+              <p className=\"text-2xl font-bold\">{formatCurrency(totalValue)}</p>\n+            </div>\n+            <DollarSign className=\"w-8 h-8 text-indigo-600\" />\n+          </div>\n+        </Card>\n+        \n+        <Card className=\"p-4 border-l-4 border-l-slate-600\">\n+          <div className=\"flex items-center justify-between\">\n+            <div>\n+              <p className=\"text-sm font-medium text-muted-foreground\">Qualified Leads</p>\n+              <p className=\"text-2xl font-bold\">{qualifiedLeads}</p>\n+            </div>\n+            <TrendingUp className=\"w-8 h-8 text-slate-600\" />\n+          </div>\n+        </Card>\n+      </div>\n+\n+      <div className=\"mb-4 flex justify-between items-center\">\n+        <div className=\"flex items-center space-x-2\">\n+          <AddLeadDialog onLeadAdded={handleLeadAdded}>\n+            <Button className=\"bg-blue-600 hover:bg-blue-700\">\n+              <Plus className=\"w-4 h-4 mr-2\" />\n+              Add Lead\n+            </Button>\n+          </AddLeadDialog>\n+          <Button variant=\"outline\" className=\"border-slate-200\">\n+            <SlidersHorizontal className=\"w-4 h-4 mr-2\" />\n+            Filters\n+          </Button>\n+        </div>\n+      </div>\n+\n+      <div className=\"relative overflow-x-auto pb-4\">\n+        <SortableContext\n+          items={columns.map(col => col.id)}\n+          strategy={horizontalListSortingStrategy}\n+        >\n+          <div className=\"flex space-x-6 min-w-full\" style={{ width: `${columns.length * 320}px` }}>\n+            {columns.map((column) => (\n+              <div key={column.id} className=\"w-[300px] flex-shrink-0\">\n+                <KanbanColumn\n+                  id={column.id}\n+                  title={column.title}\n+                  color={column.color}\n+                  onTitleChange={(newTitle) => {\n+                    setColumns(columns.map(col =>\n+                      col.id === column.id ? { ...col, title: newTitle } : col\n+                    ));\n+                  }}\n+                  onColorChange={(newColor) => {\n+                    setColumns(columns.map(col =>\n+                      col.id === column.id ? { ...col, color: newColor } : col\n+                    ));\n+                  }}\n+                  onDelete={() => {\n+                    setColumns(columns.filter(col => col.id !== column.id));\n+                    // Move leads in deleted column to New\n+                    setItems(items.map(item =>\n+                      item.status === column.id\n+                        ? { ...item, status: 'New' }\n+                        : item\n+                    ));\n+                  }}\n+                  availableColors={availableColors}\n+                  isDeletable={column.id !== 'New'}\n+                >\n+                  <SortableContext\n+                    items={items\n+                      .filter(item => item.status === column.id)\n+                      .map(item => item.id.toString())}\n+                    strategy={verticalListSortingStrategy}\n+                  >\n+                    {items\n+                      .filter(item => \n+                        item.status === column.id &&\n+                        (item.name.toLowerCase().includes(searchTerm.toLowerCase()) ||\n+                         item.company.toLowerCase().includes(searchTerm.toLowerCase()))\n+                      )\n+                      .sort((a, b) => a.position - b.position)\n+                      .map((item) => (\n+                        <KanbanCard\n+                          key={item.id}\n+                          id={item.id.toString()}\n+                          lead={item}\n+                          columnColor={column.color}\n+                        />\n+                      ))\n+                    }\n+                  </SortableContext>\n+                </KanbanColumn>\n+              </div>\n+            ))}\n+          </div>\n+        </SortableContext>\n+      </div>\n+\n+      <DragOverlay>\n+        {activeId ? (\n+          <KanbanCard\n+            id={activeId}\n+            lead={items.find(item => item.id.toString() === activeId)!}\n+            columnColor={columns.find(col => col.id === items.find(item => \n+              item.id.toString() === activeId\n+            )?.status)?.color || ''}\n+          />\n+        ) : null}\n+      </DragOverlay>\n+    </DndContext>\n+  );\n+}\n\\ No newline at end of file\n"
                },
                {
                    "date": 1741890295766,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -227,474 +227,26 @@\n             const newPosition = itemsInTargetColumn.length > 0\n               ? Math.max(...itemsInTargetColumn.map(item => item.position)) + 1\n               : 1;\n             \n-            // Update in Firestore\n-            await updateLead(activeItem.id.toString(), { \n-              status: overColumn as string,\n-              position: newPosition\n-            });\n-            \n-            // Update local state\n-            setItems(items.map(item => \n-              item.id.toString() === active.id\n-                ? { ...item, status: overColumn as string, position: newPosition }\n-                : item\n-            ));\n-          } \n-          // Reordering within the same column\n-          else if (over.data.current?.type === 'item') {\n-            const itemsInSameColumn = items.filter(item => \n-              item.status === activeItem.status && \n-              item.id > 0 // Only include items with valid positive IDs\n-            );\n-            \n-            const activeIndex = itemsInSameColumn\n-              .sort((a, b) => a.position - b.position)\n-              .findIndex(item => item.id.toString() === active.id);\n-            \n-            const overIndex = itemsInSameColumn\n-              .sort((a, b) => a.position - b.position)\n-              .findIndex(item => item.id.toString() === over.id);\n-            \n-            if (activeIndex !== overIndex && activeIndex !== -1 && overIndex !== -1) {\n-              // Get all items in the column, sorted by position\n-              const itemsInColumn = itemsInSameColumn.sort((a, b) => a.position - b.position);\n+            try {\n+              // Update in Firestore\n+              await updateLead(activeItem.id.toString(), { \n+                status: overColumn as string,\n+                position: newPosition\n+              });\n               \n-              // Reorder items\n-              const reorderedItems = arrayMove(itemsInColumn, activeIndex, overIndex);\n-              \n-              // Update positions for all items in the column to match their new order\n-              const updates = reorderedItems\n-                .filter(item => item.id && !isNaN(item.id)) // Only include items with valid IDs\n-                .map((item, index) => ({\n-                  id: item.id.toString(),\n-                  position: index + 1\n-                }));\n-              \n-              // Use batch update for better performance\n-              try {\n-                await updateLeadPositions(updates);\n-                \n-                // Update local state for all affected items\n-                setItems(items.map(item => {\n-                  const update = updates.find(u => u.id === item.id.toString());\n-                  return update \n-                    ? { ...item, position: update.position }\n-                    : item;\n-                }));\n-              } catch (err) {\n-                console.error('Error batch updating lead positions:', err);\n-                // Don't update the UI state if the database update fails\n-                // This will cause the UI to revert to the previous state\n-                fetchLeads(); // Refresh the data to ensure UI is in sync with database\n-              }\n+              // Update local state\n+              setItems(items.map(item => \n+                item.id.toString() === active.id\n+                  ? { ...item, status: overColumn as string, position: newPosition }\n+                  : item\n+              ));\n+            } catch (updateError) {\n+              console.error('Error updating lead status:', updateError);\n+              // Refresh the data to ensure UI is in sync with database\n+              fetchLeads();\n             }\n-          }\n-        } catch (err) {\n-          console.error('Error updating lead position:', err);\n-          // You might want to show a toast notification here\n-        }\n-      }\n-    }\n-\n-    setActiveId(null);\n-    setActiveColumnId(null);\n-  };\n-\n-  if (loading) {\n-    return <div className=\"py-10 text-center\">Loading leads...</div>;\n-  }\n-\n-  if (error) {\n-    return <div className=\"py-10 text-center text-red-500\">{error}</div>;\n-  }\n-\n-  return (\n-    <DndContext\n-      sensors={sensors}\n-      collisionDetection={closestCorners}\n-      onDragStart={handleDragStart}\n-      onDragEnd={handleDragEnd}\n-    >\n-      {/* Summary Statistics */}\n-      <div className=\"grid grid-cols-4 gap-4 mb-8\">\n-        <Card className=\"p-4 border-l-4 border-l-blue-600\">\n-          <div className=\"flex items-center justify-between\">\n-            <div>\n-              <p className=\"text-sm font-medium text-muted-foreground\">Total Leads</p>\n-              <p className=\"text-2xl font-bold\">{totalLeads}</p>\n-            </div>\n-            <Users className=\"w-8 h-8 text-blue-600\" />\n-          </div>\n-        </Card>\n-        \n-        <Card className=\"p-4 border-l-4 border-l-emerald-600\">\n-          <div className=\"flex items-center justify-between\">\n-            <div>\n-              <p className=\"text-sm font-medium text-muted-foreground\">Conversion Rate</p>\n-              <p className=\"text-2xl font-bold\">{conversionRate}%</p>\n-            </div>\n-            <BarChart className=\"w-8 h-8 text-emerald-600\" />\n-          </div>\n-        </Card>\n-        \n-        <Card className=\"p-4 border-l-4 border-l-indigo-600\">\n-          <div className=\"flex items-center justify-between\">\n-            <div>\n-              <p className=\"text-sm font-medium text-muted-foreground\">Pipeline Value</p>\n-              <p className=\"text-2xl font-bold\">{formatCurrency(totalValue)}</p>\n-            </div>\n-            <DollarSign className=\"w-8 h-8 text-indigo-600\" />\n-          </div>\n-        </Card>\n-        \n-        <Card className=\"p-4 border-l-4 border-l-slate-600\">\n-          <div className=\"flex items-center justify-between\">\n-            <div>\n-              <p className=\"text-sm font-medium text-muted-foreground\">Qualified Leads</p>\n-              <p className=\"text-2xl font-bold\">{qualifiedLeads}</p>\n-            </div>\n-            <TrendingUp className=\"w-8 h-8 text-slate-600\" />\n-          </div>\n-        </Card>\n-      </div>\n-\n-      <div className=\"mb-4 flex justify-between items-center\">\n-        <div className=\"flex items-center space-x-2\">\n-          <AddLeadDialog onLeadAdded={handleLeadAdded}>\n-            <Button className=\"bg-blue-600 hover:bg-blue-700\">\n-              <Plus className=\"w-4 h-4 mr-2\" />\n-              Add Lead\n-            </Button>\n-          </AddLeadDialog>\n-          <Button variant=\"outline\" className=\"border-slate-200\">\n-            <SlidersHorizontal className=\"w-4 h-4 mr-2\" />\n-            Filters\n-          </Button>\n-        </div>\n-      </div>\n-\n-      <div className=\"relative overflow-x-auto pb-4\">\n-        <SortableContext\n-          items={columns.map(col => col.id)}\n-          strategy={horizontalListSortingStrategy}\n-        >\n-          <div className=\"flex space-x-6 min-w-full\" style={{ width: `${columns.length * 320}px` }}>\n-            {columns.map((column) => (\n-              <div key={column.id} className=\"w-[300px] flex-shrink-0\">\n-                <KanbanColumn\n-                  id={column.id}\n-                  title={column.title}\n-                  color={column.color}\n-                  onTitleChange={(newTitle) => {\n-                    setColumns(columns.map(col =>\n-                      col.id === column.id ? { ...col, title: newTitle } : col\n-                    ));\n-                  }}\n-                  onColorChange={(newColor) => {\n-                    setColumns(columns.map(col =>\n-                      col.id === column.id ? { ...col, color: newColor } : col\n-                    ));\n-                  }}\n-                  onDelete={() => {\n-                    setColumns(columns.filter(col => col.id !== column.id));\n-                    // Move leads in deleted column to New\n-                    setItems(items.map(item =>\n-                      item.status === column.id\n-                        ? { ...item, status: 'New' }\n-                        : item\n-                    ));\n-                  }}\n-                  availableColors={availableColors}\n-                  isDeletable={column.id !== 'New'}\n-                >\n-                  <SortableContext\n-                    items={items\n-                      .filter(item => item.status === column.id)\n-                      .map(item => item.id.toString())}\n-                    strategy={verticalListSortingStrategy}\n-                  >\n-                    {items\n-                      .filter(item => \n-                        item.status === column.id &&\n-                        (item.name.toLowerCase().includes(searchTerm.toLowerCase()) ||\n-                         item.company.toLowerCase().includes(searchTerm.toLowerCase()))\n-                      )\n-                      .sort((a, b) => a.position - b.position)\n-                      .map((item) => (\n-                        <KanbanCard\n-                          key={item.id}\n-                          id={item.id.toString()}\n-                          lead={item}\n-                          columnColor={column.color}\n-                        />\n-                      ))\n-                    }\n-                  </SortableContext>\n-                </KanbanColumn>\n-              </div>\n-            ))}\n-          </div>\n-        </SortableContext>\n-      </div>\n-\n-      <DragOverlay>\n-        {activeId ? (\n-          <KanbanCard\n-            id={activeId}\n-            lead={items.find(item => item.id.toString() === activeId)!}\n-            columnColor={columns.find(col => col.id === items.find(item => \n-              item.id.toString() === activeId\n-            )?.status)?.color || ''}\n-          />\n-        ) : null}\n-      </DragOverlay>\n-    </DndContext>\n-  );\n-}\n-\"use client\";\n-\n-import { useState, useEffect } from 'react';\n-import { motion } from 'framer-motion';\n-import {\n-  DndContext,\n-  DragOverlay,\n-  closestCorners,\n-  KeyboardSensor,\n-  PointerSensor,\n-  useSensor,\n-  useSensors,\n-  DragStartEvent,\n-  DragEndEvent,\n-} from '@dnd-kit/core';\n-import {\n-  arrayMove,\n-  SortableContext,\n-  sortableKeyboardCoordinates,\n-  horizontalListSortingStrategy,\n-  verticalListSortingStrategy,\n-} from '@dnd-kit/sortable';\n-import { KanbanColumn } from './kanban-column';\n-import { KanbanCard } from './kanban-card';\n-import { Button } from '@/components/ui/button';\n-import { Card } from '@/components/ui/card';\n-import { \n-  Plus, \n-  Search, \n-  SlidersHorizontal,\n-  TrendingUp,\n-  Users,\n-  DollarSign,\n-  BarChart\n-} from 'lucide-react';\n-import { Lead } from '@/data/leads';\n-import { getLeads, updateLead, updateLeadPositions } from '@/lib/services/leads-service';\n-import { formatCurrency } from '@/lib/utils';\n-import { \n-  collection, \n-} from 'firebase/firestore';\n-import { db } from '@/lib/firebase';\n-import { AddLeadDialog } from '@/components/leads/add-lead-dialog';\n-\n-// Professional color scheme using muted, corporate tones\n-const initialColumns = [\n-  { id: 'New', title: 'New Leads', color: 'from-slate-600 to-slate-500' },\n-  { id: 'Contacted', title: 'Contacted', color: 'from-blue-700 to-blue-600' },\n-  { id: 'Qualified', title: 'Qualified', color: 'from-emerald-700 to-emerald-600' },\n-  { id: 'Negotiating', title: 'Negotiating', color: 'from-indigo-700 to-indigo-600' },\n-];\n-\n-const availableColors = [\n-  { id: 'slate', gradient: 'from-slate-600 to-slate-500' },\n-  { id: 'blue', gradient: 'from-blue-700 to-blue-600' },\n-  { id: 'emerald', gradient: 'from-emerald-700 to-emerald-600' },\n-  { id: 'indigo', gradient: 'from-indigo-700 to-indigo-600' },\n-  { id: 'zinc', gradient: 'from-zinc-600 to-zinc-500' },\n-  { id: 'gray', gradient: 'from-gray-600 to-gray-500' },\n-];\n-\n-export function LeadsKanban({ searchTerm }: { searchTerm: string }) {\n-  const [items, setItems] = useState<Lead[]>([]);\n-  const [columns, setColumns] = useState(initialColumns);\n-  const [activeId, setActiveId] = useState<string | null>(null);\n-  const [activeColumnId, setActiveColumnId] = useState<string | null>(null);\n-  const [loading, setLoading] = useState(true);\n-  const [error, setError] = useState<string | null>(null);\n-\n-  // Function to fetch leads data\n-  async function fetchLeads() {\n-    try {\n-      setLoading(true);\n-      const data = await getLeads();\n-      \n-      // Filter out leads with invalid IDs (negative numbers)\n-      const validLeads = data.filter(lead => lead.id > 0);\n-      \n-      if (validLeads.length < data.length) {\n-        console.warn(`Filtered out ${data.length - validLeads.length} leads with invalid IDs`);\n-      }\n-      \n-      // Check if positions need to be initialized\n-      const needsPositionInit = validLeads.some(lead => !lead.position);\n-      \n-      if (needsPositionInit) {\n-        console.log('Initializing positions for leads...');\n-        \n-        // Group leads by status\n-        const leadsByStatus = validLeads.reduce((acc, lead) => {\n-          if (!acc[lead.status]) {\n-            acc[lead.status] = [];\n-          }\n-          acc[lead.status].push(lead);\n-          return acc;\n-        }, {} as Record<string, Lead[]>);\n-        \n-        // Generate position updates for each status group\n-        const positionUpdates: { id: string; position: number }[] = [];\n-        \n-        for (const status in leadsByStatus) {\n-          const statusLeads = leadsByStatus[status];\n-          // Sort by lastActivity date as a reasonable default order\n-          statusLeads.sort((a, b) => \n-            new Date(b.lastActivity).getTime() - new Date(a.lastActivity).getTime()\n-          );\n-          \n-          // Assign positions\n-          statusLeads.forEach((lead, index) => {\n-            if (!lead.position) {\n-              // Ensure lead.id is valid before converting to string\n-              if (lead.id && !isNaN(lead.id) && lead.id > 0) {\n-                positionUpdates.push({\n-                  id: lead.id.toString(),\n-                  position: index + 1\n-                });\n-              } else {\n-                console.warn(`Skipping position update for lead with invalid ID: ${lead.id}`);\n-              }\n-            }\n-          });\n-        }\n-        \n-        // Update positions in database\n-        if (positionUpdates.length > 0) {\n-          try {\n-            await updateLeadPositions(positionUpdates);\n-            \n-            // Update local state\n-            const updatedData = validLeads.map(lead => {\n-              const update = positionUpdates.find(u => u.id === lead.id.toString());\n-              return update ? { ...lead, position: update.position } : lead;\n-            });\n-            \n-            setItems(updatedData);\n-          } catch (updateError) {\n-            console.error('Error updating lead positions:', updateError);\n-            // Continue with the existing data even if position updates fail\n-            setItems(validLeads);\n-          }\n-        } else {\n-          setItems(validLeads);\n-        }\n-      } else {\n-        setItems(validLeads);\n-      }\n-      \n-      setError(null);\n-    } catch (err) {\n-      console.error('Error fetching leads:', err);\n-      const errorMessage = err instanceof Error ? \n-        `Failed to load leads: ${err.message}` : \n-        'Failed to load leads. Please try again later.';\n-      setError(errorMessage);\n-    } finally {\n-      setLoading(false);\n-    }\n-  }\n-\n-  // Function to handle when a new lead is added\n-  const handleLeadAdded = () => {\n-    // Refetch leads\n-    fetchLeads();\n-  };\n-\n-  useEffect(() => {\n-    fetchLeads();\n-  }, []);\n-\n-  const sensors = useSensors(\n-    useSensor(PointerSensor),\n-    useSensor(KeyboardSensor, {\n-      coordinateGetter: sortableKeyboardCoordinates,\n-    })\n-  );\n-\n-  // Calculate summary statistics\n-  const totalLeads = items.length;\n-  const qualifiedLeads = items.filter(item => item.status === 'Qualified').length;\n-  const totalValue = items.reduce((sum, item) => {\n-    const numericValue = item.value.replace(/[^0-9]/g, '');\n-    return sum + (numericValue ? parseInt(numericValue) : 0);\n-  }, 0);\n-  const conversionRate = totalLeads > 0 ? Math.round((qualifiedLeads / totalLeads) * 100) : 0;\n-\n-  const handleDragStart = (event: DragStartEvent) => {\n-    const { active } = event;\n-    if (active.data.current?.type === 'column') {\n-      setActiveColumnId(active.id as string);\n-    } else {\n-      setActiveId(active.id as string);\n-    }\n-  };\n-\n-  const handleDragEnd = async (event: DragEndEvent) => {\n-    const { active, over } = event;\n-\n-    if (!over) return;\n-\n-    if (active.data.current?.type === 'column') {\n-      const oldIndex = columns.findIndex(col => col.id === active.id);\n-      const newIndex = columns.findIndex(col => col.id === over.id);\n-\n-      if (oldIndex !== newIndex) {\n-        setColumns(arrayMove(columns, oldIndex, newIndex));\n-      }\n-    } else {\n-      const activeItem = items.find(item => item.id.toString() === active.id);\n-      const overColumn = over.data.current?.type === 'column' ? over.id : over.data.current?.columnId;\n-\n-      if (activeItem && overColumn) {\n-        try {\n-          // Moving between columns\n-          if (activeItem.status !== overColumn) {\n-            // Validate the lead ID before updating\n-            if (!activeItem.id || isNaN(activeItem.id) || activeItem.id <= 0) {\n-              console.error(`Cannot update lead with invalid ID: ${activeItem.id}`);\n-              return;\n-            }\n-            \n-            // Get items in the target column to calculate new position\n-            const itemsInTargetColumn = items\n-              .filter(item => item.status === overColumn && item.id > 0)\n-              .sort((a, b) => a.position - b.position);\n-            \n-            // Calculate new position (add at the end of the target column)\n-            const newPosition = itemsInTargetColumn.length > 0\n-              ? Math.max(...itemsInTargetColumn.map(item => item.position)) + 1\n-              : 1;\n-            \n-            // Update in Firestore\n-            await updateLead(activeItem.id.toString(), { \n-              status: overColumn as string,\n-              position: newPosition\n-            });\n-            \n-            // Update local state\n-            setItems(items.map(item => \n-              item.id.toString() === active.id\n-                ? { ...item, status: overColumn as string, position: newPosition }\n-                : item\n-            ));\n           } \n           // Reordering within the same column\n           else if (over.data.current?.type === 'item') {\n             const itemsInSameColumn = items.filter(item => \n"
                },
                {
                    "date": 1741890519132,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -109,8 +109,14 @@\n           statusLeads.forEach((lead, index) => {\n             if (!lead.position) {\n               // Ensure lead.id is valid before converting to string\n               if (lead.id && !isNaN(lead.id) && lead.id > 0) {\n+                // Skip the problematic lead ID if it matches the one in the error\n+                if (lead.id.toString() === '1741295054950') {\n+                  console.warn(`Skipping known problematic lead ID: ${lead.id}`);\n+                  return;\n+                }\n+                \n                 positionUpdates.push({\n                   id: lead.id.toString(),\n                   position: index + 1\n                 });\n"
                },
                {
                    "date": 1741890529766,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -277,8 +277,9 @@\n               \n               // Update positions for all items in the column to match their new order\n               const updates = reorderedItems\n                 .filter(item => item.id && !isNaN(item.id)) // Only include items with valid IDs\n+                .filter(item => item.id.toString() !== '1741295054950') // Filter out the problematic lead ID\n                 .map((item, index) => ({\n                   id: item.id.toString(),\n                   position: index + 1\n                 }));\n"
                },
                {
                    "date": 1741890536712,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -223,8 +223,14 @@\n               console.error(`Cannot update lead with invalid ID: ${activeItem.id}`);\n               return;\n             }\n             \n+            // Skip the problematic lead ID\n+            if (activeItem.id.toString() === '1741295054950') {\n+              console.warn(`Skipping update for known problematic lead ID: ${activeItem.id}`);\n+              return;\n+            }\n+            \n             // Get items in the target column to calculate new position\n             const itemsInTargetColumn = items\n               .filter(item => item.status === overColumn && item.id > 0)\n               .sort((a, b) => a.position - b.position);\n"
                },
                {
                    "date": 1741890544644,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -172,8 +172,23 @@\n   useEffect(() => {\n     fetchLeads();\n   }, []);\n \n+  // Filter out any problematic leads from the UI\n+  useEffect(() => {\n+    if (items.length > 0) {\n+      const problematicLeadIds = ['1741295054950']; // Add any other problematic IDs here\n+      const filteredItems = items.filter(item => \n+        !problematicLeadIds.includes(item.id.toString())\n+      );\n+      \n+      if (filteredItems.length < items.length) {\n+        console.log(`Filtered out ${items.length - filteredItems.length} problematic leads from UI`);\n+        setItems(filteredItems);\n+      }\n+    }\n+  }, [items]);\n+\n   const sensors = useSensors(\n     useSensor(PointerSensor),\n     useSensor(KeyboardSensor, {\n       coordinateGetter: sortableKeyboardCoordinates,\n"
                },
                {
                    "date": 1741890654661,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -30,12 +30,13 @@\n   SlidersHorizontal,\n   TrendingUp,\n   Users,\n   DollarSign,\n-  BarChart\n+  BarChart,\n+  AlertTriangle\n } from 'lucide-react';\n import { Lead } from '@/data/leads';\n-import { getLeads, updateLead, updateLeadPositions } from '@/lib/services/leads-service';\n+import { getLeads, updateLead, updateLeadPositions, identifyProblematicLeads } from '@/lib/services/leads-service';\n import { formatCurrency } from '@/lib/utils';\n import { \n   collection, \n } from 'firebase/firestore';\n@@ -65,8 +66,10 @@\n   const [activeId, setActiveId] = useState<string | null>(null);\n   const [activeColumnId, setActiveColumnId] = useState<string | null>(null);\n   const [loading, setLoading] = useState(true);\n   const [error, setError] = useState<string | null>(null);\n+  const [isScanning, setIsScanning] = useState(false);\n+  const [problematicLeadIds, setProblematicLeadIds] = useState<string[]>([]);\n \n   // Function to fetch leads data\n   async function fetchLeads() {\n     try {\n@@ -334,8 +337,33 @@\n     setActiveId(null);\n     setActiveColumnId(null);\n   };\n \n+  // Function to identify problematic leads\n+  const handleScanForProblematicLeads = async () => {\n+    try {\n+      setIsScanning(true);\n+      const problematicIds = await identifyProblematicLeads();\n+      setProblematicLeadIds(problematicIds);\n+      \n+      // Filter out problematic leads from the UI\n+      if (problematicIds.length > 0) {\n+        const filteredItems = items.filter(item => \n+          !problematicIds.includes(item.id.toString())\n+        );\n+        \n+        if (filteredItems.length < items.length) {\n+          console.log(`Filtered out ${items.length - filteredItems.length} problematic leads from UI`);\n+          setItems(filteredItems);\n+        }\n+      }\n+    } catch (error) {\n+      console.error('Error scanning for problematic leads:', error);\n+    } finally {\n+      setIsScanning(false);\n+    }\n+  };\n+\n   if (loading) {\n     return <div className=\"py-10 text-center\">Loading leads...</div>;\n   }\n \n@@ -404,8 +432,22 @@\n           <Button variant=\"outline\" className=\"border-slate-200\">\n             <SlidersHorizontal className=\"w-4 h-4 mr-2\" />\n             Filters\n           </Button>\n+          <Button \n+            variant=\"outline\" \n+            className=\"border-amber-200 text-amber-700\"\n+            onClick={handleScanForProblematicLeads}\n+            disabled={isScanning}\n+          >\n+            <AlertTriangle className=\"w-4 h-4 mr-2\" />\n+            {isScanning ? 'Scanning...' : 'Scan for Issues'}\n+          </Button>\n+          {problematicLeadIds.length > 0 && (\n+            <span className=\"text-amber-700 text-sm\">\n+              Found {problematicLeadIds.length} problematic leads (filtered from view)\n+            </span>\n+          )}\n         </div>\n       </div>\n \n       <div className=\"relative overflow-x-auto pb-4\">\n"
                },
                {
                    "date": 1741892168833,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,538 @@\n+\"use client\";\n+\n+import { useState, useEffect } from 'react';\n+import { motion } from 'framer-motion';\n+import {\n+  DndContext,\n+  DragOverlay,\n+  closestCorners,\n+  KeyboardSensor,\n+  PointerSensor,\n+  useSensor,\n+  useSensors,\n+  DragStartEvent,\n+  DragEndEvent,\n+} from '@dnd-kit/core';\n+import {\n+  arrayMove,\n+  SortableContext,\n+  sortableKeyboardCoordinates,\n+  horizontalListSortingStrategy,\n+  verticalListSortingStrategy,\n+} from '@dnd-kit/sortable';\n+import { KanbanColumn } from './kanban-column';\n+import { KanbanCard } from './kanban-card';\n+import { Button } from '@/components/ui/button';\n+import { Card } from '@/components/ui/card';\n+import { \n+  Plus, \n+  Search, \n+  SlidersHorizontal,\n+  TrendingUp,\n+  Users,\n+  DollarSign,\n+  BarChart,\n+  AlertTriangle\n+} from 'lucide-react';\n+import { Lead } from '@/data/leads';\n+import { getLeads, updateLead, updateLeadPositions, identifyProblematicLeads } from '@/lib/services/leads-service';\n+import { formatCurrency } from '@/lib/utils';\n+import { \n+  collection, \n+} from 'firebase/firestore';\n+import { db } from '@/lib/firebase';\n+import { AddLeadDialog } from '@/components/leads/add-lead-dialog';\n+\n+// Professional color scheme using muted, corporate tones\n+const initialColumns = [\n+  { id: 'New', title: 'New Leads', color: 'from-slate-600 to-slate-500' },\n+  { id: 'Contacted', title: 'Contacted', color: 'from-blue-700 to-blue-600' },\n+  { id: 'Qualified', title: 'Qualified', color: 'from-emerald-700 to-emerald-600' },\n+  { id: 'Negotiating', title: 'Negotiating', color: 'from-indigo-700 to-indigo-600' },\n+];\n+\n+const availableColors = [\n+  { id: 'slate', gradient: 'from-slate-600 to-slate-500' },\n+  { id: 'blue', gradient: 'from-blue-700 to-blue-600' },\n+  { id: 'emerald', gradient: 'from-emerald-700 to-emerald-600' },\n+  { id: 'indigo', gradient: 'from-indigo-700 to-indigo-600' },\n+  { id: 'zinc', gradient: 'from-zinc-600 to-zinc-500' },\n+  { id: 'gray', gradient: 'from-gray-600 to-gray-500' },\n+];\n+\n+export function LeadsKanban({ searchTerm }: { searchTerm: string }) {\n+  const [items, setItems] = useState<Lead[]>([]);\n+  const [columns, setColumns] = useState(initialColumns);\n+  const [activeId, setActiveId] = useState<string | null>(null);\n+  const [activeColumnId, setActiveColumnId] = useState<string | null>(null);\n+  const [loading, setLoading] = useState(true);\n+  const [error, setError] = useState<string | null>(null);\n+  const [isScanning, setIsScanning] = useState(false);\n+  const [problematicLeadIds, setProblematicLeadIds] = useState<string[]>([]);\n+\n+  // Function to fetch leads data\n+  async function fetchLeads() {\n+    try {\n+      setLoading(true);\n+      const data = await getLeads();\n+      \n+      // Filter out leads with invalid IDs (negative numbers)\n+      const validLeads = data.filter(lead => lead.id > 0);\n+      \n+      if (validLeads.length < data.length) {\n+        console.warn(`Filtered out ${data.length - validLeads.length} leads with invalid IDs`);\n+      }\n+      \n+      // Check if positions need to be initialized\n+      const needsPositionInit = validLeads.some(lead => !lead.position);\n+      \n+      if (needsPositionInit) {\n+        console.log('Initializing positions for leads...');\n+        \n+        // Group leads by status\n+        const leadsByStatus = validLeads.reduce((acc, lead) => {\n+          if (!acc[lead.status]) {\n+            acc[lead.status] = [];\n+          }\n+          acc[lead.status].push(lead);\n+          return acc;\n+        }, {} as Record<string, Lead[]>);\n+        \n+        // Generate position updates for each status group\n+        const positionUpdates: { id: string; position: number }[] = [];\n+        \n+        for (const status in leadsByStatus) {\n+          const statusLeads = leadsByStatus[status];\n+          // Sort by lastActivity date as a reasonable default order\n+          statusLeads.sort((a, b) => \n+            new Date(b.lastActivity).getTime() - new Date(a.lastActivity).getTime()\n+          );\n+          \n+          // Assign positions\n+          statusLeads.forEach((lead, index) => {\n+            if (!lead.position) {\n+              // Ensure lead.id is valid before converting to string\n+              if (lead.id && !isNaN(lead.id) && lead.id > 0) {\n+                // Skip the problematic lead ID if it matches the one in the error\n+                if (lead.id.toString() === '1741295054950') {\n+                  console.warn(`Skipping known problematic lead ID: ${lead.id}`);\n+                  return;\n+                }\n+                \n+                positionUpdates.push({\n+                  id: lead.id.toString(),\n+                  position: index + 1\n+                });\n+              } else {\n+                console.warn(`Skipping position update for lead with invalid ID: ${lead.id}`);\n+              }\n+            }\n+          });\n+        }\n+        \n+        // Update positions in database\n+        if (positionUpdates.length > 0) {\n+          try {\n+            await updateLeadPositions(positionUpdates);\n+            \n+            // Update local state\n+            const updatedData = validLeads.map(lead => {\n+              const update = positionUpdates.find(u => u.id === lead.id.toString());\n+              return update ? { ...lead, position: update.position } : lead;\n+            });\n+            \n+            setItems(updatedData);\n+          } catch (updateError) {\n+            console.error('Error updating lead positions:', updateError);\n+            // Continue with the existing data even if position updates fail\n+            setItems(validLeads);\n+          }\n+        } else {\n+          setItems(validLeads);\n+        }\n+      } else {\n+        setItems(validLeads);\n+      }\n+      \n+      setError(null);\n+    } catch (err) {\n+      console.error('Error fetching leads:', err);\n+      const errorMessage = err instanceof Error ? \n+        `Failed to load leads: ${err.message}` : \n+        'Failed to load leads. Please try again later.';\n+      setError(errorMessage);\n+    } finally {\n+      setLoading(false);\n+    }\n+  }\n+\n+  // Function to handle when a new lead is added\n+  const handleLeadAdded = () => {\n+    // Refetch leads\n+    fetchLeads();\n+  };\n+\n+  useEffect(() => {\n+    fetchLeads();\n+  }, []);\n+\n+  // Filter out any problematic leads from the UI\n+  useEffect(() => {\n+    if (items.length > 0) {\n+      const problematicLeadIds = ['1741295054950']; // Add any other problematic IDs here\n+      const filteredItems = items.filter(item => \n+        !problematicLeadIds.includes(item.id.toString())\n+      );\n+      \n+      if (filteredItems.length < items.length) {\n+        console.log(`Filtered out ${items.length - filteredItems.length} problematic leads from UI`);\n+        setItems(filteredItems);\n+      }\n+    }\n+  }, [items]);\n+\n+  const sensors = useSensors(\n+    useSensor(PointerSensor),\n+    useSensor(KeyboardSensor, {\n+      coordinateGetter: sortableKeyboardCoordinates,\n+    })\n+  );\n+\n+  // Calculate summary statistics\n+  const totalLeads = items.length;\n+  const qualifiedLeads = items.filter(item => item.status === 'Qualified').length;\n+  const totalValue = items.reduce((sum, item) => {\n+    const numericValue = item.value.replace(/[^0-9]/g, '');\n+    return sum + (numericValue ? parseInt(numericValue) : 0);\n+  }, 0);\n+  const conversionRate = totalLeads > 0 ? Math.round((qualifiedLeads / totalLeads) * 100) : 0;\n+\n+  const handleDragStart = (event: DragStartEvent) => {\n+    const { active } = event;\n+    if (active.data.current?.type === 'column') {\n+      setActiveColumnId(active.id as string);\n+    } else {\n+      setActiveId(active.id as string);\n+    }\n+  };\n+\n+  const handleDragEnd = async (event: DragEndEvent) => {\n+    const { active, over } = event;\n+\n+    if (!over) return;\n+\n+    if (active.data.current?.type === 'column') {\n+      const oldIndex = columns.findIndex(col => col.id === active.id);\n+      const newIndex = columns.findIndex(col => col.id === over.id);\n+\n+      if (oldIndex !== newIndex) {\n+        setColumns(arrayMove(columns, oldIndex, newIndex));\n+      }\n+    } else {\n+      const activeItem = items.find(item => item.id.toString() === active.id);\n+      const overColumn = over.data.current?.type === 'column' ? over.id : over.data.current?.columnId;\n+\n+      if (activeItem && overColumn) {\n+        try {\n+          // Moving between columns\n+          if (activeItem.status !== overColumn) {\n+            // Validate the lead ID before updating\n+            if (!activeItem.id || isNaN(activeItem.id) || activeItem.id <= 0) {\n+              console.error(`Cannot update lead with invalid ID: ${activeItem.id}`);\n+              return;\n+            }\n+            \n+            // Skip the problematic lead ID\n+            if (activeItem.id.toString() === '1741295054950') {\n+              console.warn(`Skipping update for known problematic lead ID: ${activeItem.id}`);\n+              return;\n+            }\n+            \n+            // Get items in the target column to calculate new position\n+            const itemsInTargetColumn = items\n+              .filter(item => item.status === overColumn && item.id > 0)\n+              .sort((a, b) => a.position - b.position);\n+            \n+            // Calculate new position (add at the end of the target column)\n+            const newPosition = itemsInTargetColumn.length > 0\n+              ? Math.max(...itemsInTargetColumn.map(item => item.position)) + 1\n+              : 1;\n+            \n+            try {\n+              // Update in Firestore\n+              await updateLead(activeItem.id.toString(), { \n+                status: overColumn as string,\n+                position: newPosition\n+              });\n+              \n+              // Update local state\n+              setItems(items.map(item => \n+                item.id.toString() === active.id\n+                  ? { ...item, status: overColumn as string, position: newPosition }\n+                  : item\n+              ));\n+            } catch (updateError) {\n+              console.error('Error updating lead status:', updateError);\n+              // Refresh the data to ensure UI is in sync with database\n+              fetchLeads();\n+            }\n+          } \n+          // Reordering within the same column\n+          else if (over.data.current?.type === 'item') {\n+            const itemsInSameColumn = items.filter(item => \n+              item.status === activeItem.status && \n+              item.id > 0 // Only include items with valid positive IDs\n+            );\n+            \n+            const activeIndex = itemsInSameColumn\n+              .sort((a, b) => a.position - b.position)\n+              .findIndex(item => item.id.toString() === active.id);\n+            \n+            const overIndex = itemsInSameColumn\n+              .sort((a, b) => a.position - b.position)\n+              .findIndex(item => item.id.toString() === over.id);\n+            \n+            if (activeIndex !== overIndex && activeIndex !== -1 && overIndex !== -1) {\n+              // Get all items in the column, sorted by position\n+              const itemsInColumn = itemsInSameColumn.sort((a, b) => a.position - b.position);\n+              \n+              // Reorder items\n+              const reorderedItems = arrayMove(itemsInColumn, activeIndex, overIndex);\n+              \n+              // Update positions for all items in the column to match their new order\n+              const updates = reorderedItems\n+                .filter(item => item.id && !isNaN(item.id)) // Only include items with valid IDs\n+                .filter(item => item.id.toString() !== '1741295054950') // Filter out the problematic lead ID\n+                .map((item, index) => ({\n+                  id: item.id.toString(),\n+                  position: index + 1\n+                }));\n+              \n+              // Use batch update for better performance\n+              try {\n+                // First update local state optimistically for a responsive UI\n+                const updatedItems = [...items];\n+                updates.forEach(update => {\n+                  const itemIndex = updatedItems.findIndex(item => item.id.toString() === update.id);\n+                  if (itemIndex !== -1) {\n+                    updatedItems[itemIndex] = {\n+                      ...updatedItems[itemIndex],\n+                      position: update.position\n+                    };\n+                  }\n+                });\n+                setItems(updatedItems);\n+                \n+                // Then update in Firestore\n+                await updateLeadPositions(updates);\n+              } catch (err) {\n+                console.error('Error batch updating lead positions:', err);\n+                // Don't update the UI state if the database update fails\n+                // This will cause the UI to revert to the previous state\n+                fetchLeads(); // Refresh the data to ensure UI is in sync with database\n+              }\n+            }\n+          }\n+        } catch (err) {\n+          console.error('Error updating lead position:', err);\n+          // You might want to show a toast notification here\n+          // Refresh the data to ensure UI is in sync with database\n+          fetchLeads();\n+        }\n+      }\n+    }\n+\n+    setActiveId(null);\n+    setActiveColumnId(null);\n+  };\n+\n+  // Function to identify problematic leads\n+  const handleScanForProblematicLeads = async () => {\n+    try {\n+      setIsScanning(true);\n+      const problematicIds = await identifyProblematicLeads();\n+      setProblematicLeadIds(problematicIds);\n+      \n+      // Filter out problematic leads from the UI\n+      if (problematicIds.length > 0) {\n+        const filteredItems = items.filter(item => \n+          !problematicIds.includes(item.id.toString())\n+        );\n+        \n+        if (filteredItems.length < items.length) {\n+          console.log(`Filtered out ${items.length - filteredItems.length} problematic leads from UI`);\n+          setItems(filteredItems);\n+        }\n+      }\n+    } catch (error) {\n+      console.error('Error scanning for problematic leads:', error);\n+    } finally {\n+      setIsScanning(false);\n+    }\n+  };\n+\n+  if (loading) {\n+    return <div className=\"py-10 text-center\">Loading leads...</div>;\n+  }\n+\n+  if (error) {\n+    return <div className=\"py-10 text-center text-red-500\">{error}</div>;\n+  }\n+\n+  return (\n+    <DndContext\n+      sensors={sensors}\n+      collisionDetection={closestCorners}\n+      onDragStart={handleDragStart}\n+      onDragEnd={handleDragEnd}\n+    >\n+      {/* Summary Statistics */}\n+      <div className=\"grid grid-cols-4 gap-4 mb-8\">\n+        <Card className=\"p-4 border-l-4 border-l-blue-600\">\n+          <div className=\"flex items-center justify-between\">\n+            <div>\n+              <p className=\"text-sm font-medium text-muted-foreground\">Total Leads</p>\n+              <p className=\"text-2xl font-bold\">{totalLeads}</p>\n+            </div>\n+            <Users className=\"w-8 h-8 text-blue-600\" />\n+          </div>\n+        </Card>\n+        \n+        <Card className=\"p-4 border-l-4 border-l-emerald-600\">\n+          <div className=\"flex items-center justify-between\">\n+            <div>\n+              <p className=\"text-sm font-medium text-muted-foreground\">Conversion Rate</p>\n+              <p className=\"text-2xl font-bold\">{conversionRate}%</p>\n+            </div>\n+            <BarChart className=\"w-8 h-8 text-emerald-600\" />\n+          </div>\n+        </Card>\n+        \n+        <Card className=\"p-4 border-l-4 border-l-indigo-600\">\n+          <div className=\"flex items-center justify-between\">\n+            <div>\n+              <p className=\"text-sm font-medium text-muted-foreground\">Pipeline Value</p>\n+              <p className=\"text-2xl font-bold\">{formatCurrency(totalValue)}</p>\n+            </div>\n+            <DollarSign className=\"w-8 h-8 text-indigo-600\" />\n+          </div>\n+        </Card>\n+        \n+        <Card className=\"p-4 border-l-4 border-l-slate-600\">\n+          <div className=\"flex items-center justify-between\">\n+            <div>\n+              <p className=\"text-sm font-medium text-muted-foreground\">Qualified Leads</p>\n+              <p className=\"text-2xl font-bold\">{qualifiedLeads}</p>\n+            </div>\n+            <TrendingUp className=\"w-8 h-8 text-slate-600\" />\n+          </div>\n+        </Card>\n+      </div>\n+\n+      <div className=\"mb-4 flex justify-between items-center\">\n+        <div className=\"flex items-center space-x-2\">\n+          <AddLeadDialog onLeadAdded={handleLeadAdded}>\n+            <Button className=\"bg-blue-600 hover:bg-blue-700\">\n+              <Plus className=\"w-4 h-4 mr-2\" />\n+              Add Lead\n+            </Button>\n+          </AddLeadDialog>\n+          <Button variant=\"outline\" className=\"border-slate-200\">\n+            <SlidersHorizontal className=\"w-4 h-4 mr-2\" />\n+            Filters\n+          </Button>\n+          <Button \n+            variant=\"outline\" \n+            className=\"border-amber-200 text-amber-700\"\n+            onClick={handleScanForProblematicLeads}\n+            disabled={isScanning}\n+          >\n+            <AlertTriangle className=\"w-4 h-4 mr-2\" />\n+            {isScanning ? 'Scanning...' : 'Scan for Issues'}\n+          </Button>\n+          {problematicLeadIds.length > 0 && (\n+            <span className=\"text-amber-700 text-sm\">\n+              Found {problematicLeadIds.length} problematic leads (filtered from view)\n+            </span>\n+          )}\n+        </div>\n+      </div>\n+\n+      <div className=\"relative overflow-x-auto pb-4\">\n+        <SortableContext\n+          items={columns.map(col => col.id)}\n+          strategy={horizontalListSortingStrategy}\n+        >\n+          <div className=\"flex space-x-6 min-w-full\" style={{ width: `${columns.length * 320}px` }}>\n+            {columns.map((column) => (\n+              <div key={column.id} className=\"w-[300px] flex-shrink-0\">\n+                <KanbanColumn\n+                  id={column.id}\n+                  title={column.title}\n+                  color={column.color}\n+                  onTitleChange={(newTitle) => {\n+                    setColumns(columns.map(col =>\n+                      col.id === column.id ? { ...col, title: newTitle } : col\n+                    ));\n+                  }}\n+                  onColorChange={(newColor) => {\n+                    setColumns(columns.map(col =>\n+                      col.id === column.id ? { ...col, color: newColor } : col\n+                    ));\n+                  }}\n+                  onDelete={() => {\n+                    setColumns(columns.filter(col => col.id !== column.id));\n+                    // Move leads in deleted column to New\n+                    setItems(items.map(item =>\n+                      item.status === column.id\n+                        ? { ...item, status: 'New' }\n+                        : item\n+                    ));\n+                  }}\n+                  availableColors={availableColors}\n+                  isDeletable={column.id !== 'New'}\n+                >\n+                  <SortableContext\n+                    items={items\n+                      .filter(item => item.status === column.id)\n+                      .map(item => item.id.toString())}\n+                    strategy={verticalListSortingStrategy}\n+                  >\n+                    {items\n+                      .filter(item => \n+                        item.status === column.id &&\n+                        (item.name.toLowerCase().includes(searchTerm.toLowerCase()) ||\n+                         item.company.toLowerCase().includes(searchTerm.toLowerCase()))\n+                      )\n+                      .sort((a, b) => a.position - b.position)\n+                      .map((item) => (\n+                        <KanbanCard\n+                          key={item.id}\n+                          id={item.id.toString()}\n+                          lead={item}\n+                          columnColor={column.color}\n+                        />\n+                      ))\n+                    }\n+                  </SortableContext>\n+                </KanbanColumn>\n+              </div>\n+            ))}\n+          </div>\n+        </SortableContext>\n+      </div>\n+\n+      <DragOverlay>\n+        {activeId ? (\n+          <KanbanCard\n+            id={activeId}\n+            lead={items.find(item => item.id.toString() === activeId)!}\n+            columnColor={columns.find(col => col.id === items.find(item => \n+              item.id.toString() === activeId\n+            )?.status)?.color || ''}\n+          />\n+        ) : null}\n+      </DragOverlay>\n+    </DndContext>\n+  );\n+}\n\\ No newline at end of file\n"
                },
                {
                    "date": 1741892189189,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -109,9 +109,9 @@\n           );\n           \n           // Assign positions\n           statusLeads.forEach((lead, index) => {\n-            if (!lead.position) {\n+            if (!lead.position || isNaN(lead.position)) {\n               // Ensure lead.id is valid before converting to string\n               if (lead.id && !isNaN(lead.id) && lead.id > 0) {\n                 // Skip the problematic lead ID if it matches the one in the error\n                 if (lead.id.toString() === '1741295054950') {\n@@ -150,9 +150,16 @@\n         } else {\n           setItems(validLeads);\n         }\n       } else {\n-        setItems(validLeads);\n+        // Ensure all leads have a valid position\n+        const leadsWithValidPositions = validLeads.map(lead => {\n+          if (!lead.position || isNaN(lead.position)) {\n+            return { ...lead, position: 999 }; // Default position for leads without one\n+          }\n+          return lead;\n+        });\n+        setItems(leadsWithValidPositions);\n       }\n       \n       setError(null);\n     } catch (err) {\n@@ -534,535 +541,5 @@\n         ) : null}\n       </DragOverlay>\n     </DndContext>\n   );\n-}\n-\"use client\";\n-\n-import { useState, useEffect } from 'react';\n-import { motion } from 'framer-motion';\n-import {\n-  DndContext,\n-  DragOverlay,\n-  closestCorners,\n-  KeyboardSensor,\n-  PointerSensor,\n-  useSensor,\n-  useSensors,\n-  DragStartEvent,\n-  DragEndEvent,\n-} from '@dnd-kit/core';\n-import {\n-  arrayMove,\n-  SortableContext,\n-  sortableKeyboardCoordinates,\n-  horizontalListSortingStrategy,\n-  verticalListSortingStrategy,\n-} from '@dnd-kit/sortable';\n-import { KanbanColumn } from './kanban-column';\n-import { KanbanCard } from './kanban-card';\n-import { Button } from '@/components/ui/button';\n-import { Card } from '@/components/ui/card';\n-import { \n-  Plus, \n-  Search, \n-  SlidersHorizontal,\n-  TrendingUp,\n-  Users,\n-  DollarSign,\n-  BarChart,\n-  AlertTriangle\n-} from 'lucide-react';\n-import { Lead } from '@/data/leads';\n-import { getLeads, updateLead, updateLeadPositions, identifyProblematicLeads } from '@/lib/services/leads-service';\n-import { formatCurrency } from '@/lib/utils';\n-import { \n-  collection, \n-} from 'firebase/firestore';\n-import { db } from '@/lib/firebase';\n-import { AddLeadDialog } from '@/components/leads/add-lead-dialog';\n-\n-// Professional color scheme using muted, corporate tones\n-const initialColumns = [\n-  { id: 'New', title: 'New Leads', color: 'from-slate-600 to-slate-500' },\n-  { id: 'Contacted', title: 'Contacted', color: 'from-blue-700 to-blue-600' },\n-  { id: 'Qualified', title: 'Qualified', color: 'from-emerald-700 to-emerald-600' },\n-  { id: 'Negotiating', title: 'Negotiating', color: 'from-indigo-700 to-indigo-600' },\n-];\n-\n-const availableColors = [\n-  { id: 'slate', gradient: 'from-slate-600 to-slate-500' },\n-  { id: 'blue', gradient: 'from-blue-700 to-blue-600' },\n-  { id: 'emerald', gradient: 'from-emerald-700 to-emerald-600' },\n-  { id: 'indigo', gradient: 'from-indigo-700 to-indigo-600' },\n-  { id: 'zinc', gradient: 'from-zinc-600 to-zinc-500' },\n-  { id: 'gray', gradient: 'from-gray-600 to-gray-500' },\n-];\n-\n-export function LeadsKanban({ searchTerm }: { searchTerm: string }) {\n-  const [items, setItems] = useState<Lead[]>([]);\n-  const [columns, setColumns] = useState(initialColumns);\n-  const [activeId, setActiveId] = useState<string | null>(null);\n-  const [activeColumnId, setActiveColumnId] = useState<string | null>(null);\n-  const [loading, setLoading] = useState(true);\n-  const [error, setError] = useState<string | null>(null);\n-  const [isScanning, setIsScanning] = useState(false);\n-  const [problematicLeadIds, setProblematicLeadIds] = useState<string[]>([]);\n-\n-  // Function to fetch leads data\n-  async function fetchLeads() {\n-    try {\n-      setLoading(true);\n-      const data = await getLeads();\n-      \n-      // Filter out leads with invalid IDs (negative numbers)\n-      const validLeads = data.filter(lead => lead.id > 0);\n-      \n-      if (validLeads.length < data.length) {\n-        console.warn(`Filtered out ${data.length - validLeads.length} leads with invalid IDs`);\n-      }\n-      \n-      // Check if positions need to be initialized\n-      const needsPositionInit = validLeads.some(lead => !lead.position);\n-      \n-      if (needsPositionInit) {\n-        console.log('Initializing positions for leads...');\n-        \n-        // Group leads by status\n-        const leadsByStatus = validLeads.reduce((acc, lead) => {\n-          if (!acc[lead.status]) {\n-            acc[lead.status] = [];\n-          }\n-          acc[lead.status].push(lead);\n-          return acc;\n-        }, {} as Record<string, Lead[]>);\n-        \n-        // Generate position updates for each status group\n-        const positionUpdates: { id: string; position: number }[] = [];\n-        \n-        for (const status in leadsByStatus) {\n-          const statusLeads = leadsByStatus[status];\n-          // Sort by lastActivity date as a reasonable default order\n-          statusLeads.sort((a, b) => \n-            new Date(b.lastActivity).getTime() - new Date(a.lastActivity).getTime()\n-          );\n-          \n-          // Assign positions\n-          statusLeads.forEach((lead, index) => {\n-            if (!lead.position) {\n-              // Ensure lead.id is valid before converting to string\n-              if (lead.id && !isNaN(lead.id) && lead.id > 0) {\n-                // Skip the problematic lead ID if it matches the one in the error\n-                if (lead.id.toString() === '1741295054950') {\n-                  console.warn(`Skipping known problematic lead ID: ${lead.id}`);\n-                  return;\n-                }\n-                \n-                positionUpdates.push({\n-                  id: lead.id.toString(),\n-                  position: index + 1\n-                });\n-              } else {\n-                console.warn(`Skipping position update for lead with invalid ID: ${lead.id}`);\n-              }\n-            }\n-          });\n-        }\n-        \n-        // Update positions in database\n-        if (positionUpdates.length > 0) {\n-          try {\n-            await updateLeadPositions(positionUpdates);\n-            \n-            // Update local state\n-            const updatedData = validLeads.map(lead => {\n-              const update = positionUpdates.find(u => u.id === lead.id.toString());\n-              return update ? { ...lead, position: update.position } : lead;\n-            });\n-            \n-            setItems(updatedData);\n-          } catch (updateError) {\n-            console.error('Error updating lead positions:', updateError);\n-            // Continue with the existing data even if position updates fail\n-            setItems(validLeads);\n-          }\n-        } else {\n-          setItems(validLeads);\n-        }\n-      } else {\n-        setItems(validLeads);\n-      }\n-      \n-      setError(null);\n-    } catch (err) {\n-      console.error('Error fetching leads:', err);\n-      const errorMessage = err instanceof Error ? \n-        `Failed to load leads: ${err.message}` : \n-        'Failed to load leads. Please try again later.';\n-      setError(errorMessage);\n-    } finally {\n-      setLoading(false);\n-    }\n-  }\n-\n-  // Function to handle when a new lead is added\n-  const handleLeadAdded = () => {\n-    // Refetch leads\n-    fetchLeads();\n-  };\n-\n-  useEffect(() => {\n-    fetchLeads();\n-  }, []);\n-\n-  // Filter out any problematic leads from the UI\n-  useEffect(() => {\n-    if (items.length > 0) {\n-      const problematicLeadIds = ['1741295054950']; // Add any other problematic IDs here\n-      const filteredItems = items.filter(item => \n-        !problematicLeadIds.includes(item.id.toString())\n-      );\n-      \n-      if (filteredItems.length < items.length) {\n-        console.log(`Filtered out ${items.length - filteredItems.length} problematic leads from UI`);\n-        setItems(filteredItems);\n-      }\n-    }\n-  }, [items]);\n-\n-  const sensors = useSensors(\n-    useSensor(PointerSensor),\n-    useSensor(KeyboardSensor, {\n-      coordinateGetter: sortableKeyboardCoordinates,\n-    })\n-  );\n-\n-  // Calculate summary statistics\n-  const totalLeads = items.length;\n-  const qualifiedLeads = items.filter(item => item.status === 'Qualified').length;\n-  const totalValue = items.reduce((sum, item) => {\n-    const numericValue = item.value.replace(/[^0-9]/g, '');\n-    return sum + (numericValue ? parseInt(numericValue) : 0);\n-  }, 0);\n-  const conversionRate = totalLeads > 0 ? Math.round((qualifiedLeads / totalLeads) * 100) : 0;\n-\n-  const handleDragStart = (event: DragStartEvent) => {\n-    const { active } = event;\n-    if (active.data.current?.type === 'column') {\n-      setActiveColumnId(active.id as string);\n-    } else {\n-      setActiveId(active.id as string);\n-    }\n-  };\n-\n-  const handleDragEnd = async (event: DragEndEvent) => {\n-    const { active, over } = event;\n-\n-    if (!over) return;\n-\n-    if (active.data.current?.type === 'column') {\n-      const oldIndex = columns.findIndex(col => col.id === active.id);\n-      const newIndex = columns.findIndex(col => col.id === over.id);\n-\n-      if (oldIndex !== newIndex) {\n-        setColumns(arrayMove(columns, oldIndex, newIndex));\n-      }\n-    } else {\n-      const activeItem = items.find(item => item.id.toString() === active.id);\n-      const overColumn = over.data.current?.type === 'column' ? over.id : over.data.current?.columnId;\n-\n-      if (activeItem && overColumn) {\n-        try {\n-          // Moving between columns\n-          if (activeItem.status !== overColumn) {\n-            // Validate the lead ID before updating\n-            if (!activeItem.id || isNaN(activeItem.id) || activeItem.id <= 0) {\n-              console.error(`Cannot update lead with invalid ID: ${activeItem.id}`);\n-              return;\n-            }\n-            \n-            // Skip the problematic lead ID\n-            if (activeItem.id.toString() === '1741295054950') {\n-              console.warn(`Skipping update for known problematic lead ID: ${activeItem.id}`);\n-              return;\n-            }\n-            \n-            // Get items in the target column to calculate new position\n-            const itemsInTargetColumn = items\n-              .filter(item => item.status === overColumn && item.id > 0)\n-              .sort((a, b) => a.position - b.position);\n-            \n-            // Calculate new position (add at the end of the target column)\n-            const newPosition = itemsInTargetColumn.length > 0\n-              ? Math.max(...itemsInTargetColumn.map(item => item.position)) + 1\n-              : 1;\n-            \n-            try {\n-              // Update in Firestore\n-              await updateLead(activeItem.id.toString(), { \n-                status: overColumn as string,\n-                position: newPosition\n-              });\n-              \n-              // Update local state\n-              setItems(items.map(item => \n-                item.id.toString() === active.id\n-                  ? { ...item, status: overColumn as string, position: newPosition }\n-                  : item\n-              ));\n-            } catch (updateError) {\n-              console.error('Error updating lead status:', updateError);\n-              // Refresh the data to ensure UI is in sync with database\n-              fetchLeads();\n-            }\n-          } \n-          // Reordering within the same column\n-          else if (over.data.current?.type === 'item') {\n-            const itemsInSameColumn = items.filter(item => \n-              item.status === activeItem.status && \n-              item.id > 0 // Only include items with valid positive IDs\n-            );\n-            \n-            const activeIndex = itemsInSameColumn\n-              .sort((a, b) => a.position - b.position)\n-              .findIndex(item => item.id.toString() === active.id);\n-            \n-            const overIndex = itemsInSameColumn\n-              .sort((a, b) => a.position - b.position)\n-              .findIndex(item => item.id.toString() === over.id);\n-            \n-            if (activeIndex !== overIndex && activeIndex !== -1 && overIndex !== -1) {\n-              // Get all items in the column, sorted by position\n-              const itemsInColumn = itemsInSameColumn.sort((a, b) => a.position - b.position);\n-              \n-              // Reorder items\n-              const reorderedItems = arrayMove(itemsInColumn, activeIndex, overIndex);\n-              \n-              // Update positions for all items in the column to match their new order\n-              const updates = reorderedItems\n-                .filter(item => item.id && !isNaN(item.id)) // Only include items with valid IDs\n-                .filter(item => item.id.toString() !== '1741295054950') // Filter out the problematic lead ID\n-                .map((item, index) => ({\n-                  id: item.id.toString(),\n-                  position: index + 1\n-                }));\n-              \n-              // Use batch update for better performance\n-              try {\n-                await updateLeadPositions(updates);\n-                \n-                // Update local state for all affected items\n-                setItems(items.map(item => {\n-                  const update = updates.find(u => u.id === item.id.toString());\n-                  return update \n-                    ? { ...item, position: update.position }\n-                    : item;\n-                }));\n-              } catch (err) {\n-                console.error('Error batch updating lead positions:', err);\n-                // Don't update the UI state if the database update fails\n-                // This will cause the UI to revert to the previous state\n-                fetchLeads(); // Refresh the data to ensure UI is in sync with database\n-              }\n-            }\n-          }\n-        } catch (err) {\n-          console.error('Error updating lead position:', err);\n-          // You might want to show a toast notification here\n-        }\n-      }\n-    }\n-\n-    setActiveId(null);\n-    setActiveColumnId(null);\n-  };\n-\n-  // Function to identify problematic leads\n-  const handleScanForProblematicLeads = async () => {\n-    try {\n-      setIsScanning(true);\n-      const problematicIds = await identifyProblematicLeads();\n-      setProblematicLeadIds(problematicIds);\n-      \n-      // Filter out problematic leads from the UI\n-      if (problematicIds.length > 0) {\n-        const filteredItems = items.filter(item => \n-          !problematicIds.includes(item.id.toString())\n-        );\n-        \n-        if (filteredItems.length < items.length) {\n-          console.log(`Filtered out ${items.length - filteredItems.length} problematic leads from UI`);\n-          setItems(filteredItems);\n-        }\n-      }\n-    } catch (error) {\n-      console.error('Error scanning for problematic leads:', error);\n-    } finally {\n-      setIsScanning(false);\n-    }\n-  };\n-\n-  if (loading) {\n-    return <div className=\"py-10 text-center\">Loading leads...</div>;\n-  }\n-\n-  if (error) {\n-    return <div className=\"py-10 text-center text-red-500\">{error}</div>;\n-  }\n-\n-  return (\n-    <DndContext\n-      sensors={sensors}\n-      collisionDetection={closestCorners}\n-      onDragStart={handleDragStart}\n-      onDragEnd={handleDragEnd}\n-    >\n-      {/* Summary Statistics */}\n-      <div className=\"grid grid-cols-4 gap-4 mb-8\">\n-        <Card className=\"p-4 border-l-4 border-l-blue-600\">\n-          <div className=\"flex items-center justify-between\">\n-            <div>\n-              <p className=\"text-sm font-medium text-muted-foreground\">Total Leads</p>\n-              <p className=\"text-2xl font-bold\">{totalLeads}</p>\n-            </div>\n-            <Users className=\"w-8 h-8 text-blue-600\" />\n-          </div>\n-        </Card>\n-        \n-        <Card className=\"p-4 border-l-4 border-l-emerald-600\">\n-          <div className=\"flex items-center justify-between\">\n-            <div>\n-              <p className=\"text-sm font-medium text-muted-foreground\">Conversion Rate</p>\n-              <p className=\"text-2xl font-bold\">{conversionRate}%</p>\n-            </div>\n-            <BarChart className=\"w-8 h-8 text-emerald-600\" />\n-          </div>\n-        </Card>\n-        \n-        <Card className=\"p-4 border-l-4 border-l-indigo-600\">\n-          <div className=\"flex items-center justify-between\">\n-            <div>\n-              <p className=\"text-sm font-medium text-muted-foreground\">Pipeline Value</p>\n-              <p className=\"text-2xl font-bold\">{formatCurrency(totalValue)}</p>\n-            </div>\n-            <DollarSign className=\"w-8 h-8 text-indigo-600\" />\n-          </div>\n-        </Card>\n-        \n-        <Card className=\"p-4 border-l-4 border-l-slate-600\">\n-          <div className=\"flex items-center justify-between\">\n-            <div>\n-              <p className=\"text-sm font-medium text-muted-foreground\">Qualified Leads</p>\n-              <p className=\"text-2xl font-bold\">{qualifiedLeads}</p>\n-            </div>\n-            <TrendingUp className=\"w-8 h-8 text-slate-600\" />\n-          </div>\n-        </Card>\n-      </div>\n-\n-      <div className=\"mb-4 flex justify-between items-center\">\n-        <div className=\"flex items-center space-x-2\">\n-          <AddLeadDialog onLeadAdded={handleLeadAdded}>\n-            <Button className=\"bg-blue-600 hover:bg-blue-700\">\n-              <Plus className=\"w-4 h-4 mr-2\" />\n-              Add Lead\n-            </Button>\n-          </AddLeadDialog>\n-          <Button variant=\"outline\" className=\"border-slate-200\">\n-            <SlidersHorizontal className=\"w-4 h-4 mr-2\" />\n-            Filters\n-          </Button>\n-          <Button \n-            variant=\"outline\" \n-            className=\"border-amber-200 text-amber-700\"\n-            onClick={handleScanForProblematicLeads}\n-            disabled={isScanning}\n-          >\n-            <AlertTriangle className=\"w-4 h-4 mr-2\" />\n-            {isScanning ? 'Scanning...' : 'Scan for Issues'}\n-          </Button>\n-          {problematicLeadIds.length > 0 && (\n-            <span className=\"text-amber-700 text-sm\">\n-              Found {problematicLeadIds.length} problematic leads (filtered from view)\n-            </span>\n-          )}\n-        </div>\n-      </div>\n-\n-      <div className=\"relative overflow-x-auto pb-4\">\n-        <SortableContext\n-          items={columns.map(col => col.id)}\n-          strategy={horizontalListSortingStrategy}\n-        >\n-          <div className=\"flex space-x-6 min-w-full\" style={{ width: `${columns.length * 320}px` }}>\n-            {columns.map((column) => (\n-              <div key={column.id} className=\"w-[300px] flex-shrink-0\">\n-                <KanbanColumn\n-                  id={column.id}\n-                  title={column.title}\n-                  color={column.color}\n-                  onTitleChange={(newTitle) => {\n-                    setColumns(columns.map(col =>\n-                      col.id === column.id ? { ...col, title: newTitle } : col\n-                    ));\n-                  }}\n-                  onColorChange={(newColor) => {\n-                    setColumns(columns.map(col =>\n-                      col.id === column.id ? { ...col, color: newColor } : col\n-                    ));\n-                  }}\n-                  onDelete={() => {\n-                    setColumns(columns.filter(col => col.id !== column.id));\n-                    // Move leads in deleted column to New\n-                    setItems(items.map(item =>\n-                      item.status === column.id\n-                        ? { ...item, status: 'New' }\n-                        : item\n-                    ));\n-                  }}\n-                  availableColors={availableColors}\n-                  isDeletable={column.id !== 'New'}\n-                >\n-                  <SortableContext\n-                    items={items\n-                      .filter(item => item.status === column.id)\n-                      .map(item => item.id.toString())}\n-                    strategy={verticalListSortingStrategy}\n-                  >\n-                    {items\n-                      .filter(item => \n-                        item.status === column.id &&\n-                        (item.name.toLowerCase().includes(searchTerm.toLowerCase()) ||\n-                         item.company.toLowerCase().includes(searchTerm.toLowerCase()))\n-                      )\n-                      .sort((a, b) => a.position - b.position)\n-                      .map((item) => (\n-                        <KanbanCard\n-                          key={item.id}\n-                          id={item.id.toString()}\n-                          lead={item}\n-                          columnColor={column.color}\n-                        />\n-                      ))\n-                    }\n-                  </SortableContext>\n-                </KanbanColumn>\n-              </div>\n-            ))}\n-          </div>\n-        </SortableContext>\n-      </div>\n-\n-      <DragOverlay>\n-        {activeId ? (\n-          <KanbanCard\n-            id={activeId}\n-            lead={items.find(item => item.id.toString() === activeId)!}\n-            columnColor={columns.find(col => col.id === items.find(item => \n-              item.id.toString() === activeId\n-            )?.status)?.color || ''}\n-          />\n-        ) : null}\n-      </DragOverlay>\n-    </DndContext>\n-  );\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1741892198570,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -510,9 +510,14 @@\n                         item.status === column.id &&\n                         (item.name.toLowerCase().includes(searchTerm.toLowerCase()) ||\n                          item.company.toLowerCase().includes(searchTerm.toLowerCase()))\n                       )\n-                      .sort((a, b) => a.position - b.position)\n+                      .sort((a, b) => {\n+                        // Ensure we have valid positions to sort by\n+                        const posA = a.position || 999;\n+                        const posB = b.position || 999;\n+                        return posA - posB;\n+                      })\n                       .map((item) => (\n                         <KanbanCard\n                           key={item.id}\n                           id={item.id.toString()}\n"
                },
                {
                    "date": 1741895006299,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -265,8 +265,10 @@\n               ? Math.max(...itemsInTargetColumn.map(item => item.position)) + 1\n               : 1;\n             \n             try {\n+              console.log(`Moving lead ${activeItem.id} from ${activeItem.status} to ${overColumn} with position ${newPosition}`);\n+              \n               // Update in Firestore\n               await updateLead(activeItem.id.toString(), { \n                 status: overColumn as string,\n                 position: newPosition\n@@ -314,8 +316,10 @@\n                   id: item.id.toString(),\n                   position: index + 1\n                 }));\n               \n+              console.log(`Reordering ${updates.length} leads within column ${activeItem.status}`);\n+              \n               // Use batch update for better performance\n               try {\n                 // First update local state optimistically for a responsive UI\n                 const updatedItems = [...items];\n@@ -341,9 +345,8 @@\n             }\n           }\n         } catch (err) {\n           console.error('Error updating lead position:', err);\n-          // You might want to show a toast notification here\n           // Refresh the data to ensure UI is in sync with database\n           fetchLeads();\n         }\n       }\n"
                },
                {
                    "date": 1741895074006,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -264,23 +264,36 @@\n             const newPosition = itemsInTargetColumn.length > 0\n               ? Math.max(...itemsInTargetColumn.map(item => item.position)) + 1\n               : 1;\n             \n+            console.log(`Moving lead ${activeItem.id} from ${activeItem.status} to ${overColumn} with position ${newPosition}`);\n+            console.log(`Current positions in target column:`, itemsInTargetColumn.map(item => ({ id: item.id, position: item.position })));\n+            \n             try {\n-              console.log(`Moving lead ${activeItem.id} from ${activeItem.status} to ${overColumn} with position ${newPosition}`);\n-              \n               // Update in Firestore\n               await updateLead(activeItem.id.toString(), { \n                 status: overColumn as string,\n                 position: newPosition\n               });\n               \n               // Update local state\n-              setItems(items.map(item => \n-                item.id.toString() === active.id\n-                  ? { ...item, status: overColumn as string, position: newPosition }\n-                  : item\n-              ));\n+              setItems(prevItems => {\n+                const updatedItems = prevItems.map(item => \n+                  item.id.toString() === active.id\n+                    ? { ...item, status: overColumn as string, position: newPosition }\n+                    : item\n+                );\n+                \n+                // Log the updated positions\n+                const updatedPositionsInColumn = updatedItems\n+                  .filter(item => item.status === overColumn)\n+                  .sort((a, b) => a.position - b.position)\n+                  .map(item => ({ id: item.id, position: item.position }));\n+                \n+                console.log(`Updated positions in ${overColumn}:`, updatedPositionsInColumn);\n+                \n+                return updatedItems;\n+              });\n             } catch (updateError) {\n               console.error('Error updating lead status:', updateError);\n               // Refresh the data to ensure UI is in sync with database\n               fetchLeads();\n@@ -304,8 +317,11 @@\n             if (activeIndex !== overIndex && activeIndex !== -1 && overIndex !== -1) {\n               // Get all items in the column, sorted by position\n               const itemsInColumn = itemsInSameColumn.sort((a, b) => a.position - b.position);\n               \n+              console.log(`Current positions in column ${activeItem.status}:`, \n+                itemsInColumn.map(item => ({ id: item.id, position: item.position })));\n+              \n               // Reorder items\n               const reorderedItems = arrayMove(itemsInColumn, activeIndex, overIndex);\n               \n               // Update positions for all items in the column to match their new order\n@@ -317,23 +333,35 @@\n                   position: index + 1\n                 }));\n               \n               console.log(`Reordering ${updates.length} leads within column ${activeItem.status}`);\n+              console.log(`New positions:`, updates);\n               \n               // Use batch update for better performance\n               try {\n                 // First update local state optimistically for a responsive UI\n-                const updatedItems = [...items];\n-                updates.forEach(update => {\n-                  const itemIndex = updatedItems.findIndex(item => item.id.toString() === update.id);\n-                  if (itemIndex !== -1) {\n-                    updatedItems[itemIndex] = {\n-                      ...updatedItems[itemIndex],\n-                      position: update.position\n-                    };\n-                  }\n+                setItems(prevItems => {\n+                  const updatedItems = [...prevItems];\n+                  updates.forEach(update => {\n+                    const itemIndex = updatedItems.findIndex(item => item.id.toString() === update.id);\n+                    if (itemIndex !== -1) {\n+                      updatedItems[itemIndex] = {\n+                        ...updatedItems[itemIndex],\n+                        position: update.position\n+                      };\n+                    }\n+                  });\n+                  \n+                  // Log the updated positions\n+                  const updatedPositionsInColumn = updatedItems\n+                    .filter(item => item.status === activeItem.status)\n+                    .sort((a, b) => a.position - b.position)\n+                    .map(item => ({ id: item.id, position: item.position }));\n+                  \n+                  console.log(`Updated positions in ${activeItem.status}:`, updatedPositionsInColumn);\n+                  \n+                  return updatedItems;\n                 });\n-                setItems(updatedItems);\n                 \n                 // Then update in Firestore\n                 await updateLeadPositions(updates);\n               } catch (err) {\n"
                },
                {
                    "date": 1742493091000,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -73,20 +73,19 @@\n   // Function to fetch leads data\n   async function fetchLeads() {\n     try {\n       setLoading(true);\n-      const data = await getLeads();\n+      const leads = await getLeads();\n       \n-      // Filter out leads with invalid IDs (negative numbers)\n-      const validLeads = data.filter(lead => lead.id > 0);\n+      // Filter out any invalid leads (those with problematic IDs)\n+      const validLeads = leads.filter(lead => \n+        lead.id && !isNaN(lead.id) && lead.id > 0 && \n+        lead.id.toString() !== '1741295054950' // Skip known problematic ID\n+      );\n       \n-      if (validLeads.length < data.length) {\n-        console.warn(`Filtered out ${data.length - validLeads.length} leads with invalid IDs`);\n-      }\n+      // Check if we need to initialize positions for leads\n+      const needsPositionInit = validLeads.some(lead => !lead.position || isNaN(lead.position));\n       \n-      // Check if positions need to be initialized\n-      const needsPositionInit = validLeads.some(lead => !lead.position);\n-      \n       if (needsPositionInit) {\n         console.log('Initializing positions for leads...');\n         \n         // Group leads by status\n@@ -150,15 +149,16 @@\n         } else {\n           setItems(validLeads);\n         }\n       } else {\n-        // Ensure all leads have a valid position\n+        // Ensure all leads have a valid position and sort by position\n         const leadsWithValidPositions = validLeads.map(lead => {\n           if (!lead.position || isNaN(lead.position)) {\n             return { ...lead, position: 999 }; // Default position for leads without one\n           }\n           return lead;\n         });\n+        // Sort the leads by position before setting items\n         setItems(leadsWithValidPositions);\n       }\n       \n       setError(null);\n@@ -265,65 +265,45 @@\n               ? Math.max(...itemsInTargetColumn.map(item => item.position)) + 1\n               : 1;\n             \n             console.log(`Moving lead ${activeItem.id} from ${activeItem.status} to ${overColumn} with position ${newPosition}`);\n-            console.log(`Current positions in target column:`, itemsInTargetColumn.map(item => ({ id: item.id, position: item.position })));\n             \n             try {\n-              // Update in Firestore\n+              // Update in Firestore first, then update local state on success\n               await updateLead(activeItem.id.toString(), { \n                 status: overColumn as string,\n                 position: newPosition\n               });\n               \n-              // Update local state\n+              // Update local state after successful database update\n               setItems(prevItems => {\n-                const updatedItems = prevItems.map(item => \n+                return prevItems.map(item => \n                   item.id.toString() === active.id\n                     ? { ...item, status: overColumn as string, position: newPosition }\n                     : item\n                 );\n-                \n-                // Log the updated positions\n-                const updatedPositionsInColumn = updatedItems\n-                  .filter(item => item.status === overColumn)\n-                  .sort((a, b) => a.position - b.position)\n-                  .map(item => ({ id: item.id, position: item.position }));\n-                \n-                console.log(`Updated positions in ${overColumn}:`, updatedPositionsInColumn);\n-                \n-                return updatedItems;\n               });\n             } catch (updateError) {\n               console.error('Error updating lead status:', updateError);\n               // Refresh the data to ensure UI is in sync with database\n               fetchLeads();\n             }\n-          } \n+          }\n           // Reordering within the same column\n           else if (over.data.current?.type === 'item') {\n             const itemsInSameColumn = items.filter(item => \n               item.status === activeItem.status && \n               item.id > 0 // Only include items with valid positive IDs\n             );\n             \n-            const activeIndex = itemsInSameColumn\n-              .sort((a, b) => a.position - b.position)\n-              .findIndex(item => item.id.toString() === active.id);\n+            const sortedItemsInColumn = [...itemsInSameColumn].sort((a, b) => a.position - b.position);\n             \n-            const overIndex = itemsInSameColumn\n-              .sort((a, b) => a.position - b.position)\n-              .findIndex(item => item.id.toString() === over.id);\n+            const activeIndex = sortedItemsInColumn.findIndex(item => item.id.toString() === active.id);\n+            const overIndex = sortedItemsInColumn.findIndex(item => item.id.toString() === over.id);\n             \n             if (activeIndex !== overIndex && activeIndex !== -1 && overIndex !== -1) {\n-              // Get all items in the column, sorted by position\n-              const itemsInColumn = itemsInSameColumn.sort((a, b) => a.position - b.position);\n-              \n-              console.log(`Current positions in column ${activeItem.status}:`, \n-                itemsInColumn.map(item => ({ id: item.id, position: item.position })));\n-              \n               // Reorder items\n-              const reorderedItems = arrayMove(itemsInColumn, activeIndex, overIndex);\n+              const reorderedItems = arrayMove(sortedItemsInColumn, activeIndex, overIndex);\n               \n               // Update positions for all items in the column to match their new order\n               const updates = reorderedItems\n                 .filter(item => item.id && !isNaN(item.id)) // Only include items with valid IDs\n@@ -335,11 +315,13 @@\n               \n               console.log(`Reordering ${updates.length} leads within column ${activeItem.status}`);\n               console.log(`New positions:`, updates);\n               \n-              // Use batch update for better performance\n               try {\n-                // First update local state optimistically for a responsive UI\n+                // Update in Firestore first to ensure persistence\n+                await updateLeadPositions(updates);\n+                \n+                // Then update local state after successful database update\n                 setItems(prevItems => {\n                   const updatedItems = [...prevItems];\n                   updates.forEach(update => {\n                     const itemIndex = updatedItems.findIndex(item => item.id.toString() === update.id);\n@@ -349,27 +331,14 @@\n                         position: update.position\n                       };\n                     }\n                   });\n-                  \n-                  // Log the updated positions\n-                  const updatedPositionsInColumn = updatedItems\n-                    .filter(item => item.status === activeItem.status)\n-                    .sort((a, b) => a.position - b.position)\n-                    .map(item => ({ id: item.id, position: item.position }));\n-                  \n-                  console.log(`Updated positions in ${activeItem.status}:`, updatedPositionsInColumn);\n-                  \n                   return updatedItems;\n                 });\n-                \n-                // Then update in Firestore\n-                await updateLeadPositions(updates);\n               } catch (err) {\n                 console.error('Error batch updating lead positions:', err);\n-                // Don't update the UI state if the database update fails\n-                // This will cause the UI to revert to the previous state\n-                fetchLeads(); // Refresh the data to ensure UI is in sync with database\n+                // Refresh the data to ensure UI is in sync with database\n+                fetchLeads();\n               }\n             }\n           }\n         } catch (err) {\n"
                },
                {
                    "date": 1742493143598,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -501,21 +501,27 @@\n                 >\n                   <SortableContext\n                     items={items\n                       .filter(item => item.status === column.id)\n+                      .sort((a, b) => {\n+                        // Ensure we have valid positions to sort by\n+                        const posA = a.position !== undefined && !isNaN(a.position) ? a.position : 999;\n+                        const posB = b.position !== undefined && !isNaN(b.position) ? b.position : 999;\n+                        return posA - posB;\n+                      })\n                       .map(item => item.id.toString())}\n                     strategy={verticalListSortingStrategy}\n                   >\n                     {items\n                       .filter(item => \n                         item.status === column.id &&\n                         (item.name.toLowerCase().includes(searchTerm.toLowerCase()) ||\n-                         item.company.toLowerCase().includes(searchTerm.toLowerCase()))\n+                          item.company.toLowerCase().includes(searchTerm.toLowerCase()))\n                       )\n                       .sort((a, b) => {\n                         // Ensure we have valid positions to sort by\n-                        const posA = a.position || 999;\n-                        const posB = b.position || 999;\n+                        const posA = a.position !== undefined && !isNaN(a.position) ? a.position : 999;\n+                        const posB = b.position !== undefined && !isNaN(b.position) ? b.position : 999;\n                         return posA - posB;\n                       })\n                       .map((item) => (\n                         <KanbanCard\n"
                },
                {
                    "date": 1742493226698,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,7 +1,7 @@\n \"use client\";\n \n-import { useState, useEffect } from 'react';\n+import { useState, useEffect, useRef } from 'react';\n import { motion } from 'framer-motion';\n import {\n   DndContext,\n   DragOverlay,\n@@ -68,8 +68,12 @@\n   const [loading, setLoading] = useState(true);\n   const [error, setError] = useState<string | null>(null);\n   const [isScanning, setIsScanning] = useState(false);\n   const [problematicLeadIds, setProblematicLeadIds] = useState<string[]>([]);\n+  // Add a ref to track cards that are currently being dragged\n+  const dragInProgressRef = useRef<Record<string, boolean>>({});\n+  // Add a ref to track the last successful update\n+  const lastUpdateRef = useRef<{id: string, position: number, status: string}[]>([]);\n \n   // Function to fetch leads data\n   async function fetchLeads() {\n     try {\n@@ -240,8 +244,11 @@\n       const overColumn = over.data.current?.type === 'column' ? over.id : over.data.current?.columnId;\n \n       if (activeItem && overColumn) {\n         try {\n+          // Set the drag in progress flag\n+          dragInProgressRef.current[active.id as string] = true;\n+          \n           // Moving between columns\n           if (activeItem.status !== overColumn) {\n             // Validate the lead ID before updating\n             if (!activeItem.id || isNaN(activeItem.id) || activeItem.id <= 0) {\n@@ -267,26 +274,36 @@\n             \n             console.log(`Moving lead ${activeItem.id} from ${activeItem.status} to ${overColumn} with position ${newPosition}`);\n             \n             try {\n-              // Update in Firestore first, then update local state on success\n+              // Update local state first for immediate visual feedback\n+              const updatedItems = items.map(item => \n+                item.id.toString() === active.id\n+                  ? { ...item, status: overColumn as string, position: newPosition }\n+                  : item\n+              );\n+              setItems(updatedItems);\n+              \n+              // Save the last update info\n+              lastUpdateRef.current = [\n+                ...lastUpdateRef.current.filter(item => item.id !== active.id as string),\n+                { id: active.id as string, position: newPosition, status: overColumn as string }\n+              ];\n+              \n+              // Then update in Firestore\n               await updateLead(activeItem.id.toString(), { \n                 status: overColumn as string,\n                 position: newPosition\n               });\n               \n-              // Update local state after successful database update\n-              setItems(prevItems => {\n-                return prevItems.map(item => \n-                  item.id.toString() === active.id\n-                    ? { ...item, status: overColumn as string, position: newPosition }\n-                    : item\n-                );\n-              });\n+              // Update was successful, we can remove the item from dragInProgress\n+              delete dragInProgressRef.current[active.id as string];\n             } catch (updateError) {\n               console.error('Error updating lead status:', updateError);\n               // Refresh the data to ensure UI is in sync with database\n               fetchLeads();\n+              // Clear the drag in progress flag\n+              delete dragInProgressRef.current[active.id as string];\n             }\n           }\n           // Reordering within the same column\n           else if (over.data.current?.type === 'item') {\n@@ -316,36 +333,56 @@\n               console.log(`Reordering ${updates.length} leads within column ${activeItem.status}`);\n               console.log(`New positions:`, updates);\n               \n               try {\n-                // Update in Firestore first to ensure persistence\n+                // Update local state first for immediate visual feedback\n+                const updatedItems = [...items];\n+                updates.forEach(update => {\n+                  const itemIndex = updatedItems.findIndex(item => item.id.toString() === update.id);\n+                  if (itemIndex !== -1) {\n+                    updatedItems[itemIndex] = {\n+                      ...updatedItems[itemIndex],\n+                      position: update.position\n+                    };\n+                    \n+                    // Set drag in progress for all affected cards\n+                    dragInProgressRef.current[update.id] = true;\n+                    \n+                    // Save the last update info\n+                    lastUpdateRef.current = [\n+                      ...lastUpdateRef.current.filter(item => item.id !== update.id),\n+                      { \n+                        id: update.id, \n+                        position: update.position, \n+                        status: updatedItems[itemIndex].status \n+                      }\n+                    ];\n+                  }\n+                });\n+                setItems(updatedItems);\n+                \n+                // Then update in Firestore\n                 await updateLeadPositions(updates);\n                 \n-                // Then update local state after successful database update\n-                setItems(prevItems => {\n-                  const updatedItems = [...prevItems];\n-                  updates.forEach(update => {\n-                    const itemIndex = updatedItems.findIndex(item => item.id.toString() === update.id);\n-                    if (itemIndex !== -1) {\n-                      updatedItems[itemIndex] = {\n-                        ...updatedItems[itemIndex],\n-                        position: update.position\n-                      };\n-                    }\n-                  });\n-                  return updatedItems;\n+                // Clear drag in progress flags for all updated cards\n+                updates.forEach(update => {\n+                  delete dragInProgressRef.current[update.id];\n                 });\n               } catch (err) {\n                 console.error('Error batch updating lead positions:', err);\n                 // Refresh the data to ensure UI is in sync with database\n                 fetchLeads();\n+                // Clear all drag in progress flags\n+                dragInProgressRef.current = {};\n               }\n             }\n           }\n         } catch (err) {\n           console.error('Error updating lead position:', err);\n           // Refresh the data to ensure UI is in sync with database\n           fetchLeads();\n+          // Clear all drag in progress flags\n+          dragInProgressRef.current = {};\n         }\n       }\n     }\n \n@@ -377,8 +414,37 @@\n       setIsScanning(false);\n     }\n   };\n \n+  // Add an effect to ensure data consistency when items are updated\n+  useEffect(() => {\n+    // Apply any pending updates from lastUpdateRef to the items\n+    if (lastUpdateRef.current.length > 0 && items.length > 0) {\n+      setItems(prevItems => {\n+        const updatedItems = [...prevItems];\n+        let hasChanges = false;\n+        \n+        lastUpdateRef.current.forEach(update => {\n+          const itemIndex = updatedItems.findIndex(item => item.id.toString() === update.id);\n+          if (itemIndex !== -1) {\n+            // Only update if the current position or status doesn't match what we expect\n+            if (updatedItems[itemIndex].position !== update.position || \n+                updatedItems[itemIndex].status !== update.status) {\n+              updatedItems[itemIndex] = {\n+                ...updatedItems[itemIndex],\n+                position: update.position,\n+                status: update.status\n+              };\n+              hasChanges = true;\n+            }\n+          }\n+        });\n+        \n+        return hasChanges ? updatedItems : prevItems;\n+      });\n+    }\n+  }, [items]);\n+\n   if (loading) {\n     return <div className=\"py-10 text-center\">Loading leads...</div>;\n   }\n \n"
                },
                {
                    "date": 1742493244334,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -576,18 +576,33 @@\n                       })\n                       .map(item => item.id.toString())}\n                     strategy={verticalListSortingStrategy}\n                   >\n+                    {/* Use a stable sort approach to maintain correct positions */}\n                     {items\n                       .filter(item => \n                         item.status === column.id &&\n-                        (item.name.toLowerCase().includes(searchTerm.toLowerCase()) ||\n+                        (searchTerm === '' || \n+                          item.name.toLowerCase().includes(searchTerm.toLowerCase()) ||\n                           item.company.toLowerCase().includes(searchTerm.toLowerCase()))\n                       )\n                       .sort((a, b) => {\n-                        // Ensure we have valid positions to sort by\n-                        const posA = a.position !== undefined && !isNaN(a.position) ? a.position : 999;\n-                        const posB = b.position !== undefined && !isNaN(b.position) ? b.position : 999;\n+                        // Check if this card is in the middle of a drag operation\n+                        if (dragInProgressRef.current[a.id.toString()] && !dragInProgressRef.current[b.id.toString()]) {\n+                          return -1; // Prioritize the card being dragged\n+                        }\n+                        if (!dragInProgressRef.current[a.id.toString()] && dragInProgressRef.current[b.id.toString()]) {\n+                          return 1;\n+                        }\n+                        \n+                        // Find the last position update if available\n+                        const lastUpdateA = lastUpdateRef.current.find(update => update.id === a.id.toString());\n+                        const lastUpdateB = lastUpdateRef.current.find(update => update.id === b.id.toString());\n+                        \n+                        // Use last update position if available\n+                        const posA = lastUpdateA?.position ?? (a.position !== undefined && !isNaN(a.position) ? a.position : 999);\n+                        const posB = lastUpdateB?.position ?? (b.position !== undefined && !isNaN(b.position) ? b.position : 999);\n+                        \n                         return posA - posB;\n                       })\n                       .map((item) => (\n                         <KanbanCard\n"
                },
                {
                    "date": 1742493273467,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -79,8 +79,11 @@\n     try {\n       setLoading(true);\n       const leads = await getLeads();\n       \n+      // Keep track of any pending position updates\n+      const pendingUpdates = [...lastUpdateRef.current];\n+      \n       // Filter out any invalid leads (those with problematic IDs)\n       const validLeads = leads.filter(lead => \n         lead.id && !isNaN(lead.id) && lead.id > 0 && \n         lead.id.toString() !== '1741295054950' // Skip known problematic ID\n@@ -143,16 +146,20 @@\n               const update = positionUpdates.find(u => u.id === lead.id.toString());\n               return update ? { ...lead, position: update.position } : lead;\n             });\n             \n-            setItems(updatedData);\n+            // Apply any pending updates we were tracking\n+            const finalData = applyPendingUpdates(updatedData, pendingUpdates);\n+            setItems(finalData);\n           } catch (updateError) {\n             console.error('Error updating lead positions:', updateError);\n             // Continue with the existing data even if position updates fail\n-            setItems(validLeads);\n+            const finalData = applyPendingUpdates(validLeads, pendingUpdates);\n+            setItems(finalData);\n           }\n         } else {\n-          setItems(validLeads);\n+          const finalData = applyPendingUpdates(validLeads, pendingUpdates);\n+          setItems(finalData);\n         }\n       } else {\n         // Ensure all leads have a valid position and sort by position\n         const leadsWithValidPositions = validLeads.map(lead => {\n@@ -160,10 +167,14 @@\n             return { ...lead, position: 999 }; // Default position for leads without one\n           }\n           return lead;\n         });\n+        \n+        // Apply any pending updates we were tracking\n+        const finalData = applyPendingUpdates(leadsWithValidPositions, pendingUpdates);\n+        \n         // Sort the leads by position before setting items\n-        setItems(leadsWithValidPositions);\n+        setItems(finalData);\n       }\n       \n       setError(null);\n     } catch (err) {\n@@ -176,8 +187,25 @@\n       setLoading(false);\n     }\n   }\n \n+  // Helper function to apply pending position updates\n+  function applyPendingUpdates(leads: Lead[], pendingUpdates: {id: string, position: number, status: string}[]): Lead[] {\n+    if (pendingUpdates.length === 0) return leads;\n+    \n+    return leads.map(lead => {\n+      const update = pendingUpdates.find(u => u.id === lead.id.toString());\n+      if (update) {\n+        return {\n+          ...lead,\n+          position: update.position,\n+          status: update.status\n+        };\n+      }\n+      return lead;\n+    });\n+  }\n+\n   // Function to handle when a new lead is added\n   const handleLeadAdded = () => {\n     // Refetch leads\n     fetchLeads();\n"
                },
                {
                    "date": 1742493482606,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -302,30 +302,37 @@\n             \n             console.log(`Moving lead ${activeItem.id} from ${activeItem.status} to ${overColumn} with position ${newPosition}`);\n             \n             try {\n-              // Update local state first for immediate visual feedback\n-              const updatedItems = items.map(item => \n-                item.id.toString() === active.id\n-                  ? { ...item, status: overColumn as string, position: newPosition }\n-                  : item\n-              );\n-              setItems(updatedItems);\n+              // Try to update in database first for consistent state\n+              await updateLead(activeItem.id.toString(), { \n+                status: overColumn as string,\n+                position: newPosition\n+              });\n               \n-              // Save the last update info\n+              // After database update success, update local state\n+              setItems(prevItems => {\n+                const newItems = prevItems.map(item => \n+                  item.id.toString() === active.id\n+                    ? { ...item, status: overColumn as string, position: newPosition }\n+                    : item\n+                );\n+                return newItems;\n+              });\n+              \n+              // Save the last update info for reference during renders\n               lastUpdateRef.current = [\n                 ...lastUpdateRef.current.filter(item => item.id !== active.id as string),\n                 { id: active.id as string, position: newPosition, status: overColumn as string }\n               ];\n               \n-              // Then update in Firestore\n-              await updateLead(activeItem.id.toString(), { \n-                status: overColumn as string,\n-                position: newPosition\n-              });\n+              // Update was successful, remove the item from dragInProgress\n+              delete dragInProgressRef.current[active.id as string];\n               \n-              // Update was successful, we can remove the item from dragInProgress\n-              delete dragInProgressRef.current[active.id as string];\n+              // Force a refresh after a short delay to ensure UI is in sync\n+              setTimeout(() => {\n+                fetchLeads();\n+              }, 500);\n             } catch (updateError) {\n               console.error('Error updating lead status:', updateError);\n               // Refresh the data to ensure UI is in sync with database\n               fetchLeads();\n@@ -361,41 +368,50 @@\n               console.log(`Reordering ${updates.length} leads within column ${activeItem.status}`);\n               console.log(`New positions:`, updates);\n               \n               try {\n-                // Update local state first for immediate visual feedback\n-                const updatedItems = [...items];\n+                // Mark all affected cards as in progress\n                 updates.forEach(update => {\n-                  const itemIndex = updatedItems.findIndex(item => item.id.toString() === update.id);\n-                  if (itemIndex !== -1) {\n-                    updatedItems[itemIndex] = {\n-                      ...updatedItems[itemIndex],\n-                      position: update.position\n-                    };\n-                    \n-                    // Set drag in progress for all affected cards\n-                    dragInProgressRef.current[update.id] = true;\n-                    \n-                    // Save the last update info\n-                    lastUpdateRef.current = [\n-                      ...lastUpdateRef.current.filter(item => item.id !== update.id),\n-                      { \n-                        id: update.id, \n-                        position: update.position, \n-                        status: updatedItems[itemIndex].status \n-                      }\n-                    ];\n-                  }\n+                  dragInProgressRef.current[update.id] = true;\n                 });\n-                setItems(updatedItems);\n                 \n-                // Then update in Firestore\n+                // Try database update first\n                 await updateLeadPositions(updates);\n                 \n+                // On successful database update, update the UI\n+                setItems(prevItems => {\n+                  const updatedItems = [...prevItems];\n+                  updates.forEach(update => {\n+                    const itemIndex = updatedItems.findIndex(item => item.id.toString() === update.id);\n+                    if (itemIndex !== -1) {\n+                      updatedItems[itemIndex] = {\n+                        ...updatedItems[itemIndex],\n+                        position: update.position\n+                      };\n+                      \n+                      // Update the last known position for this item\n+                      lastUpdateRef.current = [\n+                        ...lastUpdateRef.current.filter(item => item.id !== update.id),\n+                        { \n+                          id: update.id, \n+                          position: update.position, \n+                          status: updatedItems[itemIndex].status \n+                        }\n+                      ];\n+                    }\n+                  });\n+                  return updatedItems;\n+                });\n+                \n                 // Clear drag in progress flags for all updated cards\n                 updates.forEach(update => {\n                   delete dragInProgressRef.current[update.id];\n                 });\n+                \n+                // Force a refresh after a short delay to ensure UI is in sync\n+                setTimeout(() => {\n+                  fetchLeads();\n+                }, 500);\n               } catch (err) {\n                 console.error('Error batch updating lead positions:', err);\n                 // Refresh the data to ensure UI is in sync with database\n                 fetchLeads();\n@@ -661,5 +677,6 @@\n         ) : null}\n       </DragOverlay>\n     </DndContext>\n   );\n+}\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1742493488499,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -677,6 +677,5 @@\n         ) : null}\n       </DragOverlay>\n     </DndContext>\n   );\n-}\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1742493502403,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -487,8 +487,37 @@\n       });\n     }\n   }, [items]);\n \n+  // Add an effect to refresh the lead positions when the window regains focus\n+  useEffect(() => {\n+    const handleFocus = () => {\n+      console.log('Window refocused, refreshing lead positions');\n+      fetchLeads();\n+    };\n+\n+    // Add event listener\n+    window.addEventListener('focus', handleFocus);\n+    \n+    // Clean up\n+    return () => {\n+      window.removeEventListener('focus', handleFocus);\n+    };\n+  }, []);\n+\n+  // Add an effect to periodically check if we have any pending position updates\n+  useEffect(() => {\n+    // If we have pending position updates, refresh data after a delay\n+    if (lastUpdateRef.current.length > 0) {\n+      const timer = setTimeout(() => {\n+        console.log('Refreshing leads due to pending position updates');\n+        fetchLeads();\n+      }, 2000); // Check after 2 seconds\n+      \n+      return () => clearTimeout(timer);\n+    }\n+  }, [lastUpdateRef.current.length]);\n+\n   if (loading) {\n     return <div className=\"py-10 text-center\">Loading leads...</div>;\n   }\n \n"
                },
                {
                    "date": 1742493732090,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -326,16 +326,11 @@\n               ];\n               \n               // Update was successful, remove the item from dragInProgress\n               delete dragInProgressRef.current[active.id as string];\n-              \n-              // Force a refresh after a short delay to ensure UI is in sync\n-              setTimeout(() => {\n-                fetchLeads();\n-              }, 500);\n             } catch (updateError) {\n               console.error('Error updating lead status:', updateError);\n-              // Refresh the data to ensure UI is in sync with database\n+              // Only refresh on error\n               fetchLeads();\n               // Clear the drag in progress flag\n               delete dragInProgressRef.current[active.id as string];\n             }\n@@ -405,16 +400,11 @@\n                 // Clear drag in progress flags for all updated cards\n                 updates.forEach(update => {\n                   delete dragInProgressRef.current[update.id];\n                 });\n-                \n-                // Force a refresh after a short delay to ensure UI is in sync\n-                setTimeout(() => {\n-                  fetchLeads();\n-                }, 500);\n               } catch (err) {\n                 console.error('Error batch updating lead positions:', err);\n-                // Refresh the data to ensure UI is in sync with database\n+                // Only refresh on error\n                 fetchLeads();\n                 // Clear all drag in progress flags\n                 dragInProgressRef.current = {};\n               }\n"
                },
                {
                    "date": 1742493751301,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -477,13 +477,20 @@\n       });\n     }\n   }, [items]);\n \n-  // Add an effect to refresh the lead positions when the window regains focus\n+  // Modify the window focus handler to prevent too frequent refreshes\n   useEffect(() => {\n+    let lastRefreshTime = Date.now();\n+    \n     const handleFocus = () => {\n-      console.log('Window refocused, refreshing lead positions');\n-      fetchLeads();\n+      // Only refresh if it's been at least 10 seconds since last refresh\n+      const now = Date.now();\n+      if (now - lastRefreshTime > 10000) {\n+        console.log('Window refocused, refreshing lead positions');\n+        fetchLeads();\n+        lastRefreshTime = now;\n+      }\n     };\n \n     // Add event listener\n     window.addEventListener('focus', handleFocus);\n@@ -585,8 +592,15 @@\n           >\n             <AlertTriangle className=\"w-4 h-4 mr-2\" />\n             {isScanning ? 'Scanning...' : 'Scan for Issues'}\n           </Button>\n+          <Button\n+            variant=\"outline\"\n+            className=\"border-slate-200\"\n+            onClick={() => fetchLeads()}\n+          >\n+            Refresh\n+          </Button>\n           {problematicLeadIds.length > 0 && (\n             <span className=\"text-amber-700 text-sm\">\n               Found {problematicLeadIds.length} problematic leads (filtered from view)\n             </span>\n"
                },
                {
                    "date": 1742493769069,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -171,10 +171,13 @@\n         \n         // Apply any pending updates we were tracking\n         const finalData = applyPendingUpdates(leadsWithValidPositions, pendingUpdates);\n         \n-        // Sort the leads by position before setting items\n-        setItems(finalData);\n+        // Properly sort leads by column and position before setting items\n+        const sortedData = sortLeadsByPositionInColumns(finalData);\n+        \n+        // Set the items\n+        setItems(sortedData);\n       }\n       \n       setError(null);\n     } catch (err) {\n@@ -204,8 +207,41 @@\n       return lead;\n     });\n   }\n \n+  // Add a new helper function to sort leads properly by position within columns\n+  // Add this after the applyPendingUpdates function\n+\n+  // Helper function to sort leads by position within each column/status\n+  function sortLeadsByPositionInColumns(leads: Lead[]): Lead[] {\n+    // Group leads by status\n+    const leadsByStatus: Record<string, Lead[]> = {};\n+    \n+    leads.forEach(lead => {\n+      if (!leadsByStatus[lead.status]) {\n+        leadsByStatus[lead.status] = [];\n+      }\n+      leadsByStatus[lead.status].push(lead);\n+    });\n+    \n+    // Sort each group by position\n+    Object.keys(leadsByStatus).forEach(status => {\n+      leadsByStatus[status].sort((a, b) => {\n+        const posA = a.position !== undefined && !isNaN(a.position) ? a.position : 999;\n+        const posB = b.position !== undefined && !isNaN(b.position) ? b.position : 999;\n+        return posA - posB;\n+      });\n+    });\n+    \n+    // Flatten the sorted groups back into a single array\n+    const sortedLeads: Lead[] = [];\n+    Object.values(leadsByStatus).forEach(statusLeads => {\n+      sortedLeads.push(...statusLeads);\n+    });\n+    \n+    return sortedLeads;\n+  }\n+\n   // Function to handle when a new lead is added\n   const handleLeadAdded = () => {\n     // Refetch leads\n     fetchLeads();\n"
                },
                {
                    "date": 1742493789084,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -351,9 +351,10 @@\n                   item.id.toString() === active.id\n                     ? { ...item, status: overColumn as string, position: newPosition }\n                     : item\n                 );\n-                return newItems;\n+                // Sort properly to ensure consistent ordering\n+                return sortLeadsByPositionInColumns(newItems);\n               });\n               \n               // Save the last update info for reference during renders\n               lastUpdateRef.current = [\n@@ -429,9 +430,10 @@\n                         }\n                       ];\n                     }\n                   });\n-                  return updatedItems;\n+                  // Sort properly to ensure consistent ordering\n+                  return sortLeadsByPositionInColumns(updatedItems);\n                 });\n                 \n                 // Clear drag in progress flags for all updated cards\n                 updates.forEach(update => {\n"
                },
                {
                    "date": 1742493809174,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -344,8 +344,11 @@\n                 status: overColumn as string,\n                 position: newPosition\n               });\n               \n+              // Log the successful position update\n+              console.log(`Position update SUCCESS: Lead ${activeItem.id} moved to ${overColumn} with position ${newPosition}`);\n+              \n               // After database update success, update local state\n               setItems(prevItems => {\n                 const newItems = prevItems.map(item => \n                   item.id.toString() === active.id\n@@ -408,8 +411,13 @@\n                 \n                 // Try database update first\n                 await updateLeadPositions(updates);\n                 \n+                // Log successful position updates\n+                console.log(`Batch position update SUCCESS for ${updates.length} leads in ${activeItem.status}:`, \n+                  updates.map(u => `${u.id}:${u.position}`).join(', ')\n+                );\n+                \n                 // On successful database update, update the UI\n                 setItems(prevItems => {\n                   const updatedItems = [...prevItems];\n                   updates.forEach(update => {\n@@ -691,8 +699,11 @@\n                       })\n                       .map(item => item.id.toString())}\n                     strategy={verticalListSortingStrategy}\n                   >\n+                    {/* Uncomment this line to debug position values when needed */}\n+                    {/* console.log(`Column ${column.id} card positions:`, items.filter(item => item.status === column.id).map(i => `${i.id}:${i.position}`).join(', ')) */}\n+                    \n                     {/* Use a stable sort approach to maintain correct positions */}\n                     {items\n                       .filter(item => \n                         item.status === column.id &&\n"
                },
                {
                    "date": 1742493836144,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -147,19 +147,30 @@\n               return update ? { ...lead, position: update.position } : lead;\n             });\n             \n             // Apply any pending updates we were tracking\n-            const finalData = applyPendingUpdates(updatedData, pendingUpdates);\n-            setItems(finalData);\n+            const dataWithPendingUpdates = applyPendingUpdates(updatedData, pendingUpdates);\n+            \n+            // Properly sort the data by position within columns\n+            const sortedData = sortLeadsByPositionInColumns(dataWithPendingUpdates);\n+            \n+            // Set the sorted items\n+            setItems(sortedData);\n+            \n+            console.log('Position initialization complete', \n+              sortedData.map(lead => `${lead.id}:${lead.position}:${lead.status}`).join(', ')\n+            );\n           } catch (updateError) {\n             console.error('Error updating lead positions:', updateError);\n             // Continue with the existing data even if position updates fail\n             const finalData = applyPendingUpdates(validLeads, pendingUpdates);\n-            setItems(finalData);\n+            const sortedData = sortLeadsByPositionInColumns(finalData);\n+            setItems(sortedData);\n           }\n         } else {\n           const finalData = applyPendingUpdates(validLeads, pendingUpdates);\n-          setItems(finalData);\n+          const sortedData = sortLeadsByPositionInColumns(finalData);\n+          setItems(sortedData);\n         }\n       } else {\n         // Ensure all leads have a valid position and sort by position\n         const leadsWithValidPositions = validLeads.map(lead => {\n"
                },
                {
                    "date": 1742495331800,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,27 +1,13 @@\n \"use client\";\n \n-import { useState, useEffect, useRef } from 'react';\n-import { motion } from 'framer-motion';\n-import {\n-  DndContext,\n-  DragOverlay,\n-  closestCorners,\n-  KeyboardSensor,\n-  PointerSensor,\n-  useSensor,\n-  useSensors,\n-  DragStartEvent,\n-  DragEndEvent,\n-} from '@dnd-kit/core';\n-import {\n-  arrayMove,\n-  SortableContext,\n-  sortableKeyboardCoordinates,\n-  horizontalListSortingStrategy,\n-  verticalListSortingStrategy,\n-} from '@dnd-kit/sortable';\n-import { KanbanColumn } from './kanban-column';\n+import { useState, useEffect } from 'react';\n+import { \n+  DragDropContext, \n+  Droppable, \n+  Draggable, \n+  DropResult \n+} from '@hello-pangea/dnd';\n import { KanbanCard } from './kanban-card';\n import { Button } from '@/components/ui/button';\n import { Card } from '@/components/ui/card';\n import { \n@@ -36,15 +22,11 @@\n } from 'lucide-react';\n import { Lead } from '@/data/leads';\n import { getLeads, updateLead, updateLeadPositions, identifyProblematicLeads } from '@/lib/services/leads-service';\n import { formatCurrency } from '@/lib/utils';\n-import { \n-  collection, \n-} from 'firebase/firestore';\n-import { db } from '@/lib/firebase';\n-import { AddLeadDialog } from '@/components/leads/add-lead-dialog';\n+import { AddLeadDialog } from './add-lead-dialog';\n \n-// Professional color scheme using muted, corporate tones\n+// Professional color scheme\n const initialColumns = [\n   { id: 'New', title: 'New Leads', color: 'from-slate-600 to-slate-500' },\n   { id: 'Contacted', title: 'Contacted', color: 'from-blue-700 to-blue-600' },\n   { id: 'Qualified', title: 'Qualified', color: 'from-emerald-700 to-emerald-600' },\n@@ -59,716 +41,326 @@\n   { id: 'zinc', gradient: 'from-zinc-600 to-zinc-500' },\n   { id: 'gray', gradient: 'from-gray-600 to-gray-500' },\n ];\n \n-export function LeadsKanban({ searchTerm }: { searchTerm: string }) {\n+export function LeadsKanban() {\n+  const [columns, setColumns] = useState(initialColumns);\n   const [items, setItems] = useState<Lead[]>([]);\n-  const [columns, setColumns] = useState(initialColumns);\n-  const [activeId, setActiveId] = useState<string | null>(null);\n-  const [activeColumnId, setActiveColumnId] = useState<string | null>(null);\n-  const [loading, setLoading] = useState(true);\n-  const [error, setError] = useState<string | null>(null);\n-  const [isScanning, setIsScanning] = useState(false);\n-  const [problematicLeadIds, setProblematicLeadIds] = useState<string[]>([]);\n-  // Add a ref to track cards that are currently being dragged\n-  const dragInProgressRef = useRef<Record<string, boolean>>({});\n-  // Add a ref to track the last successful update\n-  const lastUpdateRef = useRef<{id: string, position: number, status: string}[]>([]);\n+  const [isLoading, setIsLoading] = useState(true);\n+  const [isAddLeadOpen, setIsAddLeadOpen] = useState(false);\n+  const [pendingUpdates, setPendingUpdates] = useState<Record<string, Partial<Lead>>>({});\n+  const [problematicLeads, setProblematicLeads] = useState<string[]>([]);\n \n-  // Function to fetch leads data\n-  async function fetchLeads() {\n-    try {\n-      setLoading(true);\n-      const leads = await getLeads();\n-      \n-      // Keep track of any pending position updates\n-      const pendingUpdates = [...lastUpdateRef.current];\n-      \n-      // Filter out any invalid leads (those with problematic IDs)\n-      const validLeads = leads.filter(lead => \n-        lead.id && !isNaN(lead.id) && lead.id > 0 && \n-        lead.id.toString() !== '1741295054950' // Skip known problematic ID\n-      );\n-      \n-      // Check if we need to initialize positions for leads\n-      const needsPositionInit = validLeads.some(lead => !lead.position || isNaN(lead.position));\n-      \n-      if (needsPositionInit) {\n-        console.log('Initializing positions for leads...');\n+  // Fetch leads on component mount\n+  useEffect(() => {\n+    const fetchLeads = async () => {\n+      setIsLoading(true);\n+      try {\n+        const fetchedLeads = await getLeads();\n+        const problemLeads = await identifyProblematicLeads(fetchedLeads);\n+        setProblematicLeads(problemLeads.map(lead => lead.id));\n         \n-        // Group leads by status\n-        const leadsByStatus = validLeads.reduce((acc, lead) => {\n-          if (!acc[lead.status]) {\n-            acc[lead.status] = [];\n-          }\n-          acc[lead.status].push(lead);\n-          return acc;\n-        }, {} as Record<string, Lead[]>);\n-        \n-        // Generate position updates for each status group\n-        const positionUpdates: { id: string; position: number }[] = [];\n-        \n-        for (const status in leadsByStatus) {\n-          const statusLeads = leadsByStatus[status];\n-          // Sort by lastActivity date as a reasonable default order\n-          statusLeads.sort((a, b) => \n-            new Date(b.lastActivity).getTime() - new Date(a.lastActivity).getTime()\n-          );\n-          \n-          // Assign positions\n-          statusLeads.forEach((lead, index) => {\n-            if (!lead.position || isNaN(lead.position)) {\n-              // Ensure lead.id is valid before converting to string\n-              if (lead.id && !isNaN(lead.id) && lead.id > 0) {\n-                // Skip the problematic lead ID if it matches the one in the error\n-                if (lead.id.toString() === '1741295054950') {\n-                  console.warn(`Skipping known problematic lead ID: ${lead.id}`);\n-                  return;\n-                }\n-                \n-                positionUpdates.push({\n-                  id: lead.id.toString(),\n-                  position: index + 1\n-                });\n-              } else {\n-                console.warn(`Skipping position update for lead with invalid ID: ${lead.id}`);\n-              }\n-            }\n-          });\n-        }\n-        \n-        // Update positions in database\n-        if (positionUpdates.length > 0) {\n-          try {\n-            await updateLeadPositions(positionUpdates);\n-            \n-            // Update local state\n-            const updatedData = validLeads.map(lead => {\n-              const update = positionUpdates.find(u => u.id === lead.id.toString());\n-              return update ? { ...lead, position: update.position } : lead;\n-            });\n-            \n-            // Apply any pending updates we were tracking\n-            const dataWithPendingUpdates = applyPendingUpdates(updatedData, pendingUpdates);\n-            \n-            // Properly sort the data by position within columns\n-            const sortedData = sortLeadsByPositionInColumns(dataWithPendingUpdates);\n-            \n-            // Set the sorted items\n-            setItems(sortedData);\n-            \n-            console.log('Position initialization complete', \n-              sortedData.map(lead => `${lead.id}:${lead.position}:${lead.status}`).join(', ')\n-            );\n-          } catch (updateError) {\n-            console.error('Error updating lead positions:', updateError);\n-            // Continue with the existing data even if position updates fail\n-            const finalData = applyPendingUpdates(validLeads, pendingUpdates);\n-            const sortedData = sortLeadsByPositionInColumns(finalData);\n-            setItems(sortedData);\n-          }\n-        } else {\n-          const finalData = applyPendingUpdates(validLeads, pendingUpdates);\n-          const sortedData = sortLeadsByPositionInColumns(finalData);\n-          setItems(sortedData);\n-        }\n-      } else {\n-        // Ensure all leads have a valid position and sort by position\n-        const leadsWithValidPositions = validLeads.map(lead => {\n-          if (!lead.position || isNaN(lead.position)) {\n-            return { ...lead, position: 999 }; // Default position for leads without one\n-          }\n-          return lead;\n-        });\n-        \n-        // Apply any pending updates we were tracking\n-        const finalData = applyPendingUpdates(leadsWithValidPositions, pendingUpdates);\n-        \n-        // Properly sort leads by column and position before setting items\n-        const sortedData = sortLeadsByPositionInColumns(finalData);\n-        \n-        // Set the items\n-        setItems(sortedData);\n+        // Sort leads by position within columns\n+        const sortedLeads = sortLeadsByPositionInColumns(fetchedLeads);\n+        setItems(sortedLeads);\n+      } catch (error) {\n+        console.error(\"Error fetching leads:\", error);\n+      } finally {\n+        setIsLoading(false);\n       }\n-      \n-      setError(null);\n-    } catch (err) {\n-      console.error('Error fetching leads:', err);\n-      const errorMessage = err instanceof Error ? \n-        `Failed to load leads: ${err.message}` : \n-        'Failed to load leads. Please try again later.';\n-      setError(errorMessage);\n-    } finally {\n-      setLoading(false);\n-    }\n-  }\n+    };\n \n-  // Helper function to apply pending position updates\n-  function applyPendingUpdates(leads: Lead[], pendingUpdates: {id: string, position: number, status: string}[]): Lead[] {\n-    if (pendingUpdates.length === 0) return leads;\n-    \n-    return leads.map(lead => {\n-      const update = pendingUpdates.find(u => u.id === lead.id.toString());\n-      if (update) {\n-        return {\n-          ...lead,\n-          position: update.position,\n-          status: update.status\n-        };\n-      }\n-      return lead;\n-    });\n-  }\n+    fetchLeads();\n+  }, []);\n \n-  // Add a new helper function to sort leads properly by position within columns\n-  // Add this after the applyPendingUpdates function\n+  // Sort leads by position within their columns\n+  const sortLeadsByPositionInColumns = (leads: Lead[]) => {\n+    // Group leads by status\n+    const groupedLeads = leads.reduce((acc, lead) => {\n+      const status = lead.status || 'New';\n+      if (!acc[status]) acc[status] = [];\n+      acc[status].push(lead);\n+      return acc;\n+    }, {} as Record<string, Lead[]>);\n \n-  // Helper function to sort leads by position within each column/status\n-  function sortLeadsByPositionInColumns(leads: Lead[]): Lead[] {\n-    // Group leads by status\n-    const leadsByStatus: Record<string, Lead[]> = {};\n-    \n-    leads.forEach(lead => {\n-      if (!leadsByStatus[lead.status]) {\n-        leadsByStatus[lead.status] = [];\n-      }\n-      leadsByStatus[lead.status].push(lead);\n-    });\n-    \n     // Sort each group by position\n-    Object.keys(leadsByStatus).forEach(status => {\n-      leadsByStatus[status].sort((a, b) => {\n-        const posA = a.position !== undefined && !isNaN(a.position) ? a.position : 999;\n-        const posB = b.position !== undefined && !isNaN(b.position) ? b.position : 999;\n-        return posA - posB;\n-      });\n+    Object.keys(groupedLeads).forEach(status => {\n+      groupedLeads[status].sort((a, b) => (a.position || 0) - (b.position || 0));\n     });\n-    \n-    // Flatten the sorted groups back into a single array\n-    const sortedLeads: Lead[] = [];\n-    Object.values(leadsByStatus).forEach(statusLeads => {\n-      sortedLeads.push(...statusLeads);\n-    });\n-    \n-    return sortedLeads;\n-  }\n \n-  // Function to handle when a new lead is added\n-  const handleLeadAdded = () => {\n-    // Refetch leads\n-    fetchLeads();\n+    // Flatten back to array\n+    return Object.values(groupedLeads).flat();\n   };\n \n-  useEffect(() => {\n-    fetchLeads();\n-  }, []);\n+  // Apply any pending updates to the leads\n+  const applyPendingUpdates = (leads: Lead[], updates: Record<string, Partial<Lead>>) => {\n+    return leads.map(lead => {\n+      const update = updates[lead.id];\n+      return update ? { ...lead, ...update } : lead;\n+    });\n+  };\n \n-  // Filter out any problematic leads from the UI\n-  useEffect(() => {\n-    if (items.length > 0) {\n-      const problematicLeadIds = ['1741295054950']; // Add any other problematic IDs here\n-      const filteredItems = items.filter(item => \n-        !problematicLeadIds.includes(item.id.toString())\n-      );\n-      \n-      if (filteredItems.length < items.length) {\n-        console.log(`Filtered out ${items.length - filteredItems.length} problematic leads from UI`);\n-        setItems(filteredItems);\n-      }\n-    }\n-  }, [items]);\n+  // Handle drag end for react-beautiful-dnd\n+  const handleDragEnd = async (result: DropResult) => {\n+    const { destination, source, draggableId } = result;\n \n-  const sensors = useSensors(\n-    useSensor(PointerSensor),\n-    useSensor(KeyboardSensor, {\n-      coordinateGetter: sortableKeyboardCoordinates,\n-    })\n-  );\n-\n-  // Calculate summary statistics\n-  const totalLeads = items.length;\n-  const qualifiedLeads = items.filter(item => item.status === 'Qualified').length;\n-  const totalValue = items.reduce((sum, item) => {\n-    const numericValue = item.value.replace(/[^0-9]/g, '');\n-    return sum + (numericValue ? parseInt(numericValue) : 0);\n-  }, 0);\n-  const conversionRate = totalLeads > 0 ? Math.round((qualifiedLeads / totalLeads) * 100) : 0;\n-\n-  const handleDragStart = (event: DragStartEvent) => {\n-    const { active } = event;\n-    if (active.data.current?.type === 'column') {\n-      setActiveColumnId(active.id as string);\n-    } else {\n-      setActiveId(active.id as string);\n+    // Dropped outside or same position\n+    if (!destination || \n+        (destination.droppableId === source.droppableId && \n+         destination.index === source.index)) {\n+      return;\n     }\n-  };\n \n-  const handleDragEnd = async (event: DragEndEvent) => {\n-    const { active, over } = event;\n+    // Find the lead that was dragged\n+    const lead = items.find(item => item.id === draggableId);\n+    if (!lead) return;\n \n-    if (!over) return;\n-\n-    if (active.data.current?.type === 'column') {\n-      const oldIndex = columns.findIndex(col => col.id === active.id);\n-      const newIndex = columns.findIndex(col => col.id === over.id);\n-\n-      if (oldIndex !== newIndex) {\n-        setColumns(arrayMove(columns, oldIndex, newIndex));\n-      }\n-    } else {\n-      const activeItem = items.find(item => item.id.toString() === active.id);\n-      const overColumn = over.data.current?.type === 'column' ? over.id : over.data.current?.columnId;\n-\n-      if (activeItem && overColumn) {\n-        try {\n-          // Set the drag in progress flag\n-          dragInProgressRef.current[active.id as string] = true;\n-          \n-          // Moving between columns\n-          if (activeItem.status !== overColumn) {\n-            // Validate the lead ID before updating\n-            if (!activeItem.id || isNaN(activeItem.id) || activeItem.id <= 0) {\n-              console.error(`Cannot update lead with invalid ID: ${activeItem.id}`);\n-              return;\n-            }\n-            \n-            // Skip the problematic lead ID\n-            if (activeItem.id.toString() === '1741295054950') {\n-              console.warn(`Skipping update for known problematic lead ID: ${activeItem.id}`);\n-              return;\n-            }\n-            \n-            // Get items in the target column to calculate new position\n-            const itemsInTargetColumn = items\n-              .filter(item => item.status === overColumn && item.id > 0)\n-              .sort((a, b) => a.position - b.position);\n-            \n-            // Calculate new position (add at the end of the target column)\n-            const newPosition = itemsInTargetColumn.length > 0\n-              ? Math.max(...itemsInTargetColumn.map(item => item.position)) + 1\n-              : 1;\n-            \n-            console.log(`Moving lead ${activeItem.id} from ${activeItem.status} to ${overColumn} with position ${newPosition}`);\n-            \n-            try {\n-              // Try to update in database first for consistent state\n-              await updateLead(activeItem.id.toString(), { \n-                status: overColumn as string,\n-                position: newPosition\n-              });\n-              \n-              // Log the successful position update\n-              console.log(`Position update SUCCESS: Lead ${activeItem.id} moved to ${overColumn} with position ${newPosition}`);\n-              \n-              // After database update success, update local state\n-              setItems(prevItems => {\n-                const newItems = prevItems.map(item => \n-                  item.id.toString() === active.id\n-                    ? { ...item, status: overColumn as string, position: newPosition }\n-                    : item\n-                );\n-                // Sort properly to ensure consistent ordering\n-                return sortLeadsByPositionInColumns(newItems);\n-              });\n-              \n-              // Save the last update info for reference during renders\n-              lastUpdateRef.current = [\n-                ...lastUpdateRef.current.filter(item => item.id !== active.id as string),\n-                { id: active.id as string, position: newPosition, status: overColumn as string }\n-              ];\n-              \n-              // Update was successful, remove the item from dragInProgress\n-              delete dragInProgressRef.current[active.id as string];\n-            } catch (updateError) {\n-              console.error('Error updating lead status:', updateError);\n-              // Only refresh on error\n-              fetchLeads();\n-              // Clear the drag in progress flag\n-              delete dragInProgressRef.current[active.id as string];\n-            }\n-          }\n-          // Reordering within the same column\n-          else if (over.data.current?.type === 'item') {\n-            const itemsInSameColumn = items.filter(item => \n-              item.status === activeItem.status && \n-              item.id > 0 // Only include items with valid positive IDs\n-            );\n-            \n-            const sortedItemsInColumn = [...itemsInSameColumn].sort((a, b) => a.position - b.position);\n-            \n-            const activeIndex = sortedItemsInColumn.findIndex(item => item.id.toString() === active.id);\n-            const overIndex = sortedItemsInColumn.findIndex(item => item.id.toString() === over.id);\n-            \n-            if (activeIndex !== overIndex && activeIndex !== -1 && overIndex !== -1) {\n-              // Reorder items\n-              const reorderedItems = arrayMove(sortedItemsInColumn, activeIndex, overIndex);\n-              \n-              // Update positions for all items in the column to match their new order\n-              const updates = reorderedItems\n-                .filter(item => item.id && !isNaN(item.id)) // Only include items with valid IDs\n-                .filter(item => item.id.toString() !== '1741295054950') // Filter out the problematic lead ID\n-                .map((item, index) => ({\n-                  id: item.id.toString(),\n-                  position: index + 1\n-                }));\n-              \n-              console.log(`Reordering ${updates.length} leads within column ${activeItem.status}`);\n-              console.log(`New positions:`, updates);\n-              \n-              try {\n-                // Mark all affected cards as in progress\n-                updates.forEach(update => {\n-                  dragInProgressRef.current[update.id] = true;\n-                });\n-                \n-                // Try database update first\n-                await updateLeadPositions(updates);\n-                \n-                // Log successful position updates\n-                console.log(`Batch position update SUCCESS for ${updates.length} leads in ${activeItem.status}:`, \n-                  updates.map(u => `${u.id}:${u.position}`).join(', ')\n-                );\n-                \n-                // On successful database update, update the UI\n-                setItems(prevItems => {\n-                  const updatedItems = [...prevItems];\n-                  updates.forEach(update => {\n-                    const itemIndex = updatedItems.findIndex(item => item.id.toString() === update.id);\n-                    if (itemIndex !== -1) {\n-                      updatedItems[itemIndex] = {\n-                        ...updatedItems[itemIndex],\n-                        position: update.position\n-                      };\n-                      \n-                      // Update the last known position for this item\n-                      lastUpdateRef.current = [\n-                        ...lastUpdateRef.current.filter(item => item.id !== update.id),\n-                        { \n-                          id: update.id, \n-                          position: update.position, \n-                          status: updatedItems[itemIndex].status \n-                        }\n-                      ];\n-                    }\n-                  });\n-                  // Sort properly to ensure consistent ordering\n-                  return sortLeadsByPositionInColumns(updatedItems);\n-                });\n-                \n-                // Clear drag in progress flags for all updated cards\n-                updates.forEach(update => {\n-                  delete dragInProgressRef.current[update.id];\n-                });\n-              } catch (err) {\n-                console.error('Error batch updating lead positions:', err);\n-                // Only refresh on error\n-                fetchLeads();\n-                // Clear all drag in progress flags\n-                dragInProgressRef.current = {};\n-              }\n-            }\n-          }\n-        } catch (err) {\n-          console.error('Error updating lead position:', err);\n-          // Refresh the data to ensure UI is in sync with database\n-          fetchLeads();\n-          // Clear all drag in progress flags\n-          dragInProgressRef.current = {};\n+    // Create a new list with updated positions\n+    let newItems = [...items];\n+    \n+    // Apply status update if moved to a different column\n+    if (destination.droppableId !== source.droppableId) {\n+      // Create a pending update\n+      setPendingUpdates({\n+        ...pendingUpdates,\n+        [lead.id]: {\n+          ...pendingUpdates[lead.id],\n+          status: destination.droppableId,\n         }\n-      }\n+      });\n+      \n+      // Optimistically update the UI\n+      newItems = newItems.map(item => \n+        item.id === lead.id \n+          ? { ...item, status: destination.droppableId } \n+          : item\n+      );\n     }\n \n-    setActiveId(null);\n-    setActiveColumnId(null);\n-  };\n-\n-  // Function to identify problematic leads\n-  const handleScanForProblematicLeads = async () => {\n+    // Get leads in destination column\n+    const leadsInDestination = newItems.filter(\n+      item => item.status === destination.droppableId\n+    );\n+    \n+    // Remove the dragged lead if it's already in the destination column\n+    const destinationWithoutDragged = destination.droppableId === source.droppableId\n+      ? leadsInDestination.filter(item => item.id !== lead.id)\n+      : leadsInDestination;\n+    \n+    // Insert the dragged lead at the new position\n+    destinationWithoutDragged.splice(destination.index, 0, {\n+      ...lead,\n+      status: destination.droppableId\n+    });\n+    \n+    // Update positions for all leads in the destination column\n+    const updatedDestinationLeads = destinationWithoutDragged.map((item, index) => ({\n+      ...item,\n+      position: index\n+    }));\n+    \n+    // Update the items list with the new positions\n+    newItems = newItems.map(item => {\n+      if (item.status === destination.droppableId) {\n+        const updatedItem = updatedDestinationLeads.find(u => u.id === item.id);\n+        return updatedItem || item;\n+      }\n+      return item;\n+    });\n+    \n+    // Update UI optimistically\n+    setItems(newItems);\n+    \n+    // Persist changes to the database\n     try {\n-      setIsScanning(true);\n-      const problematicIds = await identifyProblematicLeads();\n-      setProblematicLeadIds(problematicIds);\n+      // Update the lead status if it changed\n+      if (destination.droppableId !== source.droppableId) {\n+        await updateLead(lead.id, { \n+          status: destination.droppableId \n+        });\n+      }\n       \n-      // Filter out problematic leads from the UI\n-      if (problematicIds.length > 0) {\n-        const filteredItems = items.filter(item => \n-          !problematicIds.includes(item.id.toString())\n-        );\n-        \n-        if (filteredItems.length < items.length) {\n-          console.log(`Filtered out ${items.length - filteredItems.length} problematic leads from UI`);\n-          setItems(filteredItems);\n-        }\n-      }\n+      // Update positions for all affected leads\n+      await updateLeadPositions(\n+        updatedDestinationLeads.map(lead => ({\n+          id: lead.id,\n+          position: lead.position\n+        }))\n+      );\n+      \n+      // Clear pending update for this lead\n+      const newPendingUpdates = { ...pendingUpdates };\n+      delete newPendingUpdates[lead.id];\n+      setPendingUpdates(newPendingUpdates);\n     } catch (error) {\n-      console.error('Error scanning for problematic leads:', error);\n-    } finally {\n-      setIsScanning(false);\n+      console.error(\"Error updating lead:\", error);\n+      // We could implement a rollback mechanism here if needed\n     }\n   };\n \n-  // Add an effect to ensure data consistency when items are updated\n-  useEffect(() => {\n-    // Apply any pending updates from lastUpdateRef to the items\n-    if (lastUpdateRef.current.length > 0 && items.length > 0) {\n-      setItems(prevItems => {\n-        const updatedItems = [...prevItems];\n-        let hasChanges = false;\n-        \n-        lastUpdateRef.current.forEach(update => {\n-          const itemIndex = updatedItems.findIndex(item => item.id.toString() === update.id);\n-          if (itemIndex !== -1) {\n-            // Only update if the current position or status doesn't match what we expect\n-            if (updatedItems[itemIndex].position !== update.position || \n-                updatedItems[itemIndex].status !== update.status) {\n-              updatedItems[itemIndex] = {\n-                ...updatedItems[itemIndex],\n-                position: update.position,\n-                status: update.status\n-              };\n-              hasChanges = true;\n-            }\n-          }\n-        });\n-        \n-        return hasChanges ? updatedItems : prevItems;\n-      });\n-    }\n-  }, [items]);\n+  const handleAddLead = () => {\n+    setIsAddLeadOpen(true);\n+  };\n \n-  // Modify the window focus handler to prevent too frequent refreshes\n-  useEffect(() => {\n-    let lastRefreshTime = Date.now();\n-    \n-    const handleFocus = () => {\n-      // Only refresh if it's been at least 10 seconds since last refresh\n-      const now = Date.now();\n-      if (now - lastRefreshTime > 10000) {\n-        console.log('Window refocused, refreshing lead positions');\n-        fetchLeads();\n-        lastRefreshTime = now;\n-      }\n-    };\n+  const handleLeadAdded = (newLead: Lead) => {\n+    setItems(prev => [...prev, newLead]);\n+  };\n \n-    // Add event listener\n-    window.addEventListener('focus', handleFocus);\n-    \n-    // Clean up\n-    return () => {\n-      window.removeEventListener('focus', handleFocus);\n-    };\n-  }, []);\n+  // Calculate summary statistics\n+  const totalLeadValue = items.reduce((sum, lead) => sum + (lead.value || 0), 0);\n+  const leadsByStatus = columns.map(column => ({\n+    id: column.id,\n+    count: items.filter(item => item.status === column.id).length,\n+    value: items\n+      .filter(item => item.status === column.id)\n+      .reduce((sum, lead) => sum + (lead.value || 0), 0)\n+  }));\n \n-  // Add an effect to periodically check if we have any pending position updates\n-  useEffect(() => {\n-    // If we have pending position updates, refresh data after a delay\n-    if (lastUpdateRef.current.length > 0) {\n-      const timer = setTimeout(() => {\n-        console.log('Refreshing leads due to pending position updates');\n-        fetchLeads();\n-      }, 2000); // Check after 2 seconds\n-      \n-      return () => clearTimeout(timer);\n-    }\n-  }, [lastUpdateRef.current.length]);\n-\n-  if (loading) {\n-    return <div className=\"py-10 text-center\">Loading leads...</div>;\n+  if (isLoading) {\n+    return <div className=\"p-6\">Loading leads...</div>;\n   }\n \n-  if (error) {\n-    return <div className=\"py-10 text-center text-red-500\">{error}</div>;\n-  }\n-\n   return (\n-    <DndContext\n-      sensors={sensors}\n-      collisionDetection={closestCorners}\n-      onDragStart={handleDragStart}\n-      onDragEnd={handleDragEnd}\n-    >\n-      {/* Summary Statistics */}\n-      <div className=\"grid grid-cols-4 gap-4 mb-8\">\n-        <Card className=\"p-4 border-l-4 border-l-blue-600\">\n-          <div className=\"flex items-center justify-between\">\n+    <div className=\"p-6 space-y-6\">\n+      {/* Summary Cards */}\n+      <div className=\"grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4\">\n+        <Card className=\"p-4 shadow-md\">\n+          <div className=\"flex justify-between items-center\">\n             <div>\n-              <p className=\"text-sm font-medium text-muted-foreground\">Total Leads</p>\n-              <p className=\"text-2xl font-bold\">{totalLeads}</p>\n+              <h3 className=\"text-lg font-semibold text-muted-foreground\">Total Leads</h3>\n+              <p className=\"text-2xl font-bold\">{items.length}</p>\n             </div>\n-            <Users className=\"w-8 h-8 text-blue-600\" />\n+            <div className=\"bg-slate-100 p-3 rounded-full\">\n+              <Users className=\"w-6 h-6 text-slate-600\" />\n+            </div>\n           </div>\n         </Card>\n         \n-        <Card className=\"p-4 border-l-4 border-l-emerald-600\">\n-          <div className=\"flex items-center justify-between\">\n+        <Card className=\"p-4 shadow-md\">\n+          <div className=\"flex justify-between items-center\">\n             <div>\n-              <p className=\"text-sm font-medium text-muted-foreground\">Conversion Rate</p>\n-              <p className=\"text-2xl font-bold\">{conversionRate}%</p>\n+              <h3 className=\"text-lg font-semibold text-muted-foreground\">Total Value</h3>\n+              <p className=\"text-2xl font-bold\">{formatCurrency(totalLeadValue)}</p>\n             </div>\n-            <BarChart className=\"w-8 h-8 text-emerald-600\" />\n+            <div className=\"bg-blue-100 p-3 rounded-full\">\n+              <DollarSign className=\"w-6 h-6 text-blue-600\" />\n+            </div>\n           </div>\n         </Card>\n         \n-        <Card className=\"p-4 border-l-4 border-l-indigo-600\">\n-          <div className=\"flex items-center justify-between\">\n+        <Card className=\"p-4 shadow-md\">\n+          <div className=\"flex justify-between items-center\">\n             <div>\n-              <p className=\"text-sm font-medium text-muted-foreground\">Pipeline Value</p>\n-              <p className=\"text-2xl font-bold\">{formatCurrency(totalValue)}</p>\n+              <h3 className=\"text-lg font-semibold text-muted-foreground\">Conversion Rate</h3>\n+              <p className=\"text-2xl font-bold\">\n+                {items.length ? ((leadsByStatus[2]?.count || 0) / items.length * 100).toFixed(1) : 0}%\n+              </p>\n             </div>\n-            <DollarSign className=\"w-8 h-8 text-indigo-600\" />\n+            <div className=\"bg-emerald-100 p-3 rounded-full\">\n+              <TrendingUp className=\"w-6 h-6 text-emerald-600\" />\n+            </div>\n           </div>\n         </Card>\n         \n-        <Card className=\"p-4 border-l-4 border-l-slate-600\">\n-          <div className=\"flex items-center justify-between\">\n+        <Card className=\"p-4 shadow-md\">\n+          <div className=\"flex justify-between items-center\">\n             <div>\n-              <p className=\"text-sm font-medium text-muted-foreground\">Qualified Leads</p>\n-              <p className=\"text-2xl font-bold\">{qualifiedLeads}</p>\n+              <h3 className=\"text-lg font-semibold text-muted-foreground\">Avg. Deal Size</h3>\n+              <p className=\"text-2xl font-bold\">\n+                {items.length ? formatCurrency(totalLeadValue / items.length) : '$0'}\n+              </p>\n             </div>\n-            <TrendingUp className=\"w-8 h-8 text-slate-600\" />\n+            <div className=\"bg-indigo-100 p-3 rounded-full\">\n+              <BarChart className=\"w-6 h-6 text-indigo-600\" />\n+            </div>\n           </div>\n         </Card>\n       </div>\n-\n-      <div className=\"mb-4 flex justify-between items-center\">\n-        <div className=\"flex items-center space-x-2\">\n-          <AddLeadDialog onLeadAdded={handleLeadAdded}>\n-            <Button className=\"bg-blue-600 hover:bg-blue-700\">\n-              <Plus className=\"w-4 h-4 mr-2\" />\n-              Add Lead\n+      \n+      {/* Action Bar */}\n+      <div className=\"flex justify-between items-center\">\n+        <div className=\"flex items-center gap-2\">\n+          <Button onClick={handleAddLead} className=\"bg-slate-800 hover:bg-slate-700\">\n+            <Plus className=\"mr-2 h-4 w-4\" /> Add Lead\n+          </Button>\n+          \n+          {problematicLeads.length > 0 && (\n+            <Button variant=\"ghost\" className=\"text-amber-600\" title=\"Some leads have data issues\">\n+              <AlertTriangle className=\"mr-2 h-4 w-4\" /> {problematicLeads.length} Issue{problematicLeads.length > 1 ? 's' : ''}\n             </Button>\n-          </AddLeadDialog>\n-          <Button variant=\"outline\" className=\"border-slate-200\">\n-            <SlidersHorizontal className=\"w-4 h-4 mr-2\" />\n-            Filters\n+          )}\n+        </div>\n+        \n+        <div className=\"flex items-center gap-2\">\n+          <Button variant=\"outline\" size=\"icon\">\n+            <SlidersHorizontal className=\"h-4 w-4\" />\n           </Button>\n-          <Button \n-            variant=\"outline\" \n-            className=\"border-amber-200 text-amber-700\"\n-            onClick={handleScanForProblematicLeads}\n-            disabled={isScanning}\n-          >\n-            <AlertTriangle className=\"w-4 h-4 mr-2\" />\n-            {isScanning ? 'Scanning...' : 'Scan for Issues'}\n+          <Button variant=\"outline\" size=\"icon\">\n+            <Search className=\"h-4 w-4\" />\n           </Button>\n-          <Button\n-            variant=\"outline\"\n-            className=\"border-slate-200\"\n-            onClick={() => fetchLeads()}\n-          >\n-            Refresh\n-          </Button>\n-          {problematicLeadIds.length > 0 && (\n-            <span className=\"text-amber-700 text-sm\">\n-              Found {problematicLeadIds.length} problematic leads (filtered from view)\n-            </span>\n-          )}\n         </div>\n       </div>\n-\n-      <div className=\"relative overflow-x-auto pb-4\">\n-        <SortableContext\n-          items={columns.map(col => col.id)}\n-          strategy={horizontalListSortingStrategy}\n-        >\n-          <div className=\"flex space-x-6 min-w-full\" style={{ width: `${columns.length * 320}px` }}>\n-            {columns.map((column) => (\n-              <div key={column.id} className=\"w-[300px] flex-shrink-0\">\n-                <KanbanColumn\n-                  id={column.id}\n-                  title={column.title}\n-                  color={column.color}\n-                  onTitleChange={(newTitle) => {\n-                    setColumns(columns.map(col =>\n-                      col.id === column.id ? { ...col, title: newTitle } : col\n-                    ));\n-                  }}\n-                  onColorChange={(newColor) => {\n-                    setColumns(columns.map(col =>\n-                      col.id === column.id ? { ...col, color: newColor } : col\n-                    ));\n-                  }}\n-                  onDelete={() => {\n-                    setColumns(columns.filter(col => col.id !== column.id));\n-                    // Move leads in deleted column to New\n-                    setItems(items.map(item =>\n-                      item.status === column.id\n-                        ? { ...item, status: 'New' }\n-                        : item\n-                    ));\n-                  }}\n-                  availableColors={availableColors}\n-                  isDeletable={column.id !== 'New'}\n-                >\n-                  <SortableContext\n-                    items={items\n-                      .filter(item => item.status === column.id)\n-                      .sort((a, b) => {\n-                        // Ensure we have valid positions to sort by\n-                        const posA = a.position !== undefined && !isNaN(a.position) ? a.position : 999;\n-                        const posB = b.position !== undefined && !isNaN(b.position) ? b.position : 999;\n-                        return posA - posB;\n-                      })\n-                      .map(item => item.id.toString())}\n-                    strategy={verticalListSortingStrategy}\n+      \n+      {/* Kanban Board */}\n+      <DragDropContext onDragEnd={handleDragEnd}>\n+        <div className=\"flex space-x-4 overflow-x-auto pb-6\">\n+          {columns.map((column) => (\n+            <div key={column.id} className=\"min-w-[300px]\">\n+              <div \n+                className={`bg-gradient-to-r ${column.color} py-2 px-4 rounded-t-md shadow-sm`}\n+              >\n+                <h3 className=\"font-semibold text-white\">{column.title}</h3>\n+              </div>\n+              <Droppable droppableId={column.id}>\n+                {(provided, snapshot) => (\n+                  <div\n+                    ref={provided.innerRef}\n+                    {...provided.droppableProps}\n+                    className={`bg-muted/30 p-4 rounded-b-md min-h-[500px] transition-colors ${\n+                      snapshot.isDraggingOver ? 'bg-muted/50' : ''\n+                    }`}\n                   >\n-                    {/* Uncomment this line to debug position values when needed */}\n-                    {/* console.log(`Column ${column.id} card positions:`, items.filter(item => item.status === column.id).map(i => `${i.id}:${i.position}`).join(', ')) */}\n-                    \n-                    {/* Use a stable sort approach to maintain correct positions */}\n                     {items\n-                      .filter(item => \n-                        item.status === column.id &&\n-                        (searchTerm === '' || \n-                          item.name.toLowerCase().includes(searchTerm.toLowerCase()) ||\n-                          item.company.toLowerCase().includes(searchTerm.toLowerCase()))\n-                      )\n-                      .sort((a, b) => {\n-                        // Check if this card is in the middle of a drag operation\n-                        if (dragInProgressRef.current[a.id.toString()] && !dragInProgressRef.current[b.id.toString()]) {\n-                          return -1; // Prioritize the card being dragged\n-                        }\n-                        if (!dragInProgressRef.current[a.id.toString()] && dragInProgressRef.current[b.id.toString()]) {\n-                          return 1;\n-                        }\n-                        \n-                        // Find the last position update if available\n-                        const lastUpdateA = lastUpdateRef.current.find(update => update.id === a.id.toString());\n-                        const lastUpdateB = lastUpdateRef.current.find(update => update.id === b.id.toString());\n-                        \n-                        // Use last update position if available\n-                        const posA = lastUpdateA?.position ?? (a.position !== undefined && !isNaN(a.position) ? a.position : 999);\n-                        const posB = lastUpdateB?.position ?? (b.position !== undefined && !isNaN(b.position) ? b.position : 999);\n-                        \n-                        return posA - posB;\n-                      })\n-                      .map((item) => (\n-                        <KanbanCard\n-                          key={item.id}\n-                          id={item.id.toString()}\n-                          lead={item}\n-                          columnColor={column.color}\n-                        />\n-                      ))\n-                    }\n-                  </SortableContext>\n-                </KanbanColumn>\n-              </div>\n-            ))}\n-          </div>\n-        </SortableContext>\n-      </div>\n-\n-      <DragOverlay>\n-        {activeId ? (\n-          <KanbanCard\n-            id={activeId}\n-            lead={items.find(item => item.id.toString() === activeId)!}\n-            columnColor={columns.find(col => col.id === items.find(item => \n-              item.id.toString() === activeId\n-            )?.status)?.color || ''}\n-          />\n-        ) : null}\n-      </DragOverlay>\n-    </DndContext>\n+                      .filter(item => item.status === column.id)\n+                      .map((item, index) => (\n+                        <Draggable \n+                          key={item.id} \n+                          draggableId={item.id} \n+                          index={index}\n+                          isDragDisabled={problematicLeads.includes(item.id)}\n+                        >\n+                          {(provided, snapshot) => (\n+                            <div\n+                              ref={provided.innerRef}\n+                              {...provided.draggableProps}\n+                              {...provided.dragHandleProps}\n+                              className=\"mb-3\"\n+                              style={provided.draggableProps.style}\n+                            >\n+                              <KanbanCard \n+                                id={item.id} \n+                                lead={item} \n+                                columnColor={column.color} \n+                                isDragging={snapshot.isDragging}\n+                              />\n+                            </div>\n+                          )}\n+                        </Draggable>\n+                      ))}\n+                    {provided.placeholder}\n+                  </div>\n+                )}\n+              </Droppable>\n+            </div>\n+          ))}\n+        </div>\n+      </DragDropContext>\n+      \n+      {/* Add Lead Dialog */}\n+      <AddLeadDialog \n+        open={isAddLeadOpen} \n+        onClose={() => setIsAddLeadOpen(false)}\n+        onLeadAdded={handleLeadAdded}\n+      />\n+    </div>\n   );\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1742495402897,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -55,10 +55,10 @@\n     const fetchLeads = async () => {\n       setIsLoading(true);\n       try {\n         const fetchedLeads = await getLeads();\n-        const problemLeads = await identifyProblematicLeads(fetchedLeads);\n-        setProblematicLeads(problemLeads.map(lead => lead.id));\n+        const problemLeads = await identifyProblematicLeads();\n+        setProblematicLeads(problemLeads);\n         \n         // Sort leads by position within columns\n         const sortedLeads = sortLeadsByPositionInColumns(fetchedLeads);\n         setItems(sortedLeads);\n@@ -93,9 +93,9 @@\n \n   // Apply any pending updates to the leads\n   const applyPendingUpdates = (leads: Lead[], updates: Record<string, Partial<Lead>>) => {\n     return leads.map(lead => {\n-      const update = updates[lead.id];\n+      const update = updates[lead.id.toString()];\n       return update ? { ...lead, ...update } : lead;\n     });\n   };\n \n@@ -110,9 +110,9 @@\n       return;\n     }\n \n     // Find the lead that was dragged\n-    const lead = items.find(item => item.id === draggableId);\n+    const lead = items.find(item => item.id.toString() === draggableId);\n     if (!lead) return;\n \n     // Create a new list with updated positions\n     let newItems = [...items];\n@@ -121,17 +121,17 @@\n     if (destination.droppableId !== source.droppableId) {\n       // Create a pending update\n       setPendingUpdates({\n         ...pendingUpdates,\n-        [lead.id]: {\n-          ...pendingUpdates[lead.id],\n+        [lead.id.toString()]: {\n+          ...pendingUpdates[lead.id.toString()],\n           status: destination.droppableId,\n         }\n       });\n       \n       // Optimistically update the UI\n       newItems = newItems.map(item => \n-        item.id === lead.id \n+        item.id.toString() === draggableId \n           ? { ...item, status: destination.droppableId } \n           : item\n       );\n     }\n@@ -142,9 +142,9 @@\n     );\n     \n     // Remove the dragged lead if it's already in the destination column\n     const destinationWithoutDragged = destination.droppableId === source.droppableId\n-      ? leadsInDestination.filter(item => item.id !== lead.id)\n+      ? leadsInDestination.filter(item => item.id.toString() !== draggableId)\n       : leadsInDestination;\n     \n     // Insert the dragged lead at the new position\n     destinationWithoutDragged.splice(destination.index, 0, {\n@@ -173,24 +173,24 @@\n     // Persist changes to the database\n     try {\n       // Update the lead status if it changed\n       if (destination.droppableId !== source.droppableId) {\n-        await updateLead(lead.id, { \n+        await updateLead(lead.id.toString(), { \n           status: destination.droppableId \n         });\n       }\n       \n       // Update positions for all affected leads\n       await updateLeadPositions(\n         updatedDestinationLeads.map(lead => ({\n-          id: lead.id,\n+          id: lead.id.toString(),\n           position: lead.position\n         }))\n       );\n       \n       // Clear pending update for this lead\n       const newPendingUpdates = { ...pendingUpdates };\n-      delete newPendingUpdates[lead.id];\n+      delete newPendingUpdates[lead.id.toString()];\n       setPendingUpdates(newPendingUpdates);\n     } catch (error) {\n       console.error(\"Error updating lead:\", error);\n       // We could implement a rollback mechanism here if needed\n@@ -205,15 +205,27 @@\n     setItems(prev => [...prev, newLead]);\n   };\n \n   // Calculate summary statistics\n-  const totalLeadValue = items.reduce((sum, lead) => sum + (lead.value || 0), 0);\n+  const totalLeadValue = items.reduce((sum, lead) => {\n+    // Convert string value like \"$5,000\" to number\n+    const numericValue = typeof lead.value === 'string' \n+      ? parseFloat(lead.value.replace(/[^0-9.-]+/g, \"\")) \n+      : (lead.value || 0);\n+    return sum + numericValue;\n+  }, 0);\n+  \n   const leadsByStatus = columns.map(column => ({\n     id: column.id,\n     count: items.filter(item => item.status === column.id).length,\n     value: items\n       .filter(item => item.status === column.id)\n-      .reduce((sum, lead) => sum + (lead.value || 0), 0)\n+      .reduce((sum, lead) => {\n+        const numericValue = typeof lead.value === 'string'\n+          ? parseFloat(lead.value.replace(/[^0-9.-]+/g, \"\"))\n+          : (lead.value || 0);\n+        return sum + numericValue;\n+      }, 0)\n   }));\n \n   if (isLoading) {\n     return <div className=\"p-6\">Loading leads...</div>;\n@@ -322,12 +334,12 @@\n                     {items\n                       .filter(item => item.status === column.id)\n                       .map((item, index) => (\n                         <Draggable \n-                          key={item.id} \n-                          draggableId={item.id} \n+                          key={item.id.toString()} \n+                          draggableId={item.id.toString()} \n                           index={index}\n-                          isDragDisabled={problematicLeads.includes(item.id)}\n+                          isDragDisabled={problematicLeads.includes(item.id.toString())}\n                         >\n                           {(provided, snapshot) => (\n                             <div\n                               ref={provided.innerRef}\n@@ -336,9 +348,9 @@\n                               className=\"mb-3\"\n                               style={provided.draggableProps.style}\n                             >\n                               <KanbanCard \n-                                id={item.id} \n+                                id={item.id.toString()} \n                                 lead={item} \n                                 columnColor={column.color} \n                                 isDragging={snapshot.isDragging}\n                               />\n"
                },
                {
                    "date": 1742495467013,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,14 +1,9 @@\n \"use client\";\n \n import { useState, useEffect } from 'react';\n-import { \n-  DragDropContext, \n-  Droppable, \n-  Draggable, \n-  DropResult \n-} from '@hello-pangea/dnd';\n-import { KanbanCard } from './kanban-card';\n+import dynamic from 'next/dynamic';\n+import { Lead } from '@/data/leads';\n import { Button } from '@/components/ui/button';\n import { Card } from '@/components/ui/card';\n import { \n   Plus, \n@@ -19,13 +14,29 @@\n   DollarSign,\n   BarChart,\n   AlertTriangle\n } from 'lucide-react';\n-import { Lead } from '@/data/leads';\n import { getLeads, updateLead, updateLeadPositions, identifyProblematicLeads } from '@/lib/services/leads-service';\n import { formatCurrency } from '@/lib/utils';\n import { AddLeadDialog } from './add-lead-dialog';\n+import { KanbanCard } from './kanban-card';\n \n+// Import DnD components with dynamic import to fix SSR issues\n+const DragDropContext = dynamic(\n+  () => import('@hello-pangea/dnd').then(mod => mod.DragDropContext),\n+  { ssr: false }\n+);\n+\n+const Droppable = dynamic(\n+  () => import('@hello-pangea/dnd').then(mod => mod.Droppable),\n+  { ssr: false }\n+);\n+\n+const Draggable = dynamic(\n+  () => import('@hello-pangea/dnd').then(mod => mod.Draggable),\n+  { ssr: false }\n+);\n+\n // Professional color scheme\n const initialColumns = [\n   { id: 'New', title: 'New Leads', color: 'from-slate-600 to-slate-500' },\n   { id: 'Contacted', title: 'Contacted', color: 'from-blue-700 to-blue-600' },\n@@ -41,8 +52,23 @@\n   { id: 'zinc', gradient: 'from-zinc-600 to-zinc-500' },\n   { id: 'gray', gradient: 'from-gray-600 to-gray-500' },\n ];\n \n+// Type for DropResult since we're using dynamic import\n+interface DropResult {\n+  draggableId: string;\n+  type: string;\n+  source: {\n+    droppableId: string;\n+    index: number;\n+  };\n+  destination?: {\n+    droppableId: string;\n+    index: number;\n+  } | null;\n+  reason?: 'DROP' | 'CANCEL';\n+}\n+\n export function LeadsKanban() {\n   const [columns, setColumns] = useState(initialColumns);\n   const [items, setItems] = useState<Lead[]>([]);\n   const [isLoading, setIsLoading] = useState(true);\n"
                },
                {
                    "date": 1742495538906,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,404 +1,3 @@\n \"use client\";\n \n-import { useState, useEffect } from 'react';\n-import dynamic from 'next/dynamic';\n-import { Lead } from '@/data/leads';\n-import { Button } from '@/components/ui/button';\n-import { Card } from '@/components/ui/card';\n-import { \n-  Plus, \n-  Search, \n-  SlidersHorizontal,\n-  TrendingUp,\n-  Users,\n-  DollarSign,\n-  BarChart,\n-  AlertTriangle\n-} from 'lucide-react';\n-import { getLeads, updateLead, updateLeadPositions, identifyProblematicLeads } from '@/lib/services/leads-service';\n-import { formatCurrency } from '@/lib/utils';\n-import { AddLeadDialog } from './add-lead-dialog';\n-import { KanbanCard } from './kanban-card';\n-\n-// Import DnD components with dynamic import to fix SSR issues\n-const DragDropContext = dynamic(\n-  () => import('@hello-pangea/dnd').then(mod => mod.DragDropContext),\n-  { ssr: false }\n-);\n-\n-const Droppable = dynamic(\n-  () => import('@hello-pangea/dnd').then(mod => mod.Droppable),\n-  { ssr: false }\n-);\n-\n-const Draggable = dynamic(\n-  () => import('@hello-pangea/dnd').then(mod => mod.Draggable),\n-  { ssr: false }\n-);\n-\n-// Professional color scheme\n-const initialColumns = [\n-  { id: 'New', title: 'New Leads', color: 'from-slate-600 to-slate-500' },\n-  { id: 'Contacted', title: 'Contacted', color: 'from-blue-700 to-blue-600' },\n-  { id: 'Qualified', title: 'Qualified', color: 'from-emerald-700 to-emerald-600' },\n-  { id: 'Negotiating', title: 'Negotiating', color: 'from-indigo-700 to-indigo-600' },\n-];\n-\n-const availableColors = [\n-  { id: 'slate', gradient: 'from-slate-600 to-slate-500' },\n-  { id: 'blue', gradient: 'from-blue-700 to-blue-600' },\n-  { id: 'emerald', gradient: 'from-emerald-700 to-emerald-600' },\n-  { id: 'indigo', gradient: 'from-indigo-700 to-indigo-600' },\n-  { id: 'zinc', gradient: 'from-zinc-600 to-zinc-500' },\n-  { id: 'gray', gradient: 'from-gray-600 to-gray-500' },\n-];\n-\n-// Type for DropResult since we're using dynamic import\n-interface DropResult {\n-  draggableId: string;\n-  type: string;\n-  source: {\n-    droppableId: string;\n-    index: number;\n-  };\n-  destination?: {\n-    droppableId: string;\n-    index: number;\n-  } | null;\n-  reason?: 'DROP' | 'CANCEL';\n-}\n-\n-export function LeadsKanban() {\n-  const [columns, setColumns] = useState(initialColumns);\n-  const [items, setItems] = useState<Lead[]>([]);\n-  const [isLoading, setIsLoading] = useState(true);\n-  const [isAddLeadOpen, setIsAddLeadOpen] = useState(false);\n-  const [pendingUpdates, setPendingUpdates] = useState<Record<string, Partial<Lead>>>({});\n-  const [problematicLeads, setProblematicLeads] = useState<string[]>([]);\n-\n-  // Fetch leads on component mount\n-  useEffect(() => {\n-    const fetchLeads = async () => {\n-      setIsLoading(true);\n-      try {\n-        const fetchedLeads = await getLeads();\n-        const problemLeads = await identifyProblematicLeads();\n-        setProblematicLeads(problemLeads);\n-        \n-        // Sort leads by position within columns\n-        const sortedLeads = sortLeadsByPositionInColumns(fetchedLeads);\n-        setItems(sortedLeads);\n-      } catch (error) {\n-        console.error(\"Error fetching leads:\", error);\n-      } finally {\n-        setIsLoading(false);\n-      }\n-    };\n-\n-    fetchLeads();\n-  }, []);\n-\n-  // Sort leads by position within their columns\n-  const sortLeadsByPositionInColumns = (leads: Lead[]) => {\n-    // Group leads by status\n-    const groupedLeads = leads.reduce((acc, lead) => {\n-      const status = lead.status || 'New';\n-      if (!acc[status]) acc[status] = [];\n-      acc[status].push(lead);\n-      return acc;\n-    }, {} as Record<string, Lead[]>);\n-\n-    // Sort each group by position\n-    Object.keys(groupedLeads).forEach(status => {\n-      groupedLeads[status].sort((a, b) => (a.position || 0) - (b.position || 0));\n-    });\n-\n-    // Flatten back to array\n-    return Object.values(groupedLeads).flat();\n-  };\n-\n-  // Apply any pending updates to the leads\n-  const applyPendingUpdates = (leads: Lead[], updates: Record<string, Partial<Lead>>) => {\n-    return leads.map(lead => {\n-      const update = updates[lead.id.toString()];\n-      return update ? { ...lead, ...update } : lead;\n-    });\n-  };\n-\n-  // Handle drag end for react-beautiful-dnd\n-  const handleDragEnd = async (result: DropResult) => {\n-    const { destination, source, draggableId } = result;\n-\n-    // Dropped outside or same position\n-    if (!destination || \n-        (destination.droppableId === source.droppableId && \n-         destination.index === source.index)) {\n-      return;\n-    }\n-\n-    // Find the lead that was dragged\n-    const lead = items.find(item => item.id.toString() === draggableId);\n-    if (!lead) return;\n-\n-    // Create a new list with updated positions\n-    let newItems = [...items];\n-    \n-    // Apply status update if moved to a different column\n-    if (destination.droppableId !== source.droppableId) {\n-      // Create a pending update\n-      setPendingUpdates({\n-        ...pendingUpdates,\n-        [lead.id.toString()]: {\n-          ...pendingUpdates[lead.id.toString()],\n-          status: destination.droppableId,\n-        }\n-      });\n-      \n-      // Optimistically update the UI\n-      newItems = newItems.map(item => \n-        item.id.toString() === draggableId \n-          ? { ...item, status: destination.droppableId } \n-          : item\n-      );\n-    }\n-\n-    // Get leads in destination column\n-    const leadsInDestination = newItems.filter(\n-      item => item.status === destination.droppableId\n-    );\n-    \n-    // Remove the dragged lead if it's already in the destination column\n-    const destinationWithoutDragged = destination.droppableId === source.droppableId\n-      ? leadsInDestination.filter(item => item.id.toString() !== draggableId)\n-      : leadsInDestination;\n-    \n-    // Insert the dragged lead at the new position\n-    destinationWithoutDragged.splice(destination.index, 0, {\n-      ...lead,\n-      status: destination.droppableId\n-    });\n-    \n-    // Update positions for all leads in the destination column\n-    const updatedDestinationLeads = destinationWithoutDragged.map((item, index) => ({\n-      ...item,\n-      position: index\n-    }));\n-    \n-    // Update the items list with the new positions\n-    newItems = newItems.map(item => {\n-      if (item.status === destination.droppableId) {\n-        const updatedItem = updatedDestinationLeads.find(u => u.id === item.id);\n-        return updatedItem || item;\n-      }\n-      return item;\n-    });\n-    \n-    // Update UI optimistically\n-    setItems(newItems);\n-    \n-    // Persist changes to the database\n-    try {\n-      // Update the lead status if it changed\n-      if (destination.droppableId !== source.droppableId) {\n-        await updateLead(lead.id.toString(), { \n-          status: destination.droppableId \n-        });\n-      }\n-      \n-      // Update positions for all affected leads\n-      await updateLeadPositions(\n-        updatedDestinationLeads.map(lead => ({\n-          id: lead.id.toString(),\n-          position: lead.position\n-        }))\n-      );\n-      \n-      // Clear pending update for this lead\n-      const newPendingUpdates = { ...pendingUpdates };\n-      delete newPendingUpdates[lead.id.toString()];\n-      setPendingUpdates(newPendingUpdates);\n-    } catch (error) {\n-      console.error(\"Error updating lead:\", error);\n-      // We could implement a rollback mechanism here if needed\n-    }\n-  };\n-\n-  const handleAddLead = () => {\n-    setIsAddLeadOpen(true);\n-  };\n-\n-  const handleLeadAdded = (newLead: Lead) => {\n-    setItems(prev => [...prev, newLead]);\n-  };\n-\n-  // Calculate summary statistics\n-  const totalLeadValue = items.reduce((sum, lead) => {\n-    // Convert string value like \"$5,000\" to number\n-    const numericValue = typeof lead.value === 'string' \n-      ? parseFloat(lead.value.replace(/[^0-9.-]+/g, \"\")) \n-      : (lead.value || 0);\n-    return sum + numericValue;\n-  }, 0);\n-  \n-  const leadsByStatus = columns.map(column => ({\n-    id: column.id,\n-    count: items.filter(item => item.status === column.id).length,\n-    value: items\n-      .filter(item => item.status === column.id)\n-      .reduce((sum, lead) => {\n-        const numericValue = typeof lead.value === 'string'\n-          ? parseFloat(lead.value.replace(/[^0-9.-]+/g, \"\"))\n-          : (lead.value || 0);\n-        return sum + numericValue;\n-      }, 0)\n-  }));\n-\n-  if (isLoading) {\n-    return <div className=\"p-6\">Loading leads...</div>;\n-  }\n-\n-  return (\n-    <div className=\"p-6 space-y-6\">\n-      {/* Summary Cards */}\n-      <div className=\"grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4\">\n-        <Card className=\"p-4 shadow-md\">\n-          <div className=\"flex justify-between items-center\">\n-            <div>\n-              <h3 className=\"text-lg font-semibold text-muted-foreground\">Total Leads</h3>\n-              <p className=\"text-2xl font-bold\">{items.length}</p>\n-            </div>\n-            <div className=\"bg-slate-100 p-3 rounded-full\">\n-              <Users className=\"w-6 h-6 text-slate-600\" />\n-            </div>\n-          </div>\n-        </Card>\n-        \n-        <Card className=\"p-4 shadow-md\">\n-          <div className=\"flex justify-between items-center\">\n-            <div>\n-              <h3 className=\"text-lg font-semibold text-muted-foreground\">Total Value</h3>\n-              <p className=\"text-2xl font-bold\">{formatCurrency(totalLeadValue)}</p>\n-            </div>\n-            <div className=\"bg-blue-100 p-3 rounded-full\">\n-              <DollarSign className=\"w-6 h-6 text-blue-600\" />\n-            </div>\n-          </div>\n-        </Card>\n-        \n-        <Card className=\"p-4 shadow-md\">\n-          <div className=\"flex justify-between items-center\">\n-            <div>\n-              <h3 className=\"text-lg font-semibold text-muted-foreground\">Conversion Rate</h3>\n-              <p className=\"text-2xl font-bold\">\n-                {items.length ? ((leadsByStatus[2]?.count || 0) / items.length * 100).toFixed(1) : 0}%\n-              </p>\n-            </div>\n-            <div className=\"bg-emerald-100 p-3 rounded-full\">\n-              <TrendingUp className=\"w-6 h-6 text-emerald-600\" />\n-            </div>\n-          </div>\n-        </Card>\n-        \n-        <Card className=\"p-4 shadow-md\">\n-          <div className=\"flex justify-between items-center\">\n-            <div>\n-              <h3 className=\"text-lg font-semibold text-muted-foreground\">Avg. Deal Size</h3>\n-              <p className=\"text-2xl font-bold\">\n-                {items.length ? formatCurrency(totalLeadValue / items.length) : '$0'}\n-              </p>\n-            </div>\n-            <div className=\"bg-indigo-100 p-3 rounded-full\">\n-              <BarChart className=\"w-6 h-6 text-indigo-600\" />\n-            </div>\n-          </div>\n-        </Card>\n-      </div>\n-      \n-      {/* Action Bar */}\n-      <div className=\"flex justify-between items-center\">\n-        <div className=\"flex items-center gap-2\">\n-          <Button onClick={handleAddLead} className=\"bg-slate-800 hover:bg-slate-700\">\n-            <Plus className=\"mr-2 h-4 w-4\" /> Add Lead\n-          </Button>\n-          \n-          {problematicLeads.length > 0 && (\n-            <Button variant=\"ghost\" className=\"text-amber-600\" title=\"Some leads have data issues\">\n-              <AlertTriangle className=\"mr-2 h-4 w-4\" /> {problematicLeads.length} Issue{problematicLeads.length > 1 ? 's' : ''}\n-            </Button>\n-          )}\n-        </div>\n-        \n-        <div className=\"flex items-center gap-2\">\n-          <Button variant=\"outline\" size=\"icon\">\n-            <SlidersHorizontal className=\"h-4 w-4\" />\n-          </Button>\n-          <Button variant=\"outline\" size=\"icon\">\n-            <Search className=\"h-4 w-4\" />\n-          </Button>\n-        </div>\n-      </div>\n-      \n-      {/* Kanban Board */}\n-      <DragDropContext onDragEnd={handleDragEnd}>\n-        <div className=\"flex space-x-4 overflow-x-auto pb-6\">\n-          {columns.map((column) => (\n-            <div key={column.id} className=\"min-w-[300px]\">\n-              <div \n-                className={`bg-gradient-to-r ${column.color} py-2 px-4 rounded-t-md shadow-sm`}\n-              >\n-                <h3 className=\"font-semibold text-white\">{column.title}</h3>\n-              </div>\n-              <Droppable droppableId={column.id}>\n-                {(provided, snapshot) => (\n-                  <div\n-                    ref={provided.innerRef}\n-                    {...provided.droppableProps}\n-                    className={`bg-muted/30 p-4 rounded-b-md min-h-[500px] transition-colors ${\n-                      snapshot.isDraggingOver ? 'bg-muted/50' : ''\n-                    }`}\n-                  >\n-                    {items\n-                      .filter(item => item.status === column.id)\n-                      .map((item, index) => (\n-                        <Draggable \n-                          key={item.id.toString()} \n-                          draggableId={item.id.toString()} \n-                          index={index}\n-                          isDragDisabled={problematicLeads.includes(item.id.toString())}\n-                        >\n-                          {(provided, snapshot) => (\n-                            <div\n-                              ref={provided.innerRef}\n-                              {...provided.draggableProps}\n-                              {...provided.dragHandleProps}\n-                              className=\"mb-3\"\n-                              style={provided.draggableProps.style}\n-                            >\n-                              <KanbanCard \n-                                id={item.id.toString()} \n-                                lead={item} \n-                                columnColor={column.color} \n-                                isDragging={snapshot.isDragging}\n-                              />\n-                            </div>\n-                          )}\n-                        </Draggable>\n-                      ))}\n-                    {provided.placeholder}\n-                  </div>\n-                )}\n-              </Droppable>\n-            </div>\n-          ))}\n-        </div>\n-      </DragDropContext>\n-      \n-      {/* Add Lead Dialog */}\n-      <AddLeadDialog \n-        open={isAddLeadOpen} \n-        onClose={() => setIsAddLeadOpen(false)}\n-        onLeadAdded={handleLeadAdded}\n-      />\n-    </div>\n-  );\n-}\n\\ No newline at end of file\n+export { LeadsKanban } from './kanban-wrapper';\n\\ No newline at end of file\n"
                }
            ],
            "date": 1741292639254,
            "name": "Commit-0",
            "content": "\"use client\";\n\nimport { useState, useEffect } from 'react';\nimport { motion } from 'framer-motion';\nimport {\n  DndContext,\n  DragOverlay,\n  closestCorners,\n  KeyboardSensor,\n  PointerSensor,\n  useSensor,\n  useSensors,\n  DragStartEvent,\n  DragEndEvent,\n} from '@dnd-kit/core';\nimport {\n  arrayMove,\n  SortableContext,\n  sortableKeyboardCoordinates,\n  horizontalListSortingStrategy,\n  verticalListSortingStrategy,\n} from '@dnd-kit/sortable';\nimport { KanbanColumn } from './kanban-column';\nimport { KanbanCard } from './kanban-card';\nimport { Button } from '@/components/ui/button';\nimport { Card } from '@/components/ui/card';\nimport { \n  Plus, \n  Search, \n  SlidersHorizontal,\n  TrendingUp,\n  Users,\n  DollarSign,\n  BarChart\n} from 'lucide-react';\nimport { Lead } from '@/data/leads';\nimport { getLeads, updateLead } from '@/lib/services/leads-service';\nimport { formatCurrency } from '@/lib/utils';\n\n// Professional color scheme using muted, corporate tones\nconst initialColumns = [\n  { id: 'New', title: 'New Leads', color: 'from-slate-600 to-slate-500' },\n  { id: 'Contacted', title: 'Contacted', color: 'from-blue-700 to-blue-600' },\n  { id: 'Qualified', title: 'Qualified', color: 'from-emerald-700 to-emerald-600' },\n  { id: 'Negotiating', title: 'Negotiating', color: 'from-indigo-700 to-indigo-600' },\n];\n\nconst availableColors = [\n  { id: 'slate', gradient: 'from-slate-600 to-slate-500' },\n  { id: 'blue', gradient: 'from-blue-700 to-blue-600' },\n  { id: 'emerald', gradient: 'from-emerald-700 to-emerald-600' },\n  { id: 'indigo', gradient: 'from-indigo-700 to-indigo-600' },\n  { id: 'zinc', gradient: 'from-zinc-600 to-zinc-500' },\n  { id: 'gray', gradient: 'from-gray-600 to-gray-500' },\n];\n\nexport function LeadsKanban({ searchTerm }: { searchTerm: string }) {\n  const [items, setItems] = useState<Lead[]>([]);\n  const [columns, setColumns] = useState(initialColumns);\n  const [activeId, setActiveId] = useState<string | null>(null);\n  const [activeColumnId, setActiveColumnId] = useState<string | null>(null);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState<string | null>(null);\n\n  useEffect(() => {\n    async function fetchLeads() {\n      try {\n        setLoading(true);\n        const data = await getLeads();\n        setItems(data);\n        setError(null);\n      } catch (err) {\n        console.error('Error fetching leads:', err);\n        setError('Failed to load leads. Please try again later.');\n      } finally {\n        setLoading(false);\n      }\n    }\n\n    fetchLeads();\n  }, []);\n\n  const sensors = useSensors(\n    useSensor(PointerSensor),\n    useSensor(KeyboardSensor, {\n      coordinateGetter: sortableKeyboardCoordinates,\n    })\n  );\n\n  // Calculate summary statistics\n  const totalLeads = items.length;\n  const qualifiedLeads = items.filter(item => item.status === 'Qualified').length;\n  const totalValue = items.reduce((sum, item) => {\n    const numericValue = item.value.replace(/[^0-9]/g, '');\n    return sum + (numericValue ? parseInt(numericValue) : 0);\n  }, 0);\n  const conversionRate = totalLeads > 0 ? Math.round((qualifiedLeads / totalLeads) * 100) : 0;\n\n  const handleDragStart = (event: DragStartEvent) => {\n    const { active } = event;\n    if (active.data.current?.type === 'column') {\n      setActiveColumnId(active.id as string);\n    } else {\n      setActiveId(active.id as string);\n    }\n  };\n\n  const handleDragEnd = async (event: DragEndEvent) => {\n    const { active, over } = event;\n\n    if (!over) return;\n\n    if (active.data.current?.type === 'column') {\n      const oldIndex = columns.findIndex(col => col.id === active.id);\n      const newIndex = columns.findIndex(col => col.id === over.id);\n\n      if (oldIndex !== newIndex) {\n        setColumns(arrayMove(columns, oldIndex, newIndex));\n      }\n    } else {\n      const activeItem = items.find(item => item.id.toString() === active.id);\n      const overColumn = over.data.current?.type === 'column' ? over.id : over.data.current?.columnId;\n\n      if (activeItem && overColumn && activeItem.status !== overColumn) {\n        try {\n          // Update in Firestore\n          await updateLead(activeItem.id.toString(), { status: overColumn as string });\n          \n          // Update local state\n          setItems(items.map(item => \n            item.id.toString() === active.id\n              ? { ...item, status: overColumn as string }\n              : item\n          ));\n        } catch (err) {\n          console.error('Error updating lead status:', err);\n          // You might want to show a toast notification here\n        }\n      }\n    }\n\n    setActiveId(null);\n    setActiveColumnId(null);\n  };\n\n  if (loading) {\n    return <div className=\"py-10 text-center\">Loading leads...</div>;\n  }\n\n  if (error) {\n    return <div className=\"py-10 text-center text-red-500\">{error}</div>;\n  }\n\n  return (\n    <DndContext\n      sensors={sensors}\n      collisionDetection={closestCorners}\n      onDragStart={handleDragStart}\n      onDragEnd={handleDragEnd}\n    >\n      {/* Summary Statistics */}\n      <div className=\"grid grid-cols-4 gap-4 mb-8\">\n        <Card className=\"p-4 border-l-4 border-l-blue-600\">\n          <div className=\"flex items-center justify-between\">\n            <div>\n              <p className=\"text-sm font-medium text-muted-foreground\">Total Leads</p>\n              <p className=\"text-2xl font-bold\">{totalLeads}</p>\n            </div>\n            <Users className=\"w-8 h-8 text-blue-600\" />\n          </div>\n        </Card>\n        \n        <Card className=\"p-4 border-l-4 border-l-emerald-600\">\n          <div className=\"flex items-center justify-between\">\n            <div>\n              <p className=\"text-sm font-medium text-muted-foreground\">Conversion Rate</p>\n              <p className=\"text-2xl font-bold\">{conversionRate}%</p>\n            </div>\n            <BarChart className=\"w-8 h-8 text-emerald-600\" />\n          </div>\n        </Card>\n        \n        <Card className=\"p-4 border-l-4 border-l-indigo-600\">\n          <div className=\"flex items-center justify-between\">\n            <div>\n              <p className=\"text-sm font-medium text-muted-foreground\">Pipeline Value</p>\n              <p className=\"text-2xl font-bold\">{formatCurrency(totalValue)}</p>\n            </div>\n            <DollarSign className=\"w-8 h-8 text-indigo-600\" />\n          </div>\n        </Card>\n        \n        <Card className=\"p-4 border-l-4 border-l-slate-600\">\n          <div className=\"flex items-center justify-between\">\n            <div>\n              <p className=\"text-sm font-medium text-muted-foreground\">Qualified Leads</p>\n              <p className=\"text-2xl font-bold\">{qualifiedLeads}</p>\n            </div>\n            <TrendingUp className=\"w-8 h-8 text-slate-600\" />\n          </div>\n        </Card>\n      </div>\n\n      <div className=\"mb-4 flex justify-between items-center\">\n        <div className=\"flex items-center space-x-2\">\n          <Button onClick={() => {}} className=\"bg-blue-600 hover:bg-blue-700\">\n            <Plus className=\"w-4 h-4 mr-2\" />\n            Add Lead\n          </Button>\n          <Button variant=\"outline\" className=\"border-slate-200\">\n            <SlidersHorizontal className=\"w-4 h-4 mr-2\" />\n            Filters\n          </Button>\n        </div>\n      </div>\n\n      <div className=\"relative overflow-x-auto pb-4\">\n        <SortableContext\n          items={columns.map(col => col.id)}\n          strategy={horizontalListSortingStrategy}\n        >\n          <div className=\"flex space-x-6 min-w-full\" style={{ width: `${columns.length * 320}px` }}>\n            {columns.map((column) => (\n              <div key={column.id} className=\"w-[300px] flex-shrink-0\">\n                <KanbanColumn\n                  id={column.id}\n                  title={column.title}\n                  color={column.color}\n                  onTitleChange={(newTitle) => {\n                    setColumns(columns.map(col =>\n                      col.id === column.id ? { ...col, title: newTitle } : col\n                    ));\n                  }}\n                  onColorChange={(newColor) => {\n                    setColumns(columns.map(col =>\n                      col.id === column.id ? { ...col, color: newColor } : col\n                    ));\n                  }}\n                  onDelete={() => {\n                    setColumns(columns.filter(col => col.id !== column.id));\n                    // Move leads in deleted column to New\n                    setItems(items.map(item =>\n                      item.status === column.id\n                        ? { ...item, status: 'New' }\n                        : item\n                    ));\n                  }}\n                  availableColors={availableColors}\n                  isDeletable={column.id !== 'New'}\n                >\n                  <SortableContext\n                    items={items\n                      .filter(item => item.status === column.id)\n                      .map(item => item.id.toString())}\n                    strategy={verticalListSortingStrategy}\n                  >\n                    {items\n                      .filter(item => \n                        item.status === column.id &&\n                        (item.name.toLowerCase().includes(searchTerm.toLowerCase()) ||\n                         item.company.toLowerCase().includes(searchTerm.toLowerCase()))\n                      )\n                      .map((item) => (\n                        <KanbanCard\n                          key={item.id}\n                          id={item.id.toString()}\n                          lead={item}\n                          columnColor={column.color}\n                        />\n                      ))\n                    }\n                  </SortableContext>\n                </KanbanColumn>\n              </div>\n            ))}\n          </div>\n        </SortableContext>\n      </div>\n\n      <DragOverlay>\n        {activeId ? (\n          <KanbanCard\n            id={activeId}\n            lead={items.find(item => item.id.toString() === activeId)!}\n            columnColor={columns.find(col => col.id === items.find(item => \n              item.id.toString() === activeId\n            )?.status)?.color || ''}\n          />\n        ) : null}\n      </DragOverlay>\n    </DndContext>\n  );\n}"
        }
    ]
}