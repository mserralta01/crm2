{
    "sourceFile": "components/leads/leads-kanban.tsx",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 12,
            "patches": [
                {
                    "date": 1741292639254,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1741293619090,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -120,21 +120,78 @@\n     } else {\n       const activeItem = items.find(item => item.id.toString() === active.id);\n       const overColumn = over.data.current?.type === 'column' ? over.id : over.data.current?.columnId;\n \n-      if (activeItem && overColumn && activeItem.status !== overColumn) {\n+      if (activeItem && overColumn) {\n         try {\n-          // Update in Firestore\n-          await updateLead(activeItem.id.toString(), { status: overColumn as string });\n-          \n-          // Update local state\n-          setItems(items.map(item => \n-            item.id.toString() === active.id\n-              ? { ...item, status: overColumn as string }\n-              : item\n-          ));\n+          // Moving between columns\n+          if (activeItem.status !== overColumn) {\n+            // Get items in the target column to calculate new position\n+            const itemsInTargetColumn = items\n+              .filter(item => item.status === overColumn)\n+              .sort((a, b) => a.position - b.position);\n+            \n+            // Calculate new position (add at the end of the target column)\n+            const newPosition = itemsInTargetColumn.length > 0\n+              ? Math.max(...itemsInTargetColumn.map(item => item.position)) + 1\n+              : 1;\n+            \n+            // Update in Firestore\n+            await updateLead(activeItem.id.toString(), { \n+              status: overColumn as string,\n+              position: newPosition\n+            });\n+            \n+            // Update local state\n+            setItems(items.map(item => \n+              item.id.toString() === active.id\n+                ? { ...item, status: overColumn as string, position: newPosition }\n+                : item\n+            ));\n+          } \n+          // Reordering within the same column\n+          else if (over.data.current?.type === 'item') {\n+            const activeIndex = items\n+              .filter(item => item.status === activeItem.status)\n+              .sort((a, b) => a.position - b.position)\n+              .findIndex(item => item.id.toString() === active.id);\n+            \n+            const overIndex = items\n+              .filter(item => item.status === activeItem.status)\n+              .sort((a, b) => a.position - b.position)\n+              .findIndex(item => item.id.toString() === over.id);\n+            \n+            if (activeIndex !== overIndex) {\n+              // Get all items in the column, sorted by position\n+              const itemsInColumn = items\n+                .filter(item => item.status === activeItem.status)\n+                .sort((a, b) => a.position - b.position);\n+              \n+              // Reorder items\n+              const reorderedItems = arrayMove(itemsInColumn, activeIndex, overIndex);\n+              \n+              // Update positions for all items in the column to match their new order\n+              const updates = reorderedItems.map((item, index) => ({\n+                id: item.id.toString(),\n+                newPosition: index + 1\n+              }));\n+              \n+              // Update positions in database (one by one)\n+              for (const update of updates) {\n+                await updateLead(update.id, { position: update.newPosition });\n+              }\n+              \n+              // Update local state for all affected items\n+              setItems(items.map(item => {\n+                const update = updates.find(u => u.id === item.id.toString());\n+                return update \n+                  ? { ...item, position: update.newPosition }\n+                  : item;\n+              }));\n+            }\n+          }\n         } catch (err) {\n-          console.error('Error updating lead status:', err);\n+          console.error('Error updating lead position:', err);\n           // You might want to show a toast notification here\n         }\n       }\n     }\n@@ -259,8 +316,9 @@\n                         item.status === column.id &&\n                         (item.name.toLowerCase().includes(searchTerm.toLowerCase()) ||\n                          item.company.toLowerCase().includes(searchTerm.toLowerCase()))\n                       )\n+                      .sort((a, b) => a.position - b.position)\n                       .map((item) => (\n                         <KanbanCard\n                           key={item.id}\n                           id={item.id.toString()}\n"
                },
                {
                    "date": 1741293663832,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -33,10 +33,14 @@\n   DollarSign,\n   BarChart\n } from 'lucide-react';\n import { Lead } from '@/data/leads';\n-import { getLeads, updateLead } from '@/lib/services/leads-service';\n+import { getLeads, updateLead, updateLeadPositions } from '@/lib/services/leads-service';\n import { formatCurrency } from '@/lib/utils';\n+import { \n+  collection, \n+} from 'firebase/firestore';\n+import { db } from '@/lib/firebase';\n \n // Professional color scheme using muted, corporate tones\n const initialColumns = [\n   { id: 'New', title: 'New Leads', color: 'from-slate-600 to-slate-500' },\n@@ -171,23 +175,25 @@\n               \n               // Update positions for all items in the column to match their new order\n               const updates = reorderedItems.map((item, index) => ({\n                 id: item.id.toString(),\n-                newPosition: index + 1\n+                position: index + 1\n               }));\n               \n-              // Update positions in database (one by one)\n-              for (const update of updates) {\n-                await updateLead(update.id, { position: update.newPosition });\n+              // Use batch update for better performance\n+              try {\n+                await updateLeadPositions(updates);\n+                \n+                // Update local state for all affected items\n+                setItems(items.map(item => {\n+                  const update = updates.find(u => u.id === item.id.toString());\n+                  return update \n+                    ? { ...item, position: update.position }\n+                    : item;\n+                }));\n+              } catch (err) {\n+                console.error('Error batch updating lead positions:', err);\n               }\n-              \n-              // Update local state for all affected items\n-              setItems(items.map(item => {\n-                const update = updates.find(u => u.id === item.id.toString());\n-                return update \n-                  ? { ...item, position: update.newPosition }\n-                  : item;\n-              }));\n             }\n           }\n         } catch (err) {\n           console.error('Error updating lead position:', err);\n"
                },
                {
                    "date": 1741293681592,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -70,9 +70,63 @@\n     async function fetchLeads() {\n       try {\n         setLoading(true);\n         const data = await getLeads();\n-        setItems(data);\n+        \n+        // Check if positions need to be initialized\n+        const needsPositionInit = data.some(lead => !lead.position);\n+        \n+        if (needsPositionInit) {\n+          console.log('Initializing positions for leads...');\n+          \n+          // Group leads by status\n+          const leadsByStatus = data.reduce((acc, lead) => {\n+            if (!acc[lead.status]) {\n+              acc[lead.status] = [];\n+            }\n+            acc[lead.status].push(lead);\n+            return acc;\n+          }, {} as Record<string, Lead[]>);\n+          \n+          // Generate position updates for each status group\n+          const positionUpdates: { id: string; position: number }[] = [];\n+          \n+          for (const status in leadsByStatus) {\n+            const statusLeads = leadsByStatus[status];\n+            // Sort by lastActivity date as a reasonable default order\n+            statusLeads.sort((a, b) => \n+              new Date(b.lastActivity).getTime() - new Date(a.lastActivity).getTime()\n+            );\n+            \n+            // Assign positions\n+            statusLeads.forEach((lead, index) => {\n+              if (!lead.position) {\n+                positionUpdates.push({\n+                  id: lead.id.toString(),\n+                  position: index + 1\n+                });\n+              }\n+            });\n+          }\n+          \n+          // Update positions in database\n+          if (positionUpdates.length > 0) {\n+            await updateLeadPositions(positionUpdates);\n+            \n+            // Update local state\n+            const updatedData = data.map(lead => {\n+              const update = positionUpdates.find(u => u.id === lead.id.toString());\n+              return update ? { ...lead, position: update.position } : lead;\n+            });\n+            \n+            setItems(updatedData);\n+          } else {\n+            setItems(data);\n+          }\n+        } else {\n+          setItems(data);\n+        }\n+        \n         setError(null);\n       } catch (err) {\n         console.error('Error fetching leads:', err);\n         setError('Failed to load leads. Please try again later.');\n"
                },
                {
                    "date": 1741293913544,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -39,8 +39,9 @@\n import { \n   collection, \n } from 'firebase/firestore';\n import { db } from '@/lib/firebase';\n+import { AddLeadDialog } from '@/components/leads/add-lead-dialog';\n \n // Professional color scheme using muted, corporate tones\n const initialColumns = [\n   { id: 'New', title: 'New Leads', color: 'from-slate-600 to-slate-500' },\n@@ -65,8 +66,14 @@\n   const [activeColumnId, setActiveColumnId] = useState<string | null>(null);\n   const [loading, setLoading] = useState(true);\n   const [error, setError] = useState<string | null>(null);\n \n+  // Function to handle when a new lead is added\n+  const handleLeadAdded = () => {\n+    // Refetch leads\n+    fetchLeads();\n+  };\n+\n   useEffect(() => {\n     async function fetchLeads() {\n       try {\n         setLoading(true);\n@@ -319,12 +326,14 @@\n       </div>\n \n       <div className=\"mb-4 flex justify-between items-center\">\n         <div className=\"flex items-center space-x-2\">\n-          <Button onClick={() => {}} className=\"bg-blue-600 hover:bg-blue-700\">\n-            <Plus className=\"w-4 h-4 mr-2\" />\n-            Add Lead\n-          </Button>\n+          <AddLeadDialog onLeadAdded={handleLeadAdded}>\n+            <Button className=\"bg-blue-600 hover:bg-blue-700\">\n+              <Plus className=\"w-4 h-4 mr-2\" />\n+              Add Lead\n+            </Button>\n+          </AddLeadDialog>\n           <Button variant=\"outline\" className=\"border-slate-200\">\n             <SlidersHorizontal className=\"w-4 h-4 mr-2\" />\n             Filters\n           </Button>\n"
                },
                {
                    "date": 1741293925486,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -66,84 +66,85 @@\n   const [activeColumnId, setActiveColumnId] = useState<string | null>(null);\n   const [loading, setLoading] = useState(true);\n   const [error, setError] = useState<string | null>(null);\n \n-  // Function to handle when a new lead is added\n-  const handleLeadAdded = () => {\n-    // Refetch leads\n-    fetchLeads();\n-  };\n-\n-  useEffect(() => {\n-    async function fetchLeads() {\n-      try {\n-        setLoading(true);\n-        const data = await getLeads();\n+  // Function to fetch leads data\n+  async function fetchLeads() {\n+    try {\n+      setLoading(true);\n+      const data = await getLeads();\n+      \n+      // Check if positions need to be initialized\n+      const needsPositionInit = data.some(lead => !lead.position);\n+      \n+      if (needsPositionInit) {\n+        console.log('Initializing positions for leads...');\n         \n-        // Check if positions need to be initialized\n-        const needsPositionInit = data.some(lead => !lead.position);\n+        // Group leads by status\n+        const leadsByStatus = data.reduce((acc, lead) => {\n+          if (!acc[lead.status]) {\n+            acc[lead.status] = [];\n+          }\n+          acc[lead.status].push(lead);\n+          return acc;\n+        }, {} as Record<string, Lead[]>);\n         \n-        if (needsPositionInit) {\n-          console.log('Initializing positions for leads...');\n+        // Generate position updates for each status group\n+        const positionUpdates: { id: string; position: number }[] = [];\n+        \n+        for (const status in leadsByStatus) {\n+          const statusLeads = leadsByStatus[status];\n+          // Sort by lastActivity date as a reasonable default order\n+          statusLeads.sort((a, b) => \n+            new Date(b.lastActivity).getTime() - new Date(a.lastActivity).getTime()\n+          );\n           \n-          // Group leads by status\n-          const leadsByStatus = data.reduce((acc, lead) => {\n-            if (!acc[lead.status]) {\n-              acc[lead.status] = [];\n+          // Assign positions\n+          statusLeads.forEach((lead, index) => {\n+            if (!lead.position) {\n+              positionUpdates.push({\n+                id: lead.id.toString(),\n+                position: index + 1\n+              });\n             }\n-            acc[lead.status].push(lead);\n-            return acc;\n-          }, {} as Record<string, Lead[]>);\n+          });\n+        }\n+        \n+        // Update positions in database\n+        if (positionUpdates.length > 0) {\n+          await updateLeadPositions(positionUpdates);\n           \n-          // Generate position updates for each status group\n-          const positionUpdates: { id: string; position: number }[] = [];\n+          // Update local state\n+          const updatedData = data.map(lead => {\n+            const update = positionUpdates.find(u => u.id === lead.id.toString());\n+            return update ? { ...lead, position: update.position } : lead;\n+          });\n           \n-          for (const status in leadsByStatus) {\n-            const statusLeads = leadsByStatus[status];\n-            // Sort by lastActivity date as a reasonable default order\n-            statusLeads.sort((a, b) => \n-              new Date(b.lastActivity).getTime() - new Date(a.lastActivity).getTime()\n-            );\n-            \n-            // Assign positions\n-            statusLeads.forEach((lead, index) => {\n-              if (!lead.position) {\n-                positionUpdates.push({\n-                  id: lead.id.toString(),\n-                  position: index + 1\n-                });\n-              }\n-            });\n-          }\n-          \n-          // Update positions in database\n-          if (positionUpdates.length > 0) {\n-            await updateLeadPositions(positionUpdates);\n-            \n-            // Update local state\n-            const updatedData = data.map(lead => {\n-              const update = positionUpdates.find(u => u.id === lead.id.toString());\n-              return update ? { ...lead, position: update.position } : lead;\n-            });\n-            \n-            setItems(updatedData);\n-          } else {\n-            setItems(data);\n-          }\n+          setItems(updatedData);\n         } else {\n           setItems(data);\n         }\n-        \n-        setError(null);\n-      } catch (err) {\n-        console.error('Error fetching leads:', err);\n-        setError('Failed to load leads. Please try again later.');\n-      } finally {\n-        setLoading(false);\n+      } else {\n+        setItems(data);\n       }\n+      \n+      setError(null);\n+    } catch (err) {\n+      console.error('Error fetching leads:', err);\n+      setError('Failed to load leads. Please try again later.');\n+    } finally {\n+      setLoading(false);\n     }\n+  }\n \n+  // Function to handle when a new lead is added\n+  const handleLeadAdded = () => {\n+    // Refetch leads\n     fetchLeads();\n+  };\n+\n+  useEffect(() => {\n+    fetchLeads();\n   }, []);\n \n   const sensors = useSensors(\n     useSensor(PointerSensor),\n"
                },
                {
                    "date": 1741294657343,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -100,12 +100,17 @@\n           \n           // Assign positions\n           statusLeads.forEach((lead, index) => {\n             if (!lead.position) {\n-              positionUpdates.push({\n-                id: lead.id.toString(),\n-                position: index + 1\n-              });\n+              // Ensure lead.id is valid before converting to string\n+              if (lead.id && !isNaN(lead.id)) {\n+                positionUpdates.push({\n+                  id: lead.id.toString(),\n+                  position: index + 1\n+                });\n+              } else {\n+                console.warn(`Skipping position update for lead with invalid ID: ${lead.id}`);\n+              }\n             }\n           });\n         }\n         \n"
                },
                {
                    "date": 1741294688287,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -240,12 +240,14 @@\n               // Reorder items\n               const reorderedItems = arrayMove(itemsInColumn, activeIndex, overIndex);\n               \n               // Update positions for all items in the column to match their new order\n-              const updates = reorderedItems.map((item, index) => ({\n-                id: item.id.toString(),\n-                position: index + 1\n-              }));\n+              const updates = reorderedItems\n+                .filter(item => item.id && !isNaN(item.id)) // Only include items with valid IDs\n+                .map((item, index) => ({\n+                  id: item.id.toString(),\n+                  position: index + 1\n+                }));\n               \n               // Use batch update for better performance\n               try {\n                 await updateLeadPositions(updates);\n"
                },
                {
                    "date": 1741294699526,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -195,8 +195,14 @@\n       if (activeItem && overColumn) {\n         try {\n           // Moving between columns\n           if (activeItem.status !== overColumn) {\n+            // Validate the lead ID before updating\n+            if (!activeItem.id || isNaN(activeItem.id)) {\n+              console.error(`Cannot update lead with invalid ID: ${activeItem.id}`);\n+              return;\n+            }\n+            \n             // Get items in the target column to calculate new position\n             const itemsInTargetColumn = items\n               .filter(item => item.status === overColumn)\n               .sort((a, b) => a.position - b.position);\n"
                },
                {
                    "date": 1741294718896,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -134,9 +134,12 @@\n       \n       setError(null);\n     } catch (err) {\n       console.error('Error fetching leads:', err);\n-      setError('Failed to load leads. Please try again later.');\n+      const errorMessage = err instanceof Error ? \n+        `Failed to load leads: ${err.message}` : \n+        'Failed to load leads. Please try again later.';\n+      setError(errorMessage);\n     } finally {\n       setLoading(false);\n     }\n   }\n"
                },
                {
                    "date": 1741294854691,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -72,16 +72,23 @@\n     try {\n       setLoading(true);\n       const data = await getLeads();\n       \n+      // Filter out leads with invalid IDs (negative numbers)\n+      const validLeads = data.filter(lead => lead.id > 0);\n+      \n+      if (validLeads.length < data.length) {\n+        console.warn(`Filtered out ${data.length - validLeads.length} leads with invalid IDs`);\n+      }\n+      \n       // Check if positions need to be initialized\n-      const needsPositionInit = data.some(lead => !lead.position);\n+      const needsPositionInit = validLeads.some(lead => !lead.position);\n       \n       if (needsPositionInit) {\n         console.log('Initializing positions for leads...');\n         \n         // Group leads by status\n-        const leadsByStatus = data.reduce((acc, lead) => {\n+        const leadsByStatus = validLeads.reduce((acc, lead) => {\n           if (!acc[lead.status]) {\n             acc[lead.status] = [];\n           }\n           acc[lead.status].push(lead);\n@@ -101,9 +108,9 @@\n           // Assign positions\n           statusLeads.forEach((lead, index) => {\n             if (!lead.position) {\n               // Ensure lead.id is valid before converting to string\n-              if (lead.id && !isNaN(lead.id)) {\n+              if (lead.id && !isNaN(lead.id) && lead.id > 0) {\n                 positionUpdates.push({\n                   id: lead.id.toString(),\n                   position: index + 1\n                 });\n@@ -118,19 +125,19 @@\n         if (positionUpdates.length > 0) {\n           await updateLeadPositions(positionUpdates);\n           \n           // Update local state\n-          const updatedData = data.map(lead => {\n+          const updatedData = validLeads.map(lead => {\n             const update = positionUpdates.find(u => u.id === lead.id.toString());\n             return update ? { ...lead, position: update.position } : lead;\n           });\n           \n           setItems(updatedData);\n         } else {\n-          setItems(data);\n+          setItems(validLeads);\n         }\n       } else {\n-        setItems(data);\n+        setItems(validLeads);\n       }\n       \n       setError(null);\n     } catch (err) {\n"
                },
                {
                    "date": 1741294866859,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -236,23 +236,24 @@\n             ));\n           } \n           // Reordering within the same column\n           else if (over.data.current?.type === 'item') {\n-            const activeIndex = items\n-              .filter(item => item.status === activeItem.status)\n+            const itemsInSameColumn = items.filter(item => \n+              item.status === activeItem.status && \n+              item.id > 0 // Only include items with valid positive IDs\n+            );\n+            \n+            const activeIndex = itemsInSameColumn\n               .sort((a, b) => a.position - b.position)\n               .findIndex(item => item.id.toString() === active.id);\n             \n-            const overIndex = items\n-              .filter(item => item.status === activeItem.status)\n+            const overIndex = itemsInSameColumn\n               .sort((a, b) => a.position - b.position)\n               .findIndex(item => item.id.toString() === over.id);\n             \n-            if (activeIndex !== overIndex) {\n+            if (activeIndex !== overIndex && activeIndex !== -1 && overIndex !== -1) {\n               // Get all items in the column, sorted by position\n-              const itemsInColumn = items\n-                .filter(item => item.status === activeItem.status)\n-                .sort((a, b) => a.position - b.position);\n+              const itemsInColumn = itemsInSameColumn.sort((a, b) => a.position - b.position);\n               \n               // Reorder items\n               const reorderedItems = arrayMove(itemsInColumn, activeIndex, overIndex);\n               \n"
                },
                {
                    "date": 1741294971821,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -206,16 +206,16 @@\n         try {\n           // Moving between columns\n           if (activeItem.status !== overColumn) {\n             // Validate the lead ID before updating\n-            if (!activeItem.id || isNaN(activeItem.id)) {\n+            if (!activeItem.id || isNaN(activeItem.id) || activeItem.id <= 0) {\n               console.error(`Cannot update lead with invalid ID: ${activeItem.id}`);\n               return;\n             }\n             \n             // Get items in the target column to calculate new position\n             const itemsInTargetColumn = items\n-              .filter(item => item.status === overColumn)\n+              .filter(item => item.status === overColumn && item.id > 0)\n               .sort((a, b) => a.position - b.position);\n             \n             // Calculate new position (add at the end of the target column)\n             const newPosition = itemsInTargetColumn.length > 0\n"
                }
            ],
            "date": 1741292639254,
            "name": "Commit-0",
            "content": "\"use client\";\n\nimport { useState, useEffect } from 'react';\nimport { motion } from 'framer-motion';\nimport {\n  DndContext,\n  DragOverlay,\n  closestCorners,\n  KeyboardSensor,\n  PointerSensor,\n  useSensor,\n  useSensors,\n  DragStartEvent,\n  DragEndEvent,\n} from '@dnd-kit/core';\nimport {\n  arrayMove,\n  SortableContext,\n  sortableKeyboardCoordinates,\n  horizontalListSortingStrategy,\n  verticalListSortingStrategy,\n} from '@dnd-kit/sortable';\nimport { KanbanColumn } from './kanban-column';\nimport { KanbanCard } from './kanban-card';\nimport { Button } from '@/components/ui/button';\nimport { Card } from '@/components/ui/card';\nimport { \n  Plus, \n  Search, \n  SlidersHorizontal,\n  TrendingUp,\n  Users,\n  DollarSign,\n  BarChart\n} from 'lucide-react';\nimport { Lead } from '@/data/leads';\nimport { getLeads, updateLead } from '@/lib/services/leads-service';\nimport { formatCurrency } from '@/lib/utils';\n\n// Professional color scheme using muted, corporate tones\nconst initialColumns = [\n  { id: 'New', title: 'New Leads', color: 'from-slate-600 to-slate-500' },\n  { id: 'Contacted', title: 'Contacted', color: 'from-blue-700 to-blue-600' },\n  { id: 'Qualified', title: 'Qualified', color: 'from-emerald-700 to-emerald-600' },\n  { id: 'Negotiating', title: 'Negotiating', color: 'from-indigo-700 to-indigo-600' },\n];\n\nconst availableColors = [\n  { id: 'slate', gradient: 'from-slate-600 to-slate-500' },\n  { id: 'blue', gradient: 'from-blue-700 to-blue-600' },\n  { id: 'emerald', gradient: 'from-emerald-700 to-emerald-600' },\n  { id: 'indigo', gradient: 'from-indigo-700 to-indigo-600' },\n  { id: 'zinc', gradient: 'from-zinc-600 to-zinc-500' },\n  { id: 'gray', gradient: 'from-gray-600 to-gray-500' },\n];\n\nexport function LeadsKanban({ searchTerm }: { searchTerm: string }) {\n  const [items, setItems] = useState<Lead[]>([]);\n  const [columns, setColumns] = useState(initialColumns);\n  const [activeId, setActiveId] = useState<string | null>(null);\n  const [activeColumnId, setActiveColumnId] = useState<string | null>(null);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState<string | null>(null);\n\n  useEffect(() => {\n    async function fetchLeads() {\n      try {\n        setLoading(true);\n        const data = await getLeads();\n        setItems(data);\n        setError(null);\n      } catch (err) {\n        console.error('Error fetching leads:', err);\n        setError('Failed to load leads. Please try again later.');\n      } finally {\n        setLoading(false);\n      }\n    }\n\n    fetchLeads();\n  }, []);\n\n  const sensors = useSensors(\n    useSensor(PointerSensor),\n    useSensor(KeyboardSensor, {\n      coordinateGetter: sortableKeyboardCoordinates,\n    })\n  );\n\n  // Calculate summary statistics\n  const totalLeads = items.length;\n  const qualifiedLeads = items.filter(item => item.status === 'Qualified').length;\n  const totalValue = items.reduce((sum, item) => {\n    const numericValue = item.value.replace(/[^0-9]/g, '');\n    return sum + (numericValue ? parseInt(numericValue) : 0);\n  }, 0);\n  const conversionRate = totalLeads > 0 ? Math.round((qualifiedLeads / totalLeads) * 100) : 0;\n\n  const handleDragStart = (event: DragStartEvent) => {\n    const { active } = event;\n    if (active.data.current?.type === 'column') {\n      setActiveColumnId(active.id as string);\n    } else {\n      setActiveId(active.id as string);\n    }\n  };\n\n  const handleDragEnd = async (event: DragEndEvent) => {\n    const { active, over } = event;\n\n    if (!over) return;\n\n    if (active.data.current?.type === 'column') {\n      const oldIndex = columns.findIndex(col => col.id === active.id);\n      const newIndex = columns.findIndex(col => col.id === over.id);\n\n      if (oldIndex !== newIndex) {\n        setColumns(arrayMove(columns, oldIndex, newIndex));\n      }\n    } else {\n      const activeItem = items.find(item => item.id.toString() === active.id);\n      const overColumn = over.data.current?.type === 'column' ? over.id : over.data.current?.columnId;\n\n      if (activeItem && overColumn && activeItem.status !== overColumn) {\n        try {\n          // Update in Firestore\n          await updateLead(activeItem.id.toString(), { status: overColumn as string });\n          \n          // Update local state\n          setItems(items.map(item => \n            item.id.toString() === active.id\n              ? { ...item, status: overColumn as string }\n              : item\n          ));\n        } catch (err) {\n          console.error('Error updating lead status:', err);\n          // You might want to show a toast notification here\n        }\n      }\n    }\n\n    setActiveId(null);\n    setActiveColumnId(null);\n  };\n\n  if (loading) {\n    return <div className=\"py-10 text-center\">Loading leads...</div>;\n  }\n\n  if (error) {\n    return <div className=\"py-10 text-center text-red-500\">{error}</div>;\n  }\n\n  return (\n    <DndContext\n      sensors={sensors}\n      collisionDetection={closestCorners}\n      onDragStart={handleDragStart}\n      onDragEnd={handleDragEnd}\n    >\n      {/* Summary Statistics */}\n      <div className=\"grid grid-cols-4 gap-4 mb-8\">\n        <Card className=\"p-4 border-l-4 border-l-blue-600\">\n          <div className=\"flex items-center justify-between\">\n            <div>\n              <p className=\"text-sm font-medium text-muted-foreground\">Total Leads</p>\n              <p className=\"text-2xl font-bold\">{totalLeads}</p>\n            </div>\n            <Users className=\"w-8 h-8 text-blue-600\" />\n          </div>\n        </Card>\n        \n        <Card className=\"p-4 border-l-4 border-l-emerald-600\">\n          <div className=\"flex items-center justify-between\">\n            <div>\n              <p className=\"text-sm font-medium text-muted-foreground\">Conversion Rate</p>\n              <p className=\"text-2xl font-bold\">{conversionRate}%</p>\n            </div>\n            <BarChart className=\"w-8 h-8 text-emerald-600\" />\n          </div>\n        </Card>\n        \n        <Card className=\"p-4 border-l-4 border-l-indigo-600\">\n          <div className=\"flex items-center justify-between\">\n            <div>\n              <p className=\"text-sm font-medium text-muted-foreground\">Pipeline Value</p>\n              <p className=\"text-2xl font-bold\">{formatCurrency(totalValue)}</p>\n            </div>\n            <DollarSign className=\"w-8 h-8 text-indigo-600\" />\n          </div>\n        </Card>\n        \n        <Card className=\"p-4 border-l-4 border-l-slate-600\">\n          <div className=\"flex items-center justify-between\">\n            <div>\n              <p className=\"text-sm font-medium text-muted-foreground\">Qualified Leads</p>\n              <p className=\"text-2xl font-bold\">{qualifiedLeads}</p>\n            </div>\n            <TrendingUp className=\"w-8 h-8 text-slate-600\" />\n          </div>\n        </Card>\n      </div>\n\n      <div className=\"mb-4 flex justify-between items-center\">\n        <div className=\"flex items-center space-x-2\">\n          <Button onClick={() => {}} className=\"bg-blue-600 hover:bg-blue-700\">\n            <Plus className=\"w-4 h-4 mr-2\" />\n            Add Lead\n          </Button>\n          <Button variant=\"outline\" className=\"border-slate-200\">\n            <SlidersHorizontal className=\"w-4 h-4 mr-2\" />\n            Filters\n          </Button>\n        </div>\n      </div>\n\n      <div className=\"relative overflow-x-auto pb-4\">\n        <SortableContext\n          items={columns.map(col => col.id)}\n          strategy={horizontalListSortingStrategy}\n        >\n          <div className=\"flex space-x-6 min-w-full\" style={{ width: `${columns.length * 320}px` }}>\n            {columns.map((column) => (\n              <div key={column.id} className=\"w-[300px] flex-shrink-0\">\n                <KanbanColumn\n                  id={column.id}\n                  title={column.title}\n                  color={column.color}\n                  onTitleChange={(newTitle) => {\n                    setColumns(columns.map(col =>\n                      col.id === column.id ? { ...col, title: newTitle } : col\n                    ));\n                  }}\n                  onColorChange={(newColor) => {\n                    setColumns(columns.map(col =>\n                      col.id === column.id ? { ...col, color: newColor } : col\n                    ));\n                  }}\n                  onDelete={() => {\n                    setColumns(columns.filter(col => col.id !== column.id));\n                    // Move leads in deleted column to New\n                    setItems(items.map(item =>\n                      item.status === column.id\n                        ? { ...item, status: 'New' }\n                        : item\n                    ));\n                  }}\n                  availableColors={availableColors}\n                  isDeletable={column.id !== 'New'}\n                >\n                  <SortableContext\n                    items={items\n                      .filter(item => item.status === column.id)\n                      .map(item => item.id.toString())}\n                    strategy={verticalListSortingStrategy}\n                  >\n                    {items\n                      .filter(item => \n                        item.status === column.id &&\n                        (item.name.toLowerCase().includes(searchTerm.toLowerCase()) ||\n                         item.company.toLowerCase().includes(searchTerm.toLowerCase()))\n                      )\n                      .map((item) => (\n                        <KanbanCard\n                          key={item.id}\n                          id={item.id.toString()}\n                          lead={item}\n                          columnColor={column.color}\n                        />\n                      ))\n                    }\n                  </SortableContext>\n                </KanbanColumn>\n              </div>\n            ))}\n          </div>\n        </SortableContext>\n      </div>\n\n      <DragOverlay>\n        {activeId ? (\n          <KanbanCard\n            id={activeId}\n            lead={items.find(item => item.id.toString() === activeId)!}\n            columnColor={columns.find(col => col.id === items.find(item => \n              item.id.toString() === activeId\n            )?.status)?.color || ''}\n          />\n        ) : null}\n      </DragOverlay>\n    </DndContext>\n  );\n}"
        }
    ]
}